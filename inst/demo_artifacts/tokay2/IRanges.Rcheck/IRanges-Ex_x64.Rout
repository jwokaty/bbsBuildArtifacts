
R version 4.1.0 (2021-05-18) -- "Camp Pontanezen"
Copyright (C) 2021 The R Foundation for Statistical Computing
Platform: x86_64-w64-mingw32/x64 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "IRanges"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> options(pager = "console")
> base::assign(".ExTimings", "IRanges-Ex.timings", pos = 'CheckExEnv')
> base::cat("name\tuser\tsystem\telapsed\n", file=base::get(".ExTimings", pos = 'CheckExEnv'))
> base::assign(".format_ptime",
+ function(x) {
+   if(!is.na(x[4L])) x[1L] <- x[1L] + x[4L]
+   if(!is.na(x[5L])) x[2L] <- x[2L] + x[5L]
+   options(OutDec = '.')
+   format(x[1L:3L], digits = 7L)
+ },
+ pos = 'CheckExEnv')
> 
> ### * </HEADER>
> library('IRanges')
Loading required package: BiocGenerics
Loading required package: parallel

Attaching package: 'BiocGenerics'

The following objects are masked from 'package:parallel':

    clusterApply, clusterApplyLB, clusterCall, clusterEvalQ,
    clusterExport, clusterMap, parApply, parCapply, parLapply,
    parLapplyLB, parRapply, parSapply, parSapplyLB

The following objects are masked from 'package:stats':

    IQR, mad, sd, var, xtabs

The following objects are masked from 'package:base':

    Filter, Find, Map, Position, Reduce, anyDuplicated, append,
    as.data.frame, basename, cbind, colnames, dirname, do.call,
    duplicated, eval, evalq, get, grep, grepl, intersect, is.unsorted,
    lapply, mapply, match, mget, order, paste, pmax, pmax.int, pmin,
    pmin.int, rank, rbind, rownames, sapply, setdiff, sort, table,
    tapply, union, unique, unsplit, which.max, which.min

Loading required package: S4Vectors
Loading required package: stats4

Attaching package: 'S4Vectors'

The following objects are masked from 'package:base':

    I, expand.grid, unname


Attaching package: 'IRanges'

The following object is masked from 'package:grDevices':

    windows

> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("AtomicList-class")
> ### * AtomicList-class
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: AtomicList
> ### Title: Lists of Atomic Vectors in Natural and Rle Form
> ### Aliases: class:AtomicList AtomicList-class AtomicList
> ###   class:CompressedAtomicList CompressedAtomicList-class
> ###   CompressedAtomicList class:SimpleAtomicList SimpleAtomicList-class
> ###   SimpleAtomicList class:LogicalList LogicalList-class LogicalList
> ###   class:CompressedLogicalList CompressedLogicalList-class
> ###   CompressedLogicalList class:SimpleLogicalList SimpleLogicalList-class
> ###   SimpleLogicalList class:IntegerList IntegerList-class IntegerList
> ###   class:CompressedIntegerList CompressedIntegerList-class
> ###   CompressedIntegerList class:SimpleIntegerList SimpleIntegerList-class
> ###   SimpleIntegerList class:NumericList NumericList-class NumericList
> ###   class:CompressedNumericList CompressedNumericList-class
> ###   CompressedNumericList class:SimpleNumericList SimpleNumericList-class
> ###   SimpleNumericList class:ComplexList ComplexList-class ComplexList
> ###   class:CompressedComplexList CompressedComplexList-class
> ###   CompressedComplexList class:SimpleComplexList SimpleComplexList-class
> ###   SimpleComplexList class:CharacterList CharacterList-class
> ###   CharacterList class:CompressedCharacterList
> ###   CompressedCharacterList-class CompressedCharacterList
> ###   class:SimpleCharacterList SimpleCharacterList-class
> ###   SimpleCharacterList class:RawList RawList-class RawList
> ###   class:CompressedRawList CompressedRawList-class CompressedRawList
> ###   class:SimpleRawList SimpleRawList-class SimpleRawList class:RleList
> ###   RleList-class RleList class:CompressedRleList CompressedRleList-class
> ###   CompressedRleList class:SimpleRleList SimpleRleList-class
> ###   SimpleRleList class:FactorList FactorList-class FactorList
> ###   class:CompressedFactorList CompressedFactorList-class
> ###   CompressedFactorList class:SimpleFactorList SimpleFactorList-class
> ###   SimpleFactorList as.list,CompressedAtomicList-method
> ###   coerce,CompressedAtomicList,list-method as.vector,AtomicList-method
> ###   coerce,vector,AtomicList-method as.matrix,AtomicList-method
> ###   lapply,CompressedAtomicList-method
> ###   coerce,vector,CompressedLogicalList-method
> ###   coerce,vector,SimpleLogicalList-method
> ###   coerce,vector,CompressedIntegerList-method
> ###   coerce,vector,SimpleIntegerList-method
> ###   coerce,vector,CompressedNumericList-method
> ###   coerce,vector,SimpleNumericList-method
> ###   coerce,vector,CompressedComplexList-method
> ###   coerce,vector,SimpleComplexList-method
> ###   coerce,vector,CompressedCharacterList-method
> ###   coerce,vector,SimpleCharacterList-method
> ###   coerce,vector,CompressedRawList-method
> ###   coerce,vector,SimpleRawList-method
> ###   coerce,vector,CompressedRleList-method
> ###   coerce,vector,SimpleRleList-method
> ###   coerce,AtomicList,LogicalList-method
> ###   coerce,AtomicList,IntegerList-method
> ###   coerce,AtomicList,NumericList-method
> ###   coerce,AtomicList,ComplexList-method
> ###   coerce,AtomicList,CharacterList-method
> ###   coerce,AtomicList,RawList-method coerce,AtomicList,RleList-method
> ###   RleList,AtomicList,RleList-method coerce,AtomicList,RleViews
> ###   unlist,SimpleFactorList-method unlist,SimpleRleList-method
> ###   unique,RleList-method unique,CompressedList-method
> ###   table,AtomicList-method table,SimpleAtomicList-method
> ###   drop,AtomicList-method duplicated,CompressedList-method
> ###   duplicated,CompressedAtomicList-method sort,List-method
> ###   order,List-method rank,List-method runLength,RleList-method
> ###   runValue,RleList-method runLength,CompressedRleList-method
> ###   runValue,CompressedRleList-method runValue<-,CompressedRleList-method
> ###   runValue<-,SimpleRleList-method ranges,RleList-method
> ###   ranges,CompressedRleList-method show,AtomicList-method
> ###   show,RleList-method
> ### Keywords: methods classes
> 
> ### ** Examples
> 
> int1 <- c(1L,2L,3L,5L,2L,8L)
> int2 <- c(15L,45L,20L,1L,15L,100L,80L,5L)
> collection <- IntegerList(int1, int2)
> 
> ## names
> names(collection) <- c("one", "two")
> names(collection)
[1] "one" "two"
> names(collection) <- NULL # clear names
> names(collection)
NULL
> names(collection) <- "one"
> names(collection) # c("one", NA)
[1] "one" NA   
> 
> ## extraction
> collection[[1]] # range1
[1] 1 2 3 5 2 8
> collection[["1"]] # NULL, does not exist
NULL
> collection[["one"]] # range1
[1] 1 2 3 5 2 8
> collection[[NA_integer_]] # NULL
NULL
> 
> ## subsetting
> collection[numeric()] # empty
IntegerList of length 0
> collection[NULL] # empty
IntegerList of length 0
> collection[] # identity
IntegerList of length 2
[["one"]] 1 2 3 5 2 8
[[NA]] 15 45 20 1 15 100 80 5
> collection[c(TRUE, FALSE)] # first element
IntegerList of length 1
[["one"]] 1 2 3 5 2 8
> collection[2] # second element
IntegerList of length 1
[[NA]] 15 45 20 1 15 100 80 5
> collection[c(2,1)] # reversed
IntegerList of length 2
[[NA]] 15 45 20 1 15 100 80 5
[["one"]] 1 2 3 5 2 8
> collection[-1] # drop first
IntegerList of length 1
[[NA]] 15 45 20 1 15 100 80 5
> collection$one
[1] 1 2 3 5 2 8
> 
> ## replacement
> collection$one <- int2
> collection[[2]] <- int1
> 
> ## concatenating
> col1 <- IntegerList(one = int1, int2)
> col2 <- IntegerList(two = int2, one = int1)
> col3 <- IntegerList(int2)
> append(col1, col2)
IntegerList of length 4
[["one"]] 1 2 3 5 2 8
[[""]] 15 45 20 1 15 100 80 5
[["two"]] 15 45 20 1 15 100 80 5
[["one"]] 1 2 3 5 2 8
> append(col1, col2, 0)
IntegerList of length 4
[["two"]] 15 45 20 1 15 100 80 5
[["one"]] 1 2 3 5 2 8
[["one"]] 1 2 3 5 2 8
[[""]] 15 45 20 1 15 100 80 5
> col123 <- c(col1, col2, col3)
> col123
IntegerList of length 5
[["one"]] 1 2 3 5 2 8
[[""]] 15 45 20 1 15 100 80 5
[["two"]] 15 45 20 1 15 100 80 5
[["one"]] 1 2 3 5 2 8
[[""]] 15 45 20 1 15 100 80 5
> 
> ## revElements
> revElements(col123)
IntegerList of length 5
[["one"]] 8 2 5 3 2 1
[[""]] 5 80 100 15 1 20 45 15
[["two"]] 5 80 100 15 1 20 45 15
[["one"]] 8 2 5 3 2 1
[[""]] 5 80 100 15 1 20 45 15
> revElements(col123, 4:5)
IntegerList of length 5
[["one"]] 1 2 3 5 2 8
[[""]] 15 45 20 1 15 100 80 5
[["two"]] 15 45 20 1 15 100 80 5
[["one"]] 8 2 5 3 2 1
[[""]] 5 80 100 15 1 20 45 15
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("AtomicList-class", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("AtomicList-utils")
> ### * AtomicList-utils
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: AtomicList-utils
> ### Title: Common operations on AtomicList objects
> ### Aliases: AtomicList-utils Ops,AtomicList,AtomicList-method
> ###   Ops,CompressedAtomicList,CompressedAtomicList-method
> ###   Ops,SimpleAtomicList,CompressedAtomicList-method
> ###   Ops,CompressedAtomicList,SimpleAtomicList-method
> ###   Ops,AtomicList,atomic-method Ops,atomic,AtomicList-method
> ###   Ops,AtomicList,missing-method Ops,CompressedAtomicList,atomic-method
> ###   Ops,atomic,CompressedAtomicList-method Math,AtomicList-method
> ###   Math,CompressedAtomicList-method Math2,AtomicList-method
> ###   Math2,CompressedAtomicList-method Summary,AtomicList-method
> ###   Summary,CompressedRleList-method Complex,AtomicList-method
> ###   Complex,CompressedAtomicList-method sum,CompressedIntegerList-method
> ###   sum,CompressedLogicalList-method sum,CompressedNumericList-method
> ###   which,CompressedLogicalList-method which,SimpleLogicalList-method
> ###   which,CompressedRleList-method which,SimpleRleList-method
> ###   which.max,CompressedRleList-method which.max,RleList-method
> ###   which.max,IntegerList-method which.max,NumericList-method
> ###   which.min,CompressedRleList-method which.min,RleList-method
> ###   which.min,IntegerList-method which.min,NumericList-method
> ###   all,CompressedRleList-method all,CompressedAtomicList-method
> ###   any,CompressedAtomicList-method anyNA,CompressedAtomicList-method
> ###   diff.AtomicList diff,CompressedAtomicList-method
> ###   pmax,IntegerList-method pmax,NumericList-method pmax,RleList-method
> ###   pmin,IntegerList-method pmin,NumericList-method pmin,RleList-method
> ###   pmax.int,IntegerList-method pmax.int,NumericList-method
> ###   pmax.int,RleList-method pmin.int,IntegerList-method
> ###   pmin.int,NumericList-method pmin.int,RleList-method
> ###   mean,AtomicList-method mean,CompressedLogicalList-method
> ###   mean,CompressedIntegerList-method mean,CompressedNumericList-method
> ###   mean,CompressedRleList-method var,AtomicList,missing-method
> ###   var,AtomicList,AtomicList-method cov,AtomicList,AtomicList-method
> ###   cor,AtomicList,AtomicList-method sd,AtomicList-method
> ###   median,AtomicList-method median,CompressedAtomicList-method
> ###   quantile,AtomicList-method mad,AtomicList-method
> ###   IQR,AtomicList-method cumsum,CompressedAtomicList-method
> ###   cumprod,CompressedAtomicList-method
> ###   cummin,CompressedAtomicList-method cummax,CompressedAtomicList-method
> ###   range,CompressedIntegerList-method range,CompressedNumericList-method
> ###   range,CompressedLogicalList-method
> ###   smoothEnds,CompressedIntegerList-method
> ###   smoothEnds,SimpleIntegerList-method smoothEnds,NumericList-method
> ###   smoothEnds,RleList-method runmed,CompressedIntegerList-method
> ###   runmed,SimpleIntegerList-method runmed,NumericList-method
> ###   runmed,RleList-method runmean,RleList-method runsum,RleList-method
> ###   runwtsum,RleList-method runq,RleList-method
> ###   nchar,CompressedCharacterList-method nchar,SimpleCharacterList-method
> ###   nchar,CompressedRleList-method nchar,SimpleRleList-method
> ###   chartr,ANY,ANY,CompressedCharacterList-method
> ###   chartr,ANY,ANY,SimpleCharacterList-method
> ###   chartr,ANY,ANY,CompressedRleList-method
> ###   chartr,ANY,ANY,SimpleRleList-method
> ###   tolower,CompressedCharacterList-method
> ###   tolower,SimpleCharacterList-method tolower,CompressedRleList-method
> ###   tolower,SimpleRleList-method toupper,CompressedCharacterList-method
> ###   toupper,SimpleCharacterList-method toupper,CompressedRleList-method
> ###   toupper,SimpleRleList-method
> ###   sub,ANY,ANY,CompressedCharacterList-method
> ###   sub,ANY,ANY,SimpleCharacterList-method
> ###   sub,ANY,ANY,CompressedRleList-method sub,ANY,ANY,SimpleRleList-method
> ###   gsub,ANY,ANY,CompressedCharacterList-method
> ###   gsub,ANY,ANY,SimpleCharacterList-method
> ###   gsub,ANY,ANY,CompressedRleList-method
> ###   gsub,ANY,ANY,SimpleRleList-method unstrsplit,CharacterList-method
> ###   unstrsplit,RleList-method paste,CompressedAtomicList-method
> ###   startsWith,CharacterList,ANY-method startsWith,RleList,ANY-method
> ###   endsWith,CharacterList,ANY-method endsWith,RleList,ANY-method
> ###   rank,CompressedAtomicList-method order,CompressedAtomicList-method
> ###   selfmatch,CompressedAtomicList-method
> ###   intersect,CompressedAtomicList,CompressedAtomicList-method ifelse2
> ###   ifelse2,ANY,ANY,List-method ifelse2,ANY,List,ANY-method
> ###   ifelse2,List,ANY,ANY-method
> ###   ifelse2,CompressedLogicalList,ANY,ANY-method
> ###   ifelse2,CompressedLogicalList,List,ANY-method
> ###   ifelse2,CompressedLogicalList,ANY,List-method
> ###   ifelse2,CompressedLogicalList,List,ANY-method
> ###   ifelse2,CompressedLogicalList,List,List-method
> ###   ifelse2,SimpleLogicalList,ANY,ANY-method
> ###   ifelse2,SimpleLogicalList,List,ANY-method
> ###   ifelse2,SimpleLogicalList,ANY,List-method
> ###   ifelse2,SimpleLogicalList,List,ANY-method
> ###   ifelse2,SimpleLogicalList,List,List-method
> ### Keywords: methods
> 
> ### ** Examples
> 
> ## group generics
> int1 <- c(1L,2L,3L,5L,2L,8L)
> int2 <- c(15L,45L,20L,1L,15L,100L,80L,5L)
> col1 <- IntegerList(one = int1, int2)
> 2 * col1
NumericList of length 2
[["one"]] 2 4 6 10 4 16
[[""]] 30 90 40 2 30 200 160 10
> col1 + col1
IntegerList of length 2
[["one"]] 2 4 6 10 4 16
[[""]] 30 90 40 2 30 200 160 10
> col1 > 2
LogicalList of length 2
[["one"]] FALSE FALSE TRUE TRUE FALSE TRUE
[[""]] TRUE TRUE TRUE FALSE TRUE TRUE TRUE TRUE
> sum(col1)  # equivalent to (but faster than) 'sapply(col1, sum)'
one     
 21 281 
> mean(col1)  # equivalent to 'sapply(col1, mean)'
   one        
 3.500 35.125 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("AtomicList-utils", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("CompressedList-class")
> ### * CompressedList-class
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: CompressedList-class
> ### Title: CompressedList objects
> ### Aliases: class:CompressedList CompressedList CompressedList-class
> ###   length,CompressedList-method names,CompressedList-method
> ###   names<-,CompressedList-method elementNROWS,CompressedList-method
> ###   is.na,CompressedList-method unlist,CompressedList-method
> ###   coerce,ANY,CompressedList-method bindROWS,CompressedList-method
> ###   lapply,CompressedList-method revElements,CompressedList-method
> ###   classNameForDisplay,CompressedList-method !,CompressedList-method
> ###   match,CompressedList,vector-method
> ### Keywords: methods classes
> 
> ### ** Examples
> 
> ## Fastest way to construct a CompressedList object:
> unlisted <- runif(12)
> partitioning <- PartitioningByEnd(c(5, 5, 10, 12), names=LETTERS[1:4])
> partitioning
PartitioningByEnd object with 4 ranges and 0 metadata columns:
        start       end     width
    <integer> <integer> <integer>
  A         1         5         5
  B         6         5         0
  C         6        10         5
  D        11        12         2
> 
> x1 <- relist(unlisted, partitioning)
> x1
NumericList of length 4
[["A"]] 0.2655086631421 0.37212389963679 ... 0.201681931037456
[["B"]] numeric(0)
[["C"]] 0.898389684967697 0.944675268605351 ... 0.0617862704675645
[["D"]] 0.205974574899301 0.176556752528995
> 
> stopifnot(identical(lengths(partitioning), lengths(x1)))
> 
> ## Note that the class of the CompressedList derivative returned by
> ## relist() is determined by relistToClass():
> relistToClass(unlisted)
[1] "CompressedNumericList"
> stopifnot(relistToClass(unlisted) == class(x1))
> 
> ## Displaying a CompressedList object:
> x2 <- IntegerList(11:12, integer(0), 3:-2, compress=TRUE)
> class(x2)
[1] "CompressedIntegerList"
attr(,"package")
[1] "IRanges"
> 
> ## The "Simple" prefix is removed from the real class name of the
> ## object:
> x2
IntegerList of length 3
[[1]] 11 12
[[2]] integer(0)
[[3]] 3 2 1 0 -1 -2
> 
> ## This is controlled by internal helper classNameForDisplay():
> classNameForDisplay(x2)
[1] "IntegerList"
attr(,"package")
[1] "IRanges"
> classNameForDisplay(x1)
[1] "NumericList"
attr(,"package")
[1] "IRanges"
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("CompressedList-class", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("DataFrameList-class")
> ### * DataFrameList-class
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: DataFrameList-class
> ### Title: List of DataFrames
> ### Aliases: class:DataFrameList DataFrameList-class DataFrameList
> ###   class:DFrameList DFrameList-class DFrameList
> ###   class:SimpleDataFrameList SimpleDataFrameList-class
> ###   SimpleDataFrameList class:SimpleDFrameList SimpleDFrameList-class
> ###   SimpleDFrameList class:SplitDataFrameList SplitDataFrameList-class
> ###   SplitDataFrameList class:SplitDFrameList SplitDFrameList-class
> ###   SplitDFrameList class:SimpleSplitDataFrameList
> ###   SimpleSplitDataFrameList-class SimpleSplitDataFrameList
> ###   class:SimpleSplitDFrameList SimpleSplitDFrameList-class
> ###   SimpleSplitDFrameList class:CompressedDataFrameList
> ###   CompressedDataFrameList-class CompressedDataFrameList
> ###   class:CompressedDFrameList CompressedDFrameList-class
> ###   CompressedDFrameList class:CompressedSplitDataFrameList
> ###   CompressedSplitDataFrameList-class CompressedSplitDataFrameList
> ###   class:CompressedSplitDFrameList CompressedSplitDFrameList-class
> ###   CompressedSplitDFrameList nrow,DataFrameList-method
> ###   ncol,DataFrameList-method ncol,CompressedSplitDataFrameList-method
> ###   ncol,SimpleSplitDataFrameList-method dim,DataFrameList-method
> ###   rownames,DataFrameList-method colnames,DataFrameList-method
> ###   colnames,SplitDataFrameList-method
> ###   colnames,CompressedSplitDataFrameList-method
> ###   dimnames,DataFrameList-method
> ###   rownames<-,CompressedSplitDataFrameList-method
> ###   rownames<-,SimpleDataFrameList-method
> ###   colnames<-,CompressedSplitDataFrameList-method
> ###   colnames<-,SimpleDataFrameList-method dimnames<-,DataFrameList-method
> ###   NROW,DataFrameList-method ROWNAMES,DataFrameList-method
> ###   ROWNAMES<-,DataFrameList-method columnMetadata columnMetadata<-
> ###   columnMetadata,SimpleSplitDataFrameList-method
> ###   columnMetadata<-,SimpleSplitDataFrameList-method
> ###   columnMetadata,CompressedSplitDataFrameList-method
> ###   columnMetadata<-,CompressedSplitDataFrameList-method commonColnames
> ###   commonColnames<- commonColnames,SimpleSplitDataFrameList-method
> ###   commonColnames<-,SimpleSplitDataFrameList-method
> ###   commonColnames,CompressedSplitDataFrameList-method
> ###   commonColnames<-,CompressedSplitDataFrameList-method
> ###   [,SimpleSplitDataFrameList-method
> ###   [,CompressedSplitDataFrameList-method [<-,SplitDataFrameList-method
> ###   transform,SplitDataFrameList-method coerce,ANY,DataFrameList-method
> ###   coerce,ANY,SimpleDataFrameList-method
> ###   coerce,ANY,SplitDataFrameList-method
> ###   coerce,ANY,SimpleSplitDataFrameList-method
> ###   coerce,ANY,CompressedDataFrameList-method
> ###   coerce,ANY,CompressedSplitDataFrameList-method
> ###   coerce,DataFrameList,DFrame-method
> ###   coerce,SplitDataFrameList,DFrame-method
> ###   coerce,ANY,CompressedSplitDFrameList-method
> ###   coerce,ANY,SimpleSplitDFrameList-method
> ###   coerce,List,CompressedSplitDFrameList-method
> ###   coerce,list,SplitDFrameList-method
> ###   coerce,List,SimpleSplitDFrameList-method
> ###   coerce,ANY,SplitDFrameList-method
> ###   coerce,SimpleList,SplitDFrameList-method
> ###   coerce,list,SplitDFrameList-method
> ###   coerce,DataFrame,SplitDFrameList-method stack,DataFrameList-method
> ###   cbind,DataFrameList-method rbind,DataFrameList-method
> ###   classNameForDisplay,SimpleDFrameList-method
> ###   classNameForDisplay,CompressedDFrameList-method
> ###   show,SplitDataFrameList-method
> ###   colnames,SDFLWrapperForTransform-method
> ###   [[,SDFLWrapperForTransform-method [[<-,SDFLWrapperForTransform-method
> ###   as.env,SDFLWrapperForTransform-method
> ### Keywords: methods classes
> 
> ### ** Examples
> 
> # Making a DataFrameList, which has different columns.
> out <- DataFrameList(DataFrame(X=1, Y=2), DataFrame(A=1:2, B=3:4))
> out[[1]]
DataFrame with 1 row and 2 columns
          X         Y
  <numeric> <numeric>
1         1         2
> 
> # A more interesting SplitDataFrameList, which is guaranteed
> # to have the same columns.
> out <- SplitDataFrameList(DataFrame(X=1, Y=2), DataFrame(X=1:2, Y=3:4))
> out[[1]]
DataFrame with 1 row and 2 columns
          X         Y
  <numeric> <numeric>
1         1         2
> out[,"X"]
NumericList of length 2
[[1]] 1
[[2]] 1 2
> out[,"Y"]
NumericList of length 2
[[1]] 2
[[2]] 3 4
> 
> commonColnames(out)
[1] "X" "Y"
> commonColnames(out) <- c("x", "y")
> out[[1]]
DataFrame with 1 row and 2 columns
          x         y
  <numeric> <numeric>
1         1         2
> 
> # We can also create these split objects using various split() functions:
> out <- splitAsList(DataFrame(X=runif(100), Y=rpois(100, 5)), 
+     sample(letters, 100, replace=TRUE))
> out[['a']]
DataFrame with 2 rows and 2 columns
          X         Y
  <numeric> <integer>
1  0.794240         5
2  0.438097         4
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("DataFrameList-class", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("Grouping-class")
> ### * Grouping-class
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: Grouping-class
> ### Title: Grouping objects
> ### Aliases: class:Grouping Grouping-class Grouping nobj grouplengths
> ###   grouplengths,Grouping-method grouplengths,CompressedGrouping-method
> ###   show,Grouping-method class:ManyToOneGrouping ManyToOneGrouping-class
> ###   ManyToOneGrouping nobj,ManyToOneGrouping-method
> ###   nobj,CompressedManyToOneGrouping-method members
> ###   members,ManyToOneGrouping-method vmembers
> ###   vmembers,ManyToOneGrouping-method togroup
> ###   togroup,ManyToOneGrouping-method togrouplength
> ###   togrouplength,ManyToOneGrouping-method
> ###   coerce,grouping,Grouping-method
> ###   coerce,grouping,ManyToOneGrouping-method
> ###   coerce,vector,Grouping-method coerce,vector,ManyToOneGrouping-method
> ###   coerce,ManyToOneGrouping,factor-method
> ###   coerce,DataFrame,Grouping-method coerce,FactorList,Grouping-method
> ###   coerce,Hits,Grouping-method nobj,BaseManyToManyGrouping-method
> ###   coerce,vector,ManyToManyGrouping-method class:H2LGrouping
> ###   H2LGrouping-class H2LGrouping high2low high2low,H2LGrouping-method
> ###   high2low,ANY-method low2high low2high,H2LGrouping-method
> ###   length,H2LGrouping-method nobj,H2LGrouping-method
> ###   grouplengths,H2LGrouping-method members,H2LGrouping-method
> ###   vmembers,H2LGrouping-method togroup,H2LGrouping-method grouprank
> ###   grouprank,H2LGrouping-method togrouprank
> ###   togrouprank,H2LGrouping-method length<-,H2LGrouping-method class:Dups
> ###   Dups-class Dups duplicated,Dups-method show,Dups-method
> ###   class:ManyToManyGrouping ManyToManyGrouping-class ManyToManyGrouping
> ###   nobj,ManyToManyGrouping-method class:GroupingRanges
> ###   GroupingRanges-class GroupingRanges
> ###   grouplengths,GroupingRanges-method class:GroupingIRanges
> ###   GroupingIRanges-class GroupingIRanges class:Partitioning
> ###   Partitioning-class Partitioning
> ###   parallel_slot_names,Partitioning-method
> ###   extractROWS,Partitioning-method bindROWS,Partitioning-method
> ###   togroup,Partitioning-method names,Partitioning-method
> ###   names<-,Partitioning-method class:PartitioningByEnd
> ###   PartitioningByEnd-class PartitioningByEnd
> ###   parallel_slot_names,PartitioningByEnd-method
> ###   end,PartitioningByEnd-method length,PartitioningByEnd-method
> ###   nobj,PartitioningByEnd-method start,PartitioningByEnd-method
> ###   width,PartitioningByEnd-method
> ###   coerce,IntegerRanges,PartitioningByEnd-method
> ###   class:PartitioningByWidth PartitioningByWidth-class
> ###   PartitioningByWidth parallel_slot_names,PartitioningByWidth-method
> ###   width,PartitioningByWidth-method length,PartitioningByWidth-method
> ###   end,PartitioningByWidth-method start,PartitioningByWidth-method
> ###   coerce,IntegerRanges,PartitioningByWidth-method class:PartitioningMap
> ###   PartitioningMap-class PartitioningMap mapOrder
> ###   mapOrder,PartitioningMap-method show,PartitioningMap-method
> ###   class:SimpleGrouping SimpleGrouping-class class:CompressedGrouping
> ###   CompressedGrouping-class class:SimpleManyToOneGrouping
> ###   SimpleManyToOneGrouping-class class:CompressedManyToOneGrouping
> ###   CompressedManyToOneGrouping-class class:SimpleManyToManyGrouping
> ###   SimpleManyToManyGrouping-class class:CompressedManyToManyGrouping
> ###   CompressedManyToManyGrouping-class togroup,ANY-method
> ### Keywords: methods classes
> 
> ### ** Examples
> 
> showClass("Grouping")  # shows (some of) the known subclasses
Virtual Class "Grouping" [package "IRanges"]

Slots:
                                                            
Name:        elementType   elementMetadata          metadata
Class:         character DataFrame_OR_NULL              list

Extends: 
Class "IntegerList", directly
Class "AtomicList", by class "IntegerList", distance 2
Class "List", by class "IntegerList", distance 3
Class "Vector", by class "IntegerList", distance 4
Class "list_OR_List", by class "IntegerList", distance 4
Class "Annotated", by class "IntegerList", distance 5
Class "vector_OR_Vector", by class "IntegerList", distance 5

Known Subclasses: 
Class "ManyToOneGrouping", directly
Class "ManyToManyGrouping", directly
Class "GroupingRanges", directly
Class "SimpleGrouping", directly
Class "CompressedGrouping", directly
Class "H2LGrouping", by class "ManyToOneGrouping", distance 2
Class "Partitioning", by class "ManyToOneGrouping", distance 2
Class "SimpleManyToOneGrouping", by class "ManyToOneGrouping", distance 2
Class "BaseManyToManyGrouping", by class "ManyToManyGrouping", distance 2
Class "GroupingIRanges", by class "GroupingRanges", distance 2
Class "Partitioning", by class "GroupingRanges", distance 2
Class "SimpleManyToOneGrouping", by class "SimpleGrouping", distance 2
Class "SimpleManyToManyGrouping", by class "SimpleGrouping", distance 2
Class "Dups", by class "ManyToOneGrouping", distance 3
Class "PartitioningByEnd", by class "ManyToOneGrouping", distance 3
Class "PartitioningByWidth", by class "ManyToOneGrouping", distance 3
Class "SimpleManyToManyGrouping", by class "ManyToManyGrouping", distance 3
Class "PartitioningByEnd", by class "GroupingRanges", distance 3
Class "PartitioningByWidth", by class "GroupingRanges", distance 3
Class "PartitioningMap", by class "ManyToOneGrouping", distance 4
Class "PartitioningMap", by class "GroupingRanges", distance 4
Class "CompressedManyToOneGrouping", by class "ManyToOneGrouping", distance 2
Class "CompressedManyToManyGrouping", by class "BaseManyToManyGrouping", distance 3
> 
> ## ---------------------------------------------------------------------
> ## A. H2LGrouping OBJECTS
> ## ---------------------------------------------------------------------
> high2low <- c(NA, NA, 2, 2, NA, NA, NA, 6, NA, 1, 2, NA, 6, NA, NA, 2)
> h2l <- H2LGrouping(high2low)
> h2l
H2LGrouping with 16 groups and 16 objects
Nb of empty groups: 7 (43.75%)
> 
> ## The core Grouping API:
> length(h2l)
[1] 16
> nobj(h2l)  # same as 'length(h2l)' for H2LGrouping objects
[1] 16
> h2l[[1]]
[1]  1 10
> h2l[[2]]
[1]  2  3  4 11 16
> h2l[[3]]
integer(0)
> h2l[[4]]
integer(0)
> h2l[[5]]
[1] 5
> grouplengths(h2l)  # same as 'unname(sapply(h2l, length))'
 [1] 2 5 0 0 1 3 1 0 1 0 0 1 0 1 1 0
> grouplengths(h2l, 5:2)
[1] 1 0 0 5
> members(h2l, 5:2)  # all the members are put together and sorted
[1]  2  3  4  5 11 16
> togroup(h2l)
 [1]  1  2  2  2  5  6  7  6  9  1  2 12  6 14 15  2
> togroup(h2l, 5:2)
[1] 5 2 2 2
> togrouplength(h2l)  # same as 'grouplengths(h2l, togroup(h2l))'
 [1] 2 5 5 5 1 3 1 3 1 2 5 1 3 1 1 5
> togrouplength(h2l, 5:2)
[1] 1 5 5 5
> 
> ## The List API:
> as.list(h2l)
[[1]]
[1]  1 10

[[2]]
[1]  2  3  4 11 16

[[3]]
integer(0)

[[4]]
integer(0)

[[5]]
[1] 5

[[6]]
[1]  6  8 13

[[7]]
[1] 7

[[8]]
integer(0)

[[9]]
[1] 9

[[10]]
integer(0)

[[11]]
integer(0)

[[12]]
[1] 12

[[13]]
integer(0)

[[14]]
[1] 14

[[15]]
[1] 15

[[16]]
integer(0)

> sapply(h2l, length)
 [1] 2 5 0 0 1 3 1 0 1 0 0 1 0 1 1 0
> 
> ## ---------------------------------------------------------------------
> ## B. Dups OBJECTS
> ## ---------------------------------------------------------------------
> dups1 <- as(h2l, "Dups")
> dups1
Dups of length 16 (43.75% of duplicates)
> duplicated(dups1)  # same as 'duplicated(togroup(dups1))'
 [1] FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE  TRUE FALSE  TRUE  TRUE FALSE
[13]  TRUE FALSE FALSE  TRUE
> 
> ### The purpose of a Dups object is to describe the groups of duplicated
> ### elements in a vector-like object:
> x <- c(2, 77, 4, 4, 7, 2, 8, 8, 4, 99)
> x_high2low <- high2low(x)
> x_high2low  # same length as 'x'
 [1] NA NA NA  3 NA  1 NA  7  3 NA
> dups2 <- Dups(x_high2low)
> dups2
Dups of length 10 (40% of duplicates)
> togroup(dups2)
 [1]  1  2  3  3  5  1  7  7  3 10
> duplicated(dups2)
 [1] FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE  TRUE  TRUE FALSE
> togrouplength(dups2)  # frequency for each element
 [1] 2 1 3 3 1 2 2 2 3 1
> table(x)
x
 2  4  7  8 77 99 
 2  3  1  2  1  1 
> 
> ## ---------------------------------------------------------------------
> ## C. Partitioning OBJECTS
> ## ---------------------------------------------------------------------
> pbe1 <- PartitioningByEnd(c(4, 7, 7, 8, 15), names=LETTERS[1:5])
> pbe1  # the 3rd partition is empty
PartitioningByEnd object with 5 ranges and 0 metadata columns:
        start       end     width
    <integer> <integer> <integer>
  A         1         4         4
  B         5         7         3
  C         8         7         0
  D         8         8         1
  E         9        15         7
> 
> ## The core Grouping API:
> length(pbe1)
[1] 5
> nobj(pbe1)
[1] 15
> pbe1[[1]]
[1] 1 2 3 4
> pbe1[[2]]
[1] 5 6 7
> pbe1[[3]]
integer(0)
> grouplengths(pbe1)  # same as 'unname(sapply(pbe1, length))'
[1] 4 3 0 1 7
>                     # and 'width(pbe1)'
> togroup(pbe1)
 [1] 1 1 1 1 2 2 2 4 5 5 5 5 5 5 5
> togrouplength(pbe1)  # same as 'grouplengths(pbe1, togroup(pbe1))'
 [1] 4 4 4 4 3 3 3 1 7 7 7 7 7 7 7
> names(pbe1)
[1] "A" "B" "C" "D" "E"
> 
> ## The IntegerRanges core API:
> start(pbe1)
[1] 1 5 8 8 9
> end(pbe1)
[1]  4  7  7  8 15
> width(pbe1)
[1] 4 3 0 1 7
> 
> ## The List API:
> as.list(pbe1)
$A
[1] 1 2 3 4

$B
[1] 5 6 7

$C
integer(0)

$D
[1] 8

$E
[1]  9 10 11 12 13 14 15

> sapply(pbe1, length)
A B C D E 
4 3 0 1 7 
> 
> ## Replacing the names:
> names(pbe1)[3] <- "empty partition"
> pbe1
PartitioningByEnd object with 5 ranges and 0 metadata columns:
                      start       end     width
                  <integer> <integer> <integer>
                A         1         4         4
                B         5         7         3
  empty partition         8         7         0
                D         8         8         1
                E         9        15         7
> 
> ## Coercion to an IRanges object:
> as(pbe1, "IRanges")
IRanges object with 5 ranges and 0 metadata columns:
                      start       end     width
                  <integer> <integer> <integer>
                A         1         4         4
                B         5         7         3
  empty partition         8         7         0
                D         8         8         1
                E         9        15         7
> 
> ## Other examples:
> PartitioningByEnd(c(0, 0, 19), names=LETTERS[1:3])
PartitioningByEnd object with 3 ranges and 0 metadata columns:
        start       end     width
    <integer> <integer> <integer>
  A         1         0         0
  B         1         0         0
  C         1        19        19
> PartitioningByEnd()  # no partition
PartitioningByEnd object with 0 ranges and 0 metadata columns:
       start       end     width
   <integer> <integer> <integer>
> PartitioningByEnd(integer(9))  # all partitions are empty
PartitioningByEnd object with 9 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         1         0         0
  [2]         1         0         0
  [3]         1         0         0
  [4]         1         0         0
  [5]         1         0         0
  [6]         1         0         0
  [7]         1         0         0
  [8]         1         0         0
  [9]         1         0         0
> x <- c(1L, 5L, 5L, 6L, 8L)
> pbe2 <- PartitioningByEnd(x, NG=10L)
> stopifnot(identical(togroup(pbe2), x))
> pbw2 <- PartitioningByWidth(x, NG=10L)
> stopifnot(identical(togroup(pbw2), x))
> 
> ## ---------------------------------------------------------------------
> ## D. RELATIONSHIP BETWEEN Partitioning OBJECTS AND successiveIRanges()
> ## ---------------------------------------------------------------------
> mywidths <- c(4, 3, 0, 1, 7)
> 
> ## The 3 following calls produce the same ranges:
> ir <- successiveIRanges(mywidths)  # IRanges instance.
> pbe <- PartitioningByEnd(cumsum(mywidths))  # PartitioningByEnd instance.
> pbw <- PartitioningByWidth(mywidths)  # PartitioningByWidth instance.
> stopifnot(identical(as(ir, "PartitioningByEnd"), pbe))
> stopifnot(identical(as(ir, "PartitioningByWidth"), pbw))
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("Grouping-class", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("Hits-class-leftovers")
> ### * Hits-class-leftovers
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: Hits-class-leftovers
> ### Title: Examples of basic manipulation of Hits objects
> ### Aliases: Hits-examples
> ###   coerce,SortedByQueryHits,PartitioningByEnd-method
> ###   coerce,SortedByQueryHits,Partitioning-method
> ###   coerce,SortedByQueryHits,IntegerRanges-method
> ###   coerce,SortedByQueryHits,IRanges-method
> ###   coerce,SortedByQueryHits,CompressedIntegerList-method
> ###   coerce,SortedByQueryHits,IntegerList-method
> ###   coerce,SortedByQueryHits,List-method as.list,SortedByQueryHits-method
> ###   coerce,Hits,CompressedIntegerList-method
> ###   coerce,Hits,IntegerList-method coerce,Hits,List-method
> ###   as.list,Hits-method coerce,Hits,Grouping
> ### Keywords: methods classes
> 
> ### ** Examples
> 
> query <- IRanges(c(1, 4, 9), c(5, 7, 10))
> subject <- IRanges(c(2, 2, 10), c(2, 3, 12))
> hits <- findOverlaps(query, subject)
> 
> as.matrix(hits)
     queryHits subjectHits
[1,]         1           2
[2,]         1           1
[3,]         3           3
> as.data.frame(hits)
  queryHits subjectHits
1         1           2
2         1           1
3         3           3
> 
> as.table(hits) # hits per query
[1] 2 0 1
> as.table(t(hits)) # hits per subject
[1] 1 1 1
> 
> ## Turn a Hits object into an IntegerList object with one list element
> ## per element in the original query.
> as(hits, "IntegerList")
IntegerList of length 3
[[1]] 2 1
[[2]] integer(0)
[[3]] 3
> as(hits, "List")  # same as as(hits, "IntegerList")
IntegerList of length 3
[[1]] 2 1
[[2]] integer(0)
[[3]] 3
> 
> ## Turn a Hits object into a PartitioningByEnd object that describes
> ## the grouping of hits by query.
> as(hits, "PartitioningByEnd")
PartitioningByEnd object with 3 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         1         2         2
  [2]         3         2         0
  [3]         3         3         1
> as(hits, "Partitioning")  # same as as(hits, "PartitioningByEnd")
PartitioningByEnd object with 3 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         1         2         2
  [2]         3         2         0
  [3]         3         3         1
> 
> ## ---------------------------------------------------------------------
> ## remapHits()
> ## ---------------------------------------------------------------------
> 
> hits2 <- remapHits(hits,
+                    Rnodes.remapping=factor(c("e", "e", "d"), letters[1:5]))
> hits2
Hits object with 2 hits and 0 metadata columns:
      queryHits subjectHits
      <integer>   <integer>
  [1]         1           5
  [2]         3           4
  -------
  queryLength: 3 / subjectLength: 5
> 
> hits3 <- remapHits(hits,
+                    Rnodes.remapping=c(5, 5, 4), new.nRnode=5)
> hits3
Hits object with 2 hits and 0 metadata columns:
      queryHits subjectHits
      <integer>   <integer>
  [1]         1           5
  [2]         3           4
  -------
  queryLength: 3 / subjectLength: 5
> stopifnot(identical(hits2, hits3))
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("Hits-class-leftovers", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("IPos-class")
> ### * IPos-class
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: IPos-class
> ### Title: IPos objects
> ### Aliases: class:IPos IPos-class IPos parallel_slot_names,IPos-method
> ###   class:UnstitchedIPos UnstitchedIPos-class UnstitchedIPos
> ###   parallel_slot_names,UnstitchedIPos-method class:StitchedIPos
> ###   StitchedIPos-class StitchedIPos updateObject,IPos-method pos
> ###   pos,UnstitchedIPos-method pos,IPos-method
> ###   length,UnstitchedIPos-method length,IPos-method names,IPos-method
> ###   names<-,IPos-method coerce,UnstitchedIPos,StitchedIPos-method
> ###   coerce,StitchedIPos,UnstitchedIPos-method
> ###   coerce,IntegerRanges,UnstitchedIPos-method
> ###   coerce,IntegerRanges,StitchedIPos-method
> ###   coerce,IntegerRanges,IPos-method coerce,ANY,UnstitchedIPos-method
> ###   coerce,ANY,StitchedIPos-method coerce,ANY,IPos-method
> ###   as.data.frame.IPos as.data.frame,IPos-method extractROWS,IPos-method
> ###   summary.IPos summary,IPos-method show,IPos-method
> ###   bindROWS,IPos-method
> ### Keywords: methods classes
> 
> ### ** Examples
> 
> showClass("IPos")  # shows the known subclasses
Virtual Class "IPos" [package "IRanges"]

Slots:
                                                                              
Name:              NAMES       elementType   elementMetadata          metadata
Class: character_OR_NULL         character DataFrame_OR_NULL              list

Extends: 
Class "Pos", directly
Class "IPosRanges", directly
Class "IntegerRanges", by class "IPosRanges", distance 2
Class "Ranges", by class "IPosRanges", distance 3
Class "IntegerRanges_OR_missing", by class "IntegerRanges", distance 3
Class "List", by class "IPosRanges", distance 4
Class "Vector", by class "IPosRanges", distance 5
Class "list_OR_List", by class "IPosRanges", distance 5
Class "Annotated", by class "IPosRanges", distance 6
Class "vector_OR_Vector", by class "IPosRanges", distance 6

Known Subclasses: "UnstitchedIPos", "StitchedIPos"
> 
> ## ---------------------------------------------------------------------
> ## BASIC EXAMPLES
> ## ---------------------------------------------------------------------
> 
> ## Example 1:
> ipos1a <- IPos(c(44:53, 5:10, 2:5))
> ipos1a  # unstitched
UnstitchedIPos object with 20 positions and 0 metadata columns:
             pos
       <integer>
   [1]        44
   [2]        45
   [3]        46
   [4]        47
   [5]        48
   ...       ...
  [16]        10
  [17]         2
  [18]         3
  [19]         4
  [20]         5
> 
> length(ipos1a)
[1] 20
> pos(ipos1a)  # same as 'start(ipos1a)' and 'end(ipos1a)'
 [1] 44 45 46 47 48 49 50 51 52 53  5  6  7  8  9 10  2  3  4  5
> as.character(ipos1a)
 [1] "44" "45" "46" "47" "48" "49" "50" "51" "52" "53" "5"  "6"  "7"  "8"  "9" 
[16] "10" "2"  "3"  "4"  "5" 
> as.data.frame(ipos1a)
   pos
1   44
2   45
3   46
4   47
5   48
6   49
7   50
8   51
9   52
10  53
11   5
12   6
13   7
14   8
15   9
16  10
17   2
18   3
19   4
20   5
> as(ipos1a, "IRanges")
IRanges object with 20 ranges and 0 metadata columns:
           start       end     width
       <integer> <integer> <integer>
   [1]        44        44         1
   [2]        45        45         1
   [3]        46        46         1
   [4]        47        47         1
   [5]        48        48         1
   ...       ...       ...       ...
  [16]        10        10         1
  [17]         2         2         1
  [18]         3         3         1
  [19]         4         4         1
  [20]         5         5         1
> as.data.frame(as(ipos1a, "IRanges"))
   start end width
1     44  44     1
2     45  45     1
3     46  46     1
4     47  47     1
5     48  48     1
6     49  49     1
7     50  50     1
8     51  51     1
9     52  52     1
10    53  53     1
11     5   5     1
12     6   6     1
13     7   7     1
14     8   8     1
15     9   9     1
16    10  10     1
17     2   2     1
18     3   3     1
19     4   4     1
20     5   5     1
> ipos1a[9:17]
UnstitchedIPos object with 9 positions and 0 metadata columns:
            pos
      <integer>
  [1]        52
  [2]        53
  [3]         5
  [4]         6
  [5]         7
  [6]         8
  [7]         9
  [8]        10
  [9]         2
> 
> ipos1b <- IPos(c(44:53, 5:10, 2:5), stitch=TRUE)
> ipos1b  # stitched
StitchedIPos object with 20 positions and 0 metadata columns:
             pos
       <integer>
   [1]        44
   [2]        45
   [3]        46
   [4]        47
   [5]        48
   ...       ...
  [16]        10
  [17]         2
  [18]         3
  [19]         4
  [20]         5
> 
> ## 'ipos1a' and 'ipos1b' are semantically equivalent, only their
> ## internal representations differ:
> all(ipos1a == ipos1b)
[1] TRUE
> 
> ipos1c <- IPos(c("44-53", "5-10", "2-5"))
> ipos1c  # stitched
StitchedIPos object with 20 positions and 0 metadata columns:
             pos
       <integer>
   [1]        44
   [2]        45
   [3]        46
   [4]        47
   [5]        48
   ...       ...
  [16]        10
  [17]         2
  [18]         3
  [19]         4
  [20]         5
> 
> identical(ipos1b, ipos1c)
[1] TRUE
> 
> ## Example 2:
> my_pos <- IRanges(c(1, 6, 12, 17), c(5, 10, 16, 20))
> ipos2 <- IPos(my_pos)
> ipos2  # stitched
StitchedIPos object with 19 positions and 0 metadata columns:
             pos
       <integer>
   [1]         1
   [2]         2
   [3]         3
   [4]         4
   [5]         5
   ...       ...
  [15]        16
  [16]        17
  [17]        18
  [18]        19
  [19]        20
> 
> ## Example 3:
> ipos3A <- ipos3B <- IPos(c("1-15000", "15400-88700"))
> npos <- length(ipos3A)
> 
> mcols(ipos3A)$sample <- Rle("sA")
> sA_counts <- sample(10, npos, replace=TRUE)
> mcols(ipos3A)$counts <- sA_counts
> 
> mcols(ipos3B)$sample <- Rle("sB")
> sB_counts <- sample(10, npos, replace=TRUE)
> mcols(ipos3B)$counts <- sB_counts
> 
> ipos3 <- c(ipos3A, ipos3B)
> ipos3
StitchedIPos object with 176602 positions and 2 metadata columns:
                 pos | sample    counts
           <integer> |  <Rle> <integer>
       [1]         1 |     sA         9
       [2]         2 |     sA         4
       [3]         3 |     sA         7
       [4]         4 |     sA         1
       [5]         5 |     sA         2
       ...       ... .    ...       ...
  [176598]     88696 |     sB         5
  [176599]     88697 |     sB        10
  [176600]     88698 |     sB         4
  [176601]     88699 |     sB         8
  [176602]     88700 |     sB         3
> 
> ## ---------------------------------------------------------------------
> ## MEMORY USAGE
> ## ---------------------------------------------------------------------
> 
> ## Coercion to IRanges works on a StitchedIPos object...
> ipos4 <- IPos(c("1-125000", "135000-575000"))
> ir4 <- as(ipos4, "IRanges")
> ir4
IRanges object with 565001 ranges and 0 metadata columns:
               start       end     width
           <integer> <integer> <integer>
       [1]         1         1         1
       [2]         2         2         1
       [3]         3         3         1
       [4]         4         4         1
       [5]         5         5         1
       ...       ...       ...       ...
  [564997]    574996    574996         1
  [564998]    574997    574997         1
  [564999]    574998    574998         1
  [565000]    574999    574999         1
  [565001]    575000    575000         1
> ## ... but is generally not a good idea:
> object.size(ipos4)
2904 bytes
> object.size(ir4)  # 1652 times bigger than the StitchedIPos object!
4521560 bytes
> 
> ## Shuffling the order of the positions impacts memory usage:
> ipos4r <- rev(ipos4)
> object.size(ipos4r)
4522904 bytes
> ipos4s <- sample(ipos4)
> object.size(ipos4s)
4522888 bytes
> 
> ## If one anticipates a lot of shuffling of the positions,
> ## then an UnstitchedIPos object should be used instead:
> ipos4b <- as(ipos4, "UnstitchedIPos")
> object.size(ipos4b)  # initial size is bigger than stitched version
2261400 bytes
> object.size(rev(ipos4b))  # size didn't change
2261400 bytes
> object.size(sample(ipos4b))  # size didn't change
2261400 bytes
> 
> ## AN IMPORTANT NOTE: In the worst situations, IPos still performs
> ## as good as an IRanges object.
> object.size(as(ipos4r, "IRanges"))  # same size as 'ipos4r'
4521560 bytes
> object.size(as(ipos4s, "IRanges"))  # same size as 'ipos4s'
4521560 bytes
> 
> ## Best case scenario is when the object is strictly sorted (i.e.
> ## positions are in strict ascending order).
> ## This can be checked with:
> is.unsorted(ipos4, strict=TRUE)  # 'ipos4' is strictly sorted
[1] FALSE
> 
> ## ---------------------------------------------------------------------
> ## USING MEMORY-EFFICIENT METADATA COLUMNS
> ## ---------------------------------------------------------------------
> ## In order to keep memory usage as low as possible, it is recommended
> ## to use a memory-efficient representation of the metadata columns that
> ## we want to set on the object. Rle's are particularly well suited for
> ## this, especially if the metadata columns contain long runs of
> ## identical values. This is the case for example if we want to use an
> ## IPos object to represent the coverage of sequencing reads along a
> ## chromosome.
> 
> ## Example 5:
> library(pasillaBamSubset)
> library(Rsamtools)  # for the BamFile() constructor function
Loading required package: GenomeInfoDb
Loading required package: GenomicRanges
Loading required package: Biostrings
Loading required package: XVector

Attaching package: 'Biostrings'

The following object is masked from 'package:base':

    strsplit

> bamfile1 <- BamFile(untreated1_chr4())
> bamfile2 <- BamFile(untreated3_chr4())
> ipos5 <- IPos(IRanges(1, seqlengths(bamfile1)[["chr4"]]))
> library(GenomicAlignments)  # for "coverage" method for BamFile objects
Loading required package: SummarizedExperiment
Loading required package: MatrixGenerics
Loading required package: matrixStats

Attaching package: 'MatrixGenerics'

The following objects are masked from 'package:matrixStats':

    colAlls, colAnyNAs, colAnys, colAvgsPerRowSet, colCollapse,
    colCounts, colCummaxs, colCummins, colCumprods, colCumsums,
    colDiffs, colIQRDiffs, colIQRs, colLogSumExps, colMadDiffs,
    colMads, colMaxs, colMeans2, colMedians, colMins, colOrderStats,
    colProds, colQuantiles, colRanges, colRanks, colSdDiffs, colSds,
    colSums2, colTabulates, colVarDiffs, colVars, colWeightedMads,
    colWeightedMeans, colWeightedMedians, colWeightedSds,
    colWeightedVars, rowAlls, rowAnyNAs, rowAnys, rowAvgsPerColSet,
    rowCollapse, rowCounts, rowCummaxs, rowCummins, rowCumprods,
    rowCumsums, rowDiffs, rowIQRDiffs, rowIQRs, rowLogSumExps,
    rowMadDiffs, rowMads, rowMaxs, rowMeans2, rowMedians, rowMins,
    rowOrderStats, rowProds, rowQuantiles, rowRanges, rowRanks,
    rowSdDiffs, rowSds, rowSums2, rowTabulates, rowVarDiffs, rowVars,
    rowWeightedMads, rowWeightedMeans, rowWeightedMedians,
    rowWeightedSds, rowWeightedVars

Loading required package: Biobase
Welcome to Bioconductor

    Vignettes contain introductory material; view with
    'browseVignettes()'. To cite Bioconductor, see
    'citation("Biobase")', and for packages 'citation("pkgname")'.


Attaching package: 'Biobase'

The following object is masked from 'package:MatrixGenerics':

    rowMedians

The following objects are masked from 'package:matrixStats':

    anyMissing, rowMedians

> cvg1 <- coverage(bamfile1)$chr4
> cvg2 <- coverage(bamfile2)$chr4
> mcols(ipos5) <- DataFrame(cvg1, cvg2)
> ipos5
StitchedIPos object with 1351857 positions and 2 metadata columns:
                  pos |  cvg1  cvg2
            <integer> | <Rle> <Rle>
        [1]         1 |     0     0
        [2]         2 |     0     0
        [3]         3 |     0     0
        [4]         4 |     0     0
        [5]         5 |     0     0
        ...       ... .   ...   ...
  [1351853]   1351853 |     0     0
  [1351854]   1351854 |     0     0
  [1351855]   1351855 |     0     0
  [1351856]   1351856 |     0     0
  [1351857]   1351857 |     0     0
> 
> object.size(ipos5)  # lightweight
1820968 bytes
> 
> ## Keep only the positions where coverage is at least 10 in one of the
> ## 2 samples:
> ipos5[mcols(ipos5)$cvg1 >= 10 | mcols(ipos5)$cvg2 >= 10]
StitchedIPos object with 214773 positions and 2 metadata columns:
                 pos |  cvg1  cvg2
           <integer> | <Rle> <Rle>
       [1]      4936 |    11     6
       [2]      4937 |    12     6
       [3]      4938 |    12     6
       [4]      4939 |    13     6
       [5]      4940 |    13     6
       ...       ... .   ...   ...
  [214769]   1348339 |    10    14
  [214770]   1348340 |     6    12
  [214771]   1348341 |     6    10
  [214772]   1348342 |     6    10
  [214773]   1348343 |     0    10
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("IPos-class", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching 'package:GenomicAlignments', 'package:SummarizedExperiment',
  'package:Biobase', 'package:MatrixGenerics', 'package:matrixStats',
  'package:Rsamtools', 'package:Biostrings', 'package:XVector',
  'package:GenomicRanges', 'package:GenomeInfoDb',
  'package:pasillaBamSubset'

> nameEx("IPosRanges-class")
> ### * IPosRanges-class
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: IPosRanges-class
> ### Title: IPosRanges objects
> ### Aliases: class:IPosRanges IPosRanges-class IPosRanges width
> ###   start,Ranges-method end,Ranges-method width,Ranges-method
> ###   length,Ranges-method start,Pos-method end,Pos-method width,Pos-method
> ###   elementNROWS,Ranges-method mid mid,Ranges-method
> ###   isEmpty,Ranges-method isNormal isNormal,Ranges-method
> ###   whichFirstNotNormal whichFirstNotNormal,Ranges-method start<- width<-
> ###   end<- as.character,IPosRanges-method as.factor,IPosRanges-method
> ###   as.matrix,IPosRanges-method as.data.frame.IPosRanges
> ###   as.data.frame,IPosRanges-method summary.IPosRanges
> ###   summary,IPosRanges-method show,IPosRanges-method
> ###   getListElement,IPosRanges-method tile tile,IPosRanges-method
> ###   slidingWindows slidingWindows,IPosRanges-method
> ### Keywords: methods classes
> 
> ### ** Examples
> 
> ## ---------------------------------------------------------------------
> ## Basic manipulation
> ## ---------------------------------------------------------------------
> x <- IRanges(start=c(2:-1, 13:15), width=c(0:3, 2:0))
> x
IRanges object with 7 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         2         1         0
  [2]         1         1         1
  [3]         0         1         2
  [4]        -1         1         3
  [5]        13        14         2
  [6]        14        14         1
  [7]        15        14         0
> length(x)
[1] 7
> start(x)
[1]  2  1  0 -1 13 14 15
> width(x)
[1] 0 1 2 3 2 1 0
> end(x)
[1]  1  1  1  1 14 14 14
> isEmpty(x)
[1] FALSE
> as.matrix(x)
     [,1] [,2]
[1,]    2    0
[2,]    1    1
[3,]    0    2
[4,]   -1    3
[5,]   13    2
[6,]   14    1
[7,]   15    0
> as.data.frame(x)
  start end width
1     2   1     0
2     1   1     1
3     0   1     2
4    -1   1     3
5    13  14     2
6    14  14     1
7    15  14     0
> 
> ## Subsetting:
> x[4:2]                  # 3 ranges
IRanges object with 3 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]        -1         1         3
  [2]         0         1         2
  [3]         1         1         1
> x[-1]                   # 6 ranges
IRanges object with 6 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         1         1         1
  [2]         0         1         2
  [3]        -1         1         3
  [4]        13        14         2
  [5]        14        14         1
  [6]        15        14         0
> x[FALSE]                # 0 range
IRanges object with 0 ranges and 0 metadata columns:
       start       end     width
   <integer> <integer> <integer>
> x0 <- x[width(x) == 0]  # 2 ranges
> isEmpty(x0)
[1] TRUE
> 
> ## Use the replacement methods to resize the ranges:
> width(x) <- width(x) * 2 + 1
> x
IRanges object with 7 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         2         2         1
  [2]         1         3         3
  [3]         0         4         5
  [4]        -1         5         7
  [5]        13        17         5
  [6]        14        16         3
  [7]        15        15         1
> end(x) <- start(x)            # equivalent to width(x) <- 0
> x
IRanges object with 7 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         2         2         1
  [2]         1         1         1
  [3]         0         0         1
  [4]        -1        -1         1
  [5]        13        13         1
  [6]        14        14         1
  [7]        15        15         1
> width(x) <- c(2, 0, 4) 
Warning in x@width[] <- S4Vectors:::numeric2integer(value) :
  number of items to replace is not a multiple of replacement length
> x
IRanges object with 7 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         2         3         2
  [2]         1         0         0
  [3]         0         3         4
  [4]        -1         0         2
  [5]        13        12         0
  [6]        14        17         4
  [7]        15        16         2
> start(x)[3] <- end(x)[3] - 2  # resize the 3rd range
> x
IRanges object with 7 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         2         3         2
  [2]         1         0         0
  [3]         1         3         3
  [4]        -1         0         2
  [5]        13        12         0
  [6]        14        17         4
  [7]        15        16         2
> 
> ## Name the elements:
> names(x)
NULL
> names(x) <- c("range1", "range2")
> x
IRanges object with 7 ranges and 0 metadata columns:
             start       end     width
         <integer> <integer> <integer>
  range1         2         3         2
  range2         1         0         0
      NA         1         3         3
      NA        -1         0         2
      NA        13        12         0
      NA        14        17         4
      NA        15        16         2
> x[is.na(names(x))]  # 5 ranges
IRanges object with 5 ranges and 0 metadata columns:
         start       end     width
     <integer> <integer> <integer>
  NA         1         3         3
  NA        -1         0         2
  NA        13        12         0
  NA        14        17         4
  NA        15        16         2
> x[!is.na(names(x))]  # 2 ranges
IRanges object with 2 ranges and 0 metadata columns:
             start       end     width
         <integer> <integer> <integer>
  range1         2         3         2
  range2         1         0         0
> 
> ir <- IRanges(c(1,5), c(3,10))
> ir*1 # no change
IRanges object with 2 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         1         3         3
  [2]         5        10         6
> ir*c(1,2) # zoom second range by 2X
IRanges object with 2 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         1         3         3
  [2]         6         8         3
> ir*-2 # zoom out 2X
IRanges object with 2 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]        -1         4         6
  [2]         2        13        12
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("IPosRanges-class", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("IPosRanges-comparison")
> ### * IPosRanges-comparison
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: IPosRanges-comparison
> ### Title: Comparing and ordering ranges
> ### Aliases: IPosRanges-comparison pcompare
> ###   pcompare,IPosRanges,IPosRanges-method rangeComparisonCodeToLetter
> ###   match,IPosRanges,IPosRanges-method selfmatch,IPosRanges-method
> ###   is.unsorted,IPosRanges-method order,IPosRanges-method
> ### Keywords: methods
> 
> ### ** Examples
> 
> ## ---------------------------------------------------------------------
> ## A. ELEMENT-WISE (AKA "PARALLEL") COMPARISON OF 2 IPosRanges
> ##    DERIVATIVES
> ## ---------------------------------------------------------------------
> x0 <- IRanges(1:11, width=4)
> x0
IRanges object with 11 ranges and 0 metadata columns:
           start       end     width
       <integer> <integer> <integer>
   [1]         1         4         4
   [2]         2         5         4
   [3]         3         6         4
   [4]         4         7         4
   [5]         5         8         4
   [6]         6         9         4
   [7]         7        10         4
   [8]         8        11         4
   [9]         9        12         4
  [10]        10        13         4
  [11]        11        14         4
> y0 <- IRanges(6, 9)
> pcompare(x0, y0)
 [1] -6 -5 -4 -4 -4  0  4  4  4  5  6
> pcompare(IRanges(4:6, width=6), y0)
[1] -3 -2  1
> pcompare(IRanges(6:8, width=2), y0)
[1] -1  2  3
> pcompare(x0, y0) < 0   # equivalent to 'x0 < y0'
 [1]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE
> pcompare(x0, y0) == 0  # equivalent to 'x0 == y0'
 [1] FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE
> pcompare(x0, y0) > 0   # equivalent to 'x0 > y0'
 [1] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE
> 
> rangeComparisonCodeToLetter(-10:10)
 [1] X X X X a b c d e f g h i j k l m X X X X
Levels: a b c d e f g h i j k l m X
> rangeComparisonCodeToLetter(pcompare(x0, y0))
 [1] a b c c c g k k k l m
Levels: a b c d e f g h i j k l m X
> 
> ## Handling of zero-width ranges (a.k.a. empty ranges):
> x1 <- IRanges(11:17, width=0)
> x1
IRanges object with 7 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]        11        10         0
  [2]        12        11         0
  [3]        13        12         0
  [4]        14        13         0
  [5]        15        14         0
  [6]        16        15         0
  [7]        17        16         0
> pcompare(x1, x1[4])
[1] -6 -6 -6  0  6  6  6
> pcompare(x1, IRanges(12, 15))
[1] -6 -5  2  2  2  5  6
> 
> ## Note that x1[2] and x1[6] are empty ranges on the edge of non-empty
> ## range IRanges(12, 15). Even though -1 and 3 could also be considered
> ## valid codes for describing these configurations, pcompare()
> ## considers x1[2] and x1[6] to be *adjacent* to IRanges(12, 15), and
> ## thus returns codes -5 and 5:
> pcompare(x1[2], IRanges(12, 15))  # -5
[1] -5
> pcompare(x1[6], IRanges(12, 15))  #  5
[1] 5
> 
> x2 <- IRanges(start=c(20L, 8L, 20L, 22L, 25L, 20L, 22L, 22L),
+               width=c( 4L, 0L, 11L,  5L,  0L,  9L,  5L,  0L))
> x2
IRanges object with 8 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]        20        23         4
  [2]         8         7         0
  [3]        20        30        11
  [4]        22        26         5
  [5]        25        24         0
  [6]        20        28         9
  [7]        22        26         5
  [8]        22        21         0
> 
> which(width(x2) == 0)  # 3 empty ranges
[1] 2 5 8
> x2[2] == x2[2]  # TRUE
[1] TRUE
> x2[2] == x2[5]  # FALSE
[1] FALSE
> x2 == x2[4]
[1] FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE
> x2 >= x2[3]
[1] FALSE FALSE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE
> 
> ## ---------------------------------------------------------------------
> ## B. match(), selfmatch(), %in%, duplicated(), unique()
> ## ---------------------------------------------------------------------
> table <- x2[c(2:4, 7:8)]
> match(x2, table)
[1] NA  1  2  3 NA NA  3  5
> 
> x2 %in% table
[1] FALSE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE
> 
> duplicated(x2)
[1] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE
> unique(x2)
IRanges object with 7 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]        20        23         4
  [2]         8         7         0
  [3]        20        30        11
  [4]        22        26         5
  [5]        25        24         0
  [6]        20        28         9
  [7]        22        21         0
> 
> ## ---------------------------------------------------------------------
> ## C. findMatches(), countMatches()
> ## ---------------------------------------------------------------------
> findMatches(x2, table)
Hits object with 7 hits and 0 metadata columns:
      queryHits subjectHits
      <integer>   <integer>
  [1]         2           1
  [2]         3           2
  [3]         4           3
  [4]         4           4
  [5]         7           3
  [6]         7           4
  [7]         8           5
  -------
  queryLength: 8 / subjectLength: 5
> countMatches(x2, table)
[1] 0 1 1 2 0 0 2 1
> 
> x2_levels <- unique(x2)
> countMatches(x2_levels, x2)
[1] 1 1 1 2 1 1 1
> 
> ## ---------------------------------------------------------------------
> ## D. order() AND RELATED METHODS
> ## ---------------------------------------------------------------------
> is.unsorted(x2)
[1] TRUE
> order(x2)
[1] 2 1 6 3 8 4 7 5
> sort(x2)
IRanges object with 8 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         8         7         0
  [2]        20        23         4
  [3]        20        28         9
  [4]        20        30        11
  [5]        22        21         0
  [6]        22        26         5
  [7]        22        26         5
  [8]        25        24         0
> rank(x2, ties.method="first")
[1] 2 1 4 6 8 3 7 5
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("IPosRanges-comparison", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("IRanges-class")
> ### * IRanges-class
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: IRanges-class
> ### Title: IRanges and NormalIRanges objects
> ### Aliases: class:IRanges IRanges-class parallel_slot_names,IRanges-method
> ###   start,IRanges-method width,IRanges-method names,IRanges-method
> ###   start<-,IRanges-method width<-,IRanges-method end<-,IRanges-method
> ###   names<-,IRanges-method ranges,IntegerRanges-method
> ###   isNormal,IRanges-method class:NormalIRanges NormalIRanges-class
> ###   NormalIRanges isEmpty,NormalIRanges-method
> ###   isNormal,NormalIRanges-method max,NormalIRanges-method
> ###   min,NormalIRanges-method coerce,IntegerRanges,IRanges-method
> ###   coerce,logical,IRanges-method coerce,logical,NormalIRanges-method
> ###   coerce,integer,IRanges-method coerce,integer,NormalIRanges-method
> ###   coerce,numeric,IRanges-method coerce,numeric,NormalIRanges-method
> ###   coerce,character,IRanges-method coerce,factor,IRanges-method
> ###   coerce,ANY,IntegerRanges-method
> ### Keywords: methods classes
> 
> ### ** Examples
> 
> showClass("IRanges")  # shows the known subclasses
Class "IRanges" [package "IRanges"]

Slots:
                                                                              
Name:              start             width             NAMES       elementType
Class:           integer           integer character_OR_NULL         character
                                          
Name:    elementMetadata          metadata
Class: DataFrame_OR_NULL              list

Extends: 
Class "IPosRanges", directly
Class "IRanges_OR_IPos", directly
Class "IntegerRanges", by class "IPosRanges", distance 2
Class "Ranges", by class "IPosRanges", distance 3
Class "IntegerRanges_OR_missing", by class "IntegerRanges", distance 3
Class "List", by class "IPosRanges", distance 4
Class "Vector", by class "IPosRanges", distance 5
Class "list_OR_List", by class "IPosRanges", distance 5
Class "Annotated", by class "IPosRanges", distance 6
Class "vector_OR_Vector", by class "IPosRanges", distance 6

Known Subclasses: "NormalIRanges", "GroupingIRanges"
> 
> ## ---------------------------------------------------------------------
> ## A. MANIPULATING IRanges OBJECTS
> ## ---------------------------------------------------------------------
> ## All the methods defined for IntegerRanges objects work on IRanges
> ## objects.
> ## See ?IntegerRanges for some examples.
> ## Also see ?`IRanges-utils` and ?`setops-methods` for additional
> ## operations on IRanges objects.
>   
> ## Concatenating IRanges objects
> ir1 <- IRanges(c(1, 10, 20), width=5)
> mcols(ir1) <- DataFrame(score=runif(3))
> ir2 <- IRanges(c(101, 110, 120), width=10)
> mcols(ir2) <- DataFrame(score=runif(3))
> ir3 <- IRanges(c(1001, 1010, 1020), width=20)
> mcols(ir3) <- DataFrame(value=runif(3))
> some.iranges <- c(ir1, ir2)
> ## all.iranges <- c(ir1, ir2, ir3) ## This will raise an error
> all.iranges <- c(ir1, ir2, ir3, ignore.mcols=TRUE)
> stopifnot(is.null(mcols(all.iranges)))
> 
> ## ---------------------------------------------------------------------
> ## B. A NOTE ABOUT PERFORMANCE
> ## ---------------------------------------------------------------------
> ## Using an IRanges object for storing a big set of ranges is more
> ## efficient than using a standard R data frame:
> N <- 2000000L  # nb of ranges
> W <- 180L      # width of each range
> start <- 1L
> end <- 50000000L
> set.seed(777)
> range_starts <- sort(sample(end-W+1L, N))
> range_widths <- rep.int(W, N)
> ## Instantiation is faster
> system.time(x <- IRanges(start=range_starts, width=range_widths))
   user  system elapsed 
   0.01    0.01    0.03 
> system.time(y <- data.frame(start=range_starts, width=range_widths))
   user  system elapsed 
   0.01    0.00    0.02 
> ## Subsetting is faster
> system.time(x16 <- x[c(TRUE, rep.int(FALSE, 15))])
   user  system elapsed 
   0.01    0.00    0.02 
> system.time(y16 <- y[c(TRUE, rep.int(FALSE, 15)), ])
   user  system elapsed 
   0.02    0.00    0.01 
> ## Internal representation is more compact
> object.size(x16)
1001544 bytes
> object.size(y16)
1500840 bytes
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("IRanges-class", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("IRanges-constructor")
> ### * IRanges-constructor
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: IRanges-constructor
> ### Title: The IRanges constructor and supporting functions
> ### Aliases: IRanges-constructor IRanges solveUserSEW
> ### Keywords: utilities
> 
> ### ** Examples
> 
> ## ---------------------------------------------------------------------
> ## A. USING THE IRanges() CONSTRUCTOR
> ## ---------------------------------------------------------------------
> IRanges(start=11, end=rep.int(20, 5))
IRanges object with 5 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]        11        20        10
  [2]        11        20        10
  [3]        11        20        10
  [4]        11        20        10
  [5]        11        20        10
> IRanges(start=11, width=rep.int(20, 5))
IRanges object with 5 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]        11        30        20
  [2]        11        30        20
  [3]        11        30        20
  [4]        11        30        20
  [5]        11        30        20
> IRanges(-2, 20)  # only one range
IRanges object with 1 range and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]        -2        20        23
> IRanges(start=c(2, 0, NA), end=c(NA, NA, 14), width=11:0)
IRanges object with 12 ranges and 0 metadata columns:
           start       end     width
       <integer> <integer> <integer>
   [1]         2        12        11
   [2]         0         9        10
   [3]         6        14         9
   [4]         2         9         8
   [5]         0         6         7
   ...       ...       ...       ...
   [8]         0         3         4
   [9]        12        14         3
  [10]         2         3         2
  [11]         0         0         1
  [12]        15        14         0
> IRanges()  # IRanges instance of length zero
IRanges object with 0 ranges and 0 metadata columns:
       start       end     width
   <integer> <integer> <integer>
> IRanges(names=character())
IRanges object with 0 ranges and 0 metadata columns:
       start       end     width
   <integer> <integer> <integer>
> 
> ## With ranges specified as strings:
> IRanges(c("11-20", "15-14", "-4--2"))
IRanges object with 3 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]        11        20        10
  [2]        15        14         0
  [3]        -4        -2         3
> 
> ## With logical input:
> x <- IRanges(c(FALSE, TRUE, TRUE, FALSE, TRUE))  # logical vector input
> isNormal(x)  # TRUE
[1] TRUE
> x <- IRanges(Rle(1:30) %% 5 <= 2)  # logical Rle input
> isNormal(x)  # TRUE
[1] TRUE
> 
> ## ---------------------------------------------------------------------
> ## B. USING solveUserSEW()
> ## ---------------------------------------------------------------------
> refwidths <- c(5:3, 6:7)
> refwidths
[1] 5 4 3 6 7
> 
> solveUserSEW(refwidths)
IRanges object with 5 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         1         5         5
  [2]         1         4         4
  [3]         1         3         3
  [4]         1         6         6
  [5]         1         7         7
> solveUserSEW(refwidths, start=4)
IRanges object with 5 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         4         5         2
  [2]         4         4         1
  [3]         4         3         0
  [4]         4         6         3
  [5]         4         7         4
> solveUserSEW(refwidths, end=3, width=2)
IRanges object with 5 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         2         3         2
  [2]         2         3         2
  [3]         2         3         2
  [4]         2         3         2
  [5]         2         3         2
> solveUserSEW(refwidths, start=-3)
IRanges object with 5 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         3         5         3
  [2]         2         4         3
  [3]         1         3         3
  [4]         4         6         3
  [5]         5         7         3
> solveUserSEW(refwidths, start=-3, width=2)
IRanges object with 5 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         3         4         2
  [2]         2         3         2
  [3]         1         2         2
  [4]         4         5         2
  [5]         5         6         2
> solveUserSEW(refwidths, end=-4)
IRanges object with 5 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         1         2         2
  [2]         1         1         1
  [3]         1         0         0
  [4]         1         3         3
  [5]         1         4         4
> 
> ## The start/end/width arguments are recycled:
> solveUserSEW(refwidths, start=c(3, -4, NA), end=c(-2, NA))
IRanges object with 5 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         3         4         2
  [2]         1         4         4
  [3]         1         2         2
  [4]         3         6         4
  [5]         4         6         3
> 
> ## Using 'rep.refwidths=TRUE':
> solveUserSEW(10, start=-(1:6), rep.refwidths=TRUE)
IRanges object with 6 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]        10        10         1
  [2]         9        10         2
  [3]         8        10         3
  [4]         7        10         4
  [5]         6        10         5
  [6]         5        10         6
> solveUserSEW(10, end=-(1:6), width=3, rep.refwidths=TRUE)
IRanges object with 6 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         8        10         3
  [2]         7         9         3
  [3]         6         8         3
  [4]         5         7         3
  [5]         4         6         3
  [6]         3         5         3
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("IRanges-constructor", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("IRanges-utils")
> ### * IRanges-utils
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: IRanges-utils
> ### Title: IRanges utility functions
> ### Aliases: IRanges-utils successiveIRanges breakInChunks whichAsIRanges
> ###   asNormalIRanges coerce,IRanges,NormalIRanges-method
> ### Keywords: utilities
> 
> ### ** Examples
> 
> vec <- as.integer(c(19, 5, 0, 8, 5))
> 
> successiveIRanges(vec)
IRanges object with 5 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         1        19        19
  [2]        20        24         5
  [3]        25        24         0
  [4]        25        32         8
  [5]        33        37         5
> 
> breakInChunks(600999, chunksize=50000)  # chunks of size 50000 (last
PartitioningByEnd object with 13 ranges and 0 metadata columns:
           start       end     width
       <integer> <integer> <integer>
   [1]         1     50000     50000
   [2]     50001    100000     50000
   [3]    100001    150000     50000
   [4]    150001    200000     50000
   [5]    200001    250000     50000
   ...       ...       ...       ...
   [9]    400001    450000     50000
  [10]    450001    500000     50000
  [11]    500001    550000     50000
  [12]    550001    600000     50000
  [13]    600001    600999       999
>                                         # chunk is smaller)
> 
> whichAsIRanges(vec >= 5)
NormalIRanges object with 2 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         1         2         2
  [2]         4         5         2
> 
> x <- IRanges(start=c(-2L, 6L, 9L, -4L, 1L, 0L, -6L, 10L),
+              width=c( 5L, 0L, 6L,  1L, 4L, 3L,  2L,  3L))
> asNormalIRanges(x)  # 3 non-empty ranges ordered from left to right and
NormalIRanges object with 3 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]        -6        -4         3
  [2]        -2         4         7
  [3]         9        14         6
>                     # separated by gaps of width >= 1.
> 
> ## More on normality:
> example(`IRanges-class`)

IRngs-> showClass("IRanges")  # shows the known subclasses
Class "IRanges" [package "IRanges"]

Slots:
                                                                              
Name:              start             width             NAMES       elementType
Class:           integer           integer character_OR_NULL         character
                                          
Name:    elementMetadata          metadata
Class: DataFrame_OR_NULL              list

Extends: 
Class "IPosRanges", directly
Class "IRanges_OR_IPos", directly
Class "IntegerRanges", by class "IPosRanges", distance 2
Class "Ranges", by class "IPosRanges", distance 3
Class "IntegerRanges_OR_missing", by class "IntegerRanges", distance 3
Class "List", by class "IPosRanges", distance 4
Class "Vector", by class "IPosRanges", distance 5
Class "list_OR_List", by class "IPosRanges", distance 5
Class "Annotated", by class "IPosRanges", distance 6
Class "vector_OR_Vector", by class "IPosRanges", distance 6

Known Subclasses: "NormalIRanges", "GroupingIRanges"

IRngs-> ## ---------------------------------------------------------------------
IRngs-> ## A. MANIPULATING IRanges OBJECTS
IRngs-> ## ---------------------------------------------------------------------
IRngs-> ## All the methods defined for IntegerRanges objects work on IRanges
IRngs-> ## objects.
IRngs-> ## See ?IntegerRanges for some examples.
IRngs-> ## Also see ?`IRanges-utils` and ?`setops-methods` for additional
IRngs-> ## operations on IRanges objects.
IRngs->   
IRngs-> ## Concatenating IRanges objects
IRngs-> ir1 <- IRanges(c(1, 10, 20), width=5)

IRngs-> mcols(ir1) <- DataFrame(score=runif(3))

IRngs-> ir2 <- IRanges(c(101, 110, 120), width=10)

IRngs-> mcols(ir2) <- DataFrame(score=runif(3))

IRngs-> ir3 <- IRanges(c(1001, 1010, 1020), width=20)

IRngs-> mcols(ir3) <- DataFrame(value=runif(3))

IRngs-> some.iranges <- c(ir1, ir2)

IRngs-> ## all.iranges <- c(ir1, ir2, ir3) ## This will raise an error
IRngs-> all.iranges <- c(ir1, ir2, ir3, ignore.mcols=TRUE)

IRngs-> stopifnot(is.null(mcols(all.iranges)))

IRngs-> ## ---------------------------------------------------------------------
IRngs-> ## B. A NOTE ABOUT PERFORMANCE
IRngs-> ## ---------------------------------------------------------------------
IRngs-> ## Using an IRanges object for storing a big set of ranges is more
IRngs-> ## efficient than using a standard R data frame:
IRngs-> N <- 2000000L  # nb of ranges

IRngs-> W <- 180L      # width of each range

IRngs-> start <- 1L

IRngs-> end <- 50000000L

IRngs-> set.seed(777)

IRngs-> range_starts <- sort(sample(end-W+1L, N))

IRngs-> range_widths <- rep.int(W, N)

IRngs-> ## Instantiation is faster
IRngs-> system.time(x <- IRanges(start=range_starts, width=range_widths))
   user  system elapsed 
   0.03    0.00    0.03 

IRngs-> system.time(y <- data.frame(start=range_starts, width=range_widths))
   user  system elapsed 
      0       0       0 

IRngs-> ## Subsetting is faster
IRngs-> system.time(x16 <- x[c(TRUE, rep.int(FALSE, 15))])
   user  system elapsed 
      0       0       0 

IRngs-> system.time(y16 <- y[c(TRUE, rep.int(FALSE, 15)), ])
   user  system elapsed 
   0.02    0.00    0.02 

IRngs-> ## Internal representation is more compact
IRngs-> object.size(x16)
1001544 bytes

IRngs-> object.size(y16)
1500840 bytes
> isNormal(x16)                        # FALSE
[1] FALSE
> if (interactive())
+     x16 <- asNormalIRanges(x16)      # Error!
> whichFirstNotNormal(x16)             # 57
[1] 218
> isNormal(x16[1:56])                  # TRUE
[1] TRUE
> xx <- asNormalIRanges(x16[1:56])
> class(xx)
[1] "NormalIRanges"
> max(xx)
[1] 22086
> min(xx)
[1] 48
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("IRanges-utils", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("IRangesList-class")
> ### * IRangesList-class
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: IRangesList-class
> ### Title: List of IRanges and NormalIRanges
> ### Aliases: class:IRangesList class:CompressedIRangesList
> ###   class:SimpleIRangesList IRangesList-class CompressedIRangesList-class
> ###   SimpleIRangesList-class IRangesList CompressedIRangesList
> ###   SimpleIRangesList end,CompressedRangesList-method
> ###   width,CompressedRangesList-method start,CompressedRangesList-method
> ###   pos,CompressedPosList-method coerce,list,CompressedIRangesList-method
> ###   coerce,list,SimpleIRangesList-method coerce,list,IRangesList-method
> ###   coerce,List,CompressedIRangesList-method
> ###   coerce,IntegerRanges,CompressedIRangesList-method
> ###   coerce,List,SimpleIRangesList-method
> ###   coerce,SimpleList,SimpleIRangesList-method
> ###   coerce,IntegerRangesList,SimpleIRangesList-method
> ###   coerce,SimpleIntegerRangesList,SimpleIRangesList-method
> ###   coerce,List,IRangesList-method
> ###   coerce,CompressedRleList,CompressedIRangesList-method
> ###   class:NormalIRangesList class:SimpleNormalIRangesList
> ###   class:CompressedNormalIRangesList NormalIRangesList-class
> ###   SimpleNormalIRangesList-class CompressedNormalIRangesList-class
> ###   NormalIRangesList SimpleNormalIRangesList CompressedNormalIRangesList
> ###   isNormal,SimpleIRangesList-method
> ###   isNormal,CompressedIRangesList-method
> ###   min,SimpleNormalIRangesList-method
> ###   min,CompressedNormalIRangesList-method
> ###   max,SimpleNormalIRangesList-method
> ###   max,CompressedNormalIRangesList-method
> ###   summary,CompressedIRangesList-method
> ###   as.list,CompressedNormalIRangesList-method
> ###   unlist,SimpleNormalIRangesList-method
> ###   coerce,IntegerRangesList,SimpleNormalIRangesList-method
> ###   coerce,SimpleIRangesList,SimpleNormalIRangesList-method
> ###   coerce,NormalIRangesList,CompressedNormalIRangesList-method
> ###   coerce,CompressedIRangesList,CompressedNormalIRangesList-method
> ###   coerce,IntegerRangesList,CompressedNormalIRangesList-method
> ###   coerce,IntegerRangesList,NormalIRangesList-method
> ###   coerce,LogicalList,NormalIRangesList-method
> ###   coerce,LogicalList,SimpleNormalIRangesList-method
> ###   coerce,LogicalList,CompressedNormalIRangesList-method
> ###   coerce,RleList,NormalIRangesList-method
> ###   coerce,RleList,SimpleNormalIRangesList-method
> ###   coerce,RleList,CompressedNormalIRangesList-method
> ### Keywords: classes methods
> 
> ### ** Examples
> 
> range1 <- IRanges(start=c(1,2,3), end=c(5,2,8))
> range2 <- IRanges(start=c(15,45,20,1), end=c(15,100,80,5))
> named <- IRangesList(one = range1, two = range2)
> length(named) # 2
[1] 2
> names(named) # "one" and "two"
[1] "one" "two"
> named[[1]] # range1
IRanges object with 3 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         1         5         5
  [2]         2         2         1
  [3]         3         8         6
> unnamed <- IRangesList(range1, range2)
> names(unnamed) # NULL
NULL
> 
> x <- IRangesList(start=list(c(1,2,3), c(15,45,20,1)),
+                  end=list(c(5,2,8), c(15,100,80,5)))
> as.list(x)
[[1]]
IRanges object with 3 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         1         5         5
  [2]         2         2         1
  [3]         3         8         6

[[2]]
IRanges object with 4 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]        15        15         1
  [2]        45       100        56
  [3]        20        80        61
  [4]         1         5         5

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("IRangesList-class", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("IntegerRangesList-class")
> ### * IntegerRangesList-class
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: IntegerRangesList-class
> ### Title: IntegerRangesList objects
> ### Aliases: class:IntegerRangesList IntegerRangesList-class
> ###   IntegerRangesList class:SimpleIntegerRangesList
> ###   SimpleIntegerRangesList-class SimpleIntegerRangesList
> ###   start,RangesList-method start<-,IntegerRangesList-method
> ###   end,RangesList-method end<-,IntegerRangesList-method
> ###   width,RangesList-method width<-,IntegerRangesList-method
> ###   pos,PosList-method space space,IntegerRangesList-method
> ###   isNormal,IntegerRangesList-method
> ###   whichFirstNotNormal,IntegerRangesList-method
> ###   show,IntegerRangesList-method merge,IntegerRangesList,missing-method
> ###   merge,missing,IntegerRangesList-method
> ###   merge,IntegerRangesList,IntegerRangesList-method
> ### Keywords: methods classes
> 
> ### ** Examples
> 
> ## ---------------------------------------------------------------------
> ## Basic manipulation
> ## ---------------------------------------------------------------------
> 
> range1 <- IRanges(start=c(1, 2, 3), end=c(5, 2, 8))
> range2 <- IRanges(start=c(15, 45, 20, 1), end=c(15, 100, 80, 5))
> named <- IRangesList(one = range1, two = range2)
> length(named) # 2
[1] 2
> start(named) # same as start(c(range1, range2))
IntegerList of length 2
[["one"]] 1 2 3
[["two"]] 15 45 20 1
> names(named) # "one" and "two"
[1] "one" "two"
> named[[1]] # range1
IRanges object with 3 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         1         5         5
  [2]         2         2         1
  [3]         3         8         6
> unnamed <- IRangesList(range1, range2)
> names(unnamed) # NULL
NULL
> 
> # edit the width of the ranges in the list
> edited <- named
> width(edited) <- rep(c(3,2), elementNROWS(named))
> edited
IRangesList object of length 2:
$one
IRanges object with 3 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         1         3         3
  [2]         2         4         3
  [3]         3         5         3

$two
IRanges object with 4 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]        15        16         2
  [2]        45        46         2
  [3]        20        21         2
  [4]         1         2         2

> 
> # same as list(range1, range2)
> as.list(IRangesList(range1, range2))
[[1]]
IRanges object with 3 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         1         5         5
  [2]         2         2         1
  [3]         3         8         6

[[2]]
IRanges object with 4 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]        15        15         1
  [2]        45       100        56
  [3]        20        80        61
  [4]         1         5         5

> 
> # coerce to data.frame
> as.data.frame(named)
  group group_name start end width
1     1        one     1   5     5
2     1        one     2   2     1
3     1        one     3   8     6
4     2        two    15  15     1
5     2        two    45 100    56
6     2        two    20  80    61
7     2        two     1   5     5
> 
> IRangesList(range1, range2)
IRangesList object of length 2:
[[1]]
IRanges object with 3 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         1         5         5
  [2]         2         2         1
  [3]         3         8         6

[[2]]
IRanges object with 4 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]        15        15         1
  [2]        45       100        56
  [3]        20        80        61
  [4]         1         5         5

> 
> ## zoom in 2X
> collection <- IRangesList(one = range1, range2)
> collection * 2
IRangesList object of length 2:
$one
IRanges object with 3 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         2         3         2
  [2]         2         1         0
  [3]         4         6         3

[[2]]
IRanges object with 4 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]        15        14         0
  [2]        59        86        28
  [3]        35        64        30
  [4]         2         3         2

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("IntegerRangesList-class", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("MaskCollection-class")
> ### * MaskCollection-class
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: MaskCollection-class
> ### Title: MaskCollection objects
> ### Aliases: class:MaskCollection MaskCollection-class MaskCollection
> ###   nir_list nir_list,MaskCollection-method length,MaskCollection-method
> ###   width,MaskCollection-method active active,MaskCollection-method
> ###   active<- active<-,MaskCollection-method names,MaskCollection-method
> ###   names<-,MaskCollection-method desc desc,MaskCollection-method desc<-
> ###   desc<-,MaskCollection-method Mask max,MaskCollection-method
> ###   min,MaskCollection-method maskedwidth
> ###   maskedwidth,MaskCollection-method maskedratio
> ###   maskedratio,MaskCollection-method
> ###   append,MaskCollection,MaskCollection-method collapse
> ###   collapse,MaskCollection-method
> ###   coerce,MaskCollection,NormalIRanges-method MaskCollection.show_frame
> ###   show,MaskCollection-method
> ### Keywords: methods classes
> 
> ### ** Examples
> 
>   ## Making a MaskCollection object:
>   mask1 <- Mask(mask.width=29, start=c(11, 25, 28), width=c(5, 2, 2))
>   mask2 <- Mask(mask.width=29, start=c(3, 10, 27), width=c(5, 8, 1))
>   mask3 <- Mask(mask.width=29, start=c(7, 12), width=c(2, 4))
>   mymasks <- append(append(mask1, mask2), mask3)
>   mymasks
MaskCollection of length 3 and width 29
masks:
  maskedwidth maskedratio active
1           9   0.3103448   TRUE
2          14   0.4827586   TRUE
3           6   0.2068966   TRUE
all masks together:
  maskedwidth maskedratio
           19   0.6551724
>   length(mymasks)
[1] 3
>   width(mymasks)
[1] 29
>   collapse(mymasks)
MaskCollection of length 1 and width 29
masks:
  maskedwidth maskedratio active
1          19   0.6551724   TRUE
> 
>   ## Names and descriptions:
>   names(mymasks) <- c("A", "B", "C")  # names should be short and unique...
>   mymasks
MaskCollection of length 3 and width 29
masks:
  maskedwidth maskedratio active names
1           9   0.3103448   TRUE     A
2          14   0.4827586   TRUE     B
3           6   0.2068966   TRUE     C
all masks together:
  maskedwidth maskedratio
           19   0.6551724
>   mymasks[c("C", "A")]  # ...to make subsetting by names easier
MaskCollection of length 2 and width 29
masks:
  maskedwidth maskedratio active names
1           6   0.2068966   TRUE     C
2           9   0.3103448   TRUE     A
all masks together:
  maskedwidth maskedratio
           11   0.3793103
>   desc(mymasks) <- c("you can be", "more verbose", "here")
>   mymasks[-2]
MaskCollection of length 2 and width 29
masks:
  maskedwidth maskedratio active names       desc
1           9   0.3103448   TRUE     A you can be
2           6   0.2068966   TRUE     C       here
all masks together:
  maskedwidth maskedratio
           11   0.3793103
> 
>   ## Activate/deactivate masks:
>   active(mymasks)["B"] <- FALSE
>   mymasks
MaskCollection of length 3 and width 29
masks:
  maskedwidth maskedratio active names         desc
1           9   0.3103448   TRUE     A   you can be
2          14   0.4827586  FALSE     B more verbose
3           6   0.2068966   TRUE     C         here
all masks together:
  maskedwidth maskedratio
           19   0.6551724
all active masks together:
  maskedwidth maskedratio
           11   0.3793103
>   collapse(mymasks)
MaskCollection of length 1 and width 29
masks:
  maskedwidth maskedratio active
1          11   0.3793103   TRUE
>   active(mymasks) <- FALSE  # deactivate all masks
>   mymasks
MaskCollection of length 3 and width 29
masks:
  maskedwidth maskedratio active names         desc
1           9   0.3103448  FALSE     A   you can be
2          14   0.4827586  FALSE     B more verbose
3           6   0.2068966  FALSE     C         here
all masks together:
  maskedwidth maskedratio
           19   0.6551724
all active masks together:
  maskedwidth maskedratio
            0           0
>   active(mymasks)[-1] <- TRUE  # reactivate all masks except mask 1
>   active(mymasks) <- !active(mymasks)  # toggle all masks
> 
>   ## Other advanced operations:
>   mymasks[[2]]
NormalIRanges object with 3 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         3         7         5
  [2]        10        17         8
  [3]        27        27         1
>   length(mymasks[[2]])
[1] 3
>   mymasks[[2]][-3]
NormalIRanges object with 2 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         3         7         5
  [2]        10        17         8
>   append(mymasks[-2], gaps(mymasks[2]))
MaskCollection of length 3 and width 29
masks:
  maskedwidth maskedratio active names       desc
1           9   0.3103448   TRUE     A you can be
2           6   0.2068966  FALSE     C       here
3          15   0.5172414  FALSE                 
all masks together:
  maskedwidth maskedratio
           21   0.7241379
all active masks together:
  maskedwidth maskedratio
            9   0.3103448
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("MaskCollection-class", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("NCList-class")
> ### * NCList-class
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: NCList-class
> ### Title: Nested Containment List objects
> ### Aliases: class:NCList NCList-class NCList length,NCList-method
> ###   names,NCList-method start,NCList-method end,NCList-method
> ###   width,NCList-method coerce,IntegerRanges,NCList-method
> ###   extractROWS,NCList,ANY-method bindROWS,NCList-method class:NCLists
> ###   NCLists-class NCLists parallel_slot_names,NCLists-method
> ###   ranges,NCLists-method length,NCLists-method names,NCLists-method
> ###   start,NCLists-method end,NCLists-method width,NCLists-method
> ###   elementNROWS,NCLists-method
> ###   coerce,NCLists,CompressedIRangesList-method
> ###   coerce,NCLists,IRangesList-method
> ###   coerce,IntegerRangesList,NCLists-method
> ### Keywords: classes methods
> 
> ### ** Examples
> 
> ## The example below is for illustration purpose only and does NOT
> ## reflect typical usage. This is because, for a one-time use, it is
> ## NOT advised to explicitely preprocess the input for findOverlaps()
> ## or countOverlaps(). These functions will take care of it and do a
> ## better job at it (by preprocessing only what's needed when it's
> ## needed, and release memory as they go).
> 
> query <- IRanges(c(1, 4, 9), c(5, 7, 10))
> subject <- IRanges(c(2, 2, 10), c(2, 3, 12))
> 
> ## Either the query or the subject of findOverlaps() can be preprocessed:
> 
> ppsubject <- NCList(subject)
> hits1 <- findOverlaps(query, ppsubject)
> hits1
Hits object with 3 hits and 0 metadata columns:
      queryHits subjectHits
      <integer>   <integer>
  [1]         1           2
  [2]         1           1
  [3]         3           3
  -------
  queryLength: 3 / subjectLength: 3
> 
> ppquery <- NCList(query)
> hits2 <- findOverlaps(ppquery, subject)
> hits2
Hits object with 3 hits and 0 metadata columns:
      queryHits subjectHits
      <integer>   <integer>
  [1]         1           1
  [2]         1           2
  [3]         3           3
  -------
  queryLength: 3 / subjectLength: 3
> 
> ## Note that 'hits1' and 'hits2' contain the same hits but not in the
> ## same order.
> stopifnot(identical(sort(hits1), sort(hits2)))
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("NCList-class", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("RangedSelection-class")
> ### * RangedSelection-class
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: RangedSelection-class
> ### Title: Selection of ranges and columns
> ### Aliases: RangedSelection-class ranges,RangedSelection-method
> ###   colnames,RangedSelection-method ranges<-,RangedSelection-method
> ###   colnames<-,RangedSelection-method
> ###   coerce,IntegerRangesList,RangedSelection-method RangedSelection
> ### Keywords: methods classes
> 
> ### ** Examples
> 
>   rl <- IRangesList(chr1 = IRanges(c(1, 5), c(3, 6)))
> 
>   RangedSelection(rl)
An object of class "RangedSelection"
Slot "ranges":
IRangesList object of length 1:
$chr1
IRanges object with 2 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         1         3         3
  [2]         5         6         2


Slot "colnames":
character(0)

>   as(rl, "RangedSelection") # same as above
An object of class "RangedSelection"
Slot "ranges":
IRangesList object of length 1:
$chr1
IRanges object with 2 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         1         3         3
  [2]         5         6         2


Slot "colnames":
character(0)

> 
>   RangedSelection(rl, "score")
An object of class "RangedSelection"
Slot "ranges":
IRangesList object of length 1:
$chr1
IRanges object with 2 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         1         3         3
  [2]         5         6         2


Slot "colnames":
[1] "score"

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("RangedSelection-class", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("Rle-class-leftovers")
> ### * Rle-class-leftovers
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: Rle-class-leftovers
> ### Title: Rle objects (old man page)
> ### Aliases: ranges,Rle-method coerce,Rle,IRanges-method
> ###   coerce,Rle,NormalIRanges-method findRange findRange,Rle-method
> ###   splitRanges splitRanges,Rle-method
> ###   splitRanges,vector_OR_factor-method
> ### Keywords: methods classes
> 
> ### ** Examples
> 
> x <- Rle(10:1, 1:10)
> x
integer-Rle of length 55 with 10 runs
  Lengths:  1  2  3  4  5  6  7  8  9 10
  Values : 10  9  8  7  6  5  4  3  2  1
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("Rle-class-leftovers", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("RleViews-class")
> ### * RleViews-class
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: RleViews-class
> ### Title: The RleViews class
> ### Aliases: class:RleViews RleViews-class RleViews Views,Rle-method
> ###   show,RleViews-method
> ### Keywords: methods classes
> 
> ### ** Examples
> 
>   subject <- Rle(rep(c(3L, 2L, 18L, 0L), c(3,2,1,5)))
>   myViews <- Views(subject, 3:0, 5:8)
>   myViews
Views on a 11-length Rle subject

views:
    start end width
[1]     3   5     3 [3 2 2]
[2]     2   6     5 [ 3  3  2  2 18]
[3]     1   7     7 [ 3  3  3  2  2 18  0]
[4]     0   8     9 [ 3  3  3  2  2 18  0  0 ...]
>   subject(myViews)
integer-Rle of length 11 with 4 runs
  Lengths:  3  2  1  5
  Values :  3  2 18  0
>   length(myViews)
[1] 4
>   start(myViews)
[1] 3 2 1 0
>   end(myViews)
[1] 5 6 7 8
>   width(myViews)
[1] 3 5 7 9
>   myViews[[2]]
integer-Rle of length 5 with 3 runs
  Lengths:  2  2  1
  Values :  3  2 18
> 
>   set.seed(0)
>   vec <- Rle(sample(0:2, 20, replace = TRUE))
>   vec
integer-Rle of length 20 with 12 runs
  Lengths: 1 1 1 1 1 1 2 2 2 3 4 1
  Values : 1 0 2 0 1 0 2 1 2 0 1 2
>   Views(vec, vec > 0)
Views on a 20-length Rle subject

views:
    start end width
[1]     1   1     1 [1]
[2]     3   3     1 [2]
[3]     5   5     1 [1]
[4]     7  12     6 [2 2 1 1 2 2]
[5]    16  20     5 [1 1 1 1 2]
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("RleViews-class", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("RleViewsList-class")
> ### * RleViewsList-class
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: RleViewsList-class
> ### Title: List of RleViews
> ### Aliases: RleViewsList-class SimpleRleViewsList-class
> ###   subject,SimpleRleViewsList-method Views,RleList-method RleViewsList
> ###   coerce,RleViewsList,SimpleIRangesList-method
> ###   coerce,RleViewsList,IRangesList-method
> ### Keywords: methods classes
> 
> ### ** Examples
> 
> ## Rle objects
> subject1 <- Rle(c(3L,2L,18L,0L), c(3,2,1,5))
> set.seed(0)
> subject2 <- Rle(c(0L,5L,2L,0L,3L), c(8,5,2,7,4))
> 
> ## Views
> rleViews1 <- Views(subject1, 3:0, 5:8)
> rleViews2 <- Views(subject2, subject2 > 0) 
> 
> ## RleList and IntegerRangesList objects
> rleList <- RleList(subject1, subject2)
> rangesList <- IRangesList(IRanges(3:0, 5:8), IRanges(subject2 > 0))
> 
> ## methods for construction
> method1 <- RleViewsList(rleViews1, rleViews2)
> method2 <- RleViewsList(rleList = rleList, rangesList = rangesList)
> identical(method1, method2)
[1] TRUE
> 
> ## calculation over the views
> viewSums(method1)
IntegerList of length 2
[[1]] 7 28 31 31
[[2]] 29 12
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("RleViewsList-class", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("Views-class")
> ### * Views-class
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: Views-class
> ### Title: Views objects
> ### Aliases: class:Views Views-class parallel_slot_names,Views-method
> ###   subject subject,Views-method ranges,Views-method ranges<-
> ###   ranges<-,Views-method start,Views-method width,Views-method
> ###   names,Views-method start<-,Views-method end<-,Views-method
> ###   width<-,Views-method names<-,Views-method Views unlist,Views-method
> ###   coerce,Vector,Views-method coerce,Views,IntegerRanges-method
> ###   coerce,Views,IRanges-method coerce,Views,NormalIRanges-method
> ###   as.matrix,Views-method bindROWS,Views-method trim trim,Views-method
> ###   subviews subviews,Views-method successiveViews
> ### Keywords: methods classes
> 
> ### ** Examples
> 
> showClass("Views")  # shows (some of) the known subclasses
Virtual Class "Views" [package "IRanges"]

Slots:
                                                                              
Name:            subject            ranges       elementType   elementMetadata
Class:            Vector           IRanges         character DataFrame_OR_NULL
                        
Name:           metadata
Class:              list

Extends: 
Class "IntegerRanges", directly
Class "Ranges", by class "IntegerRanges", distance 2
Class "IntegerRanges_OR_missing", by class "IntegerRanges", distance 2, with explicit coerce
Class "List", by class "IntegerRanges", distance 3
Class "Vector", by class "IntegerRanges", distance 4
Class "list_OR_List", by class "IntegerRanges", distance 4
Class "Annotated", by class "IntegerRanges", distance 5
Class "vector_OR_Vector", by class "IntegerRanges", distance 5

Known Subclasses: "RleViews"
> 
> ## Create a set of 4 views on an XInteger subject of length 10:
> subject <- Rle(3:-6)
> v1 <- Views(subject, start=4:1, end=4:7)
> 
> ## Extract the 2nd view:
> v1[[2]]
integer-Rle of length 3 with 3 runs
  Lengths:  1  1  1
  Values :  1  0 -1
> 
> ## Some views can be "out of limits"
> v2 <- Views(subject, start=4:-1, end=6)
> trim(v2)
Views on a 10-length Rle subject

views:
    start end width
[1]     4   6     3 [ 0 -1 -2]
[2]     3   6     4 [ 1  0 -1 -2]
[3]     2   6     5 [ 2  1  0 -1 -2]
[4]     1   6     6 [ 3  2  1  0 -1 -2]
[5]     1   6     6 [ 3  2  1  0 -1 -2]
[6]     1   6     6 [ 3  2  1  0 -1 -2]
> subviews(v2, end=-2)
Views on a 10-length Rle subject

views:
    start end width
[1]     4   5     2 [ 0 -1]
[2]     3   5     3 [ 1  0 -1]
[3]     2   5     4 [ 2  1  0 -1]
[4]     1   5     5 [ 3  2  1  0 -1]
[5]     1   5     5 [ 3  2  1  0 -1]
[6]     1   5     5 [ 3  2  1  0 -1]
> 
> ## See ?`XIntegerViews-class` in the XVector package for more examples.
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("Views-class", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ViewsList-class")
> ### * ViewsList-class
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ViewsList-class
> ### Title: List of Views
> ### Aliases: class:ViewsList ViewsList-class ViewsList
> ###   class:SimpleViewsList SimpleViewsList-class SimpleViewsList
> ###   ranges,SimpleViewsList-method start,SimpleViewsList-method
> ###   end,SimpleViewsList-method width,SimpleViewsList-method
> ###   as.matrix,ViewsList-method
> ### Keywords: methods classes
> 
> ### ** Examples
> 
>   showClass("ViewsList")
Virtual Class "ViewsList" [package "IRanges"]

Slots:
                                                            
Name:        elementType   elementMetadata          metadata
Class:         character DataFrame_OR_NULL              list

Extends: 
Class "IntegerRangesList", directly
Class "RangesList", by class "IntegerRangesList", distance 2
Class "List", by class "IntegerRangesList", distance 3
Class "Vector", by class "IntegerRangesList", distance 4
Class "list_OR_List", by class "IntegerRangesList", distance 4
Class "Annotated", by class "IntegerRangesList", distance 5
Class "vector_OR_Vector", by class "IntegerRangesList", distance 5

Known Subclasses: 
Class "SimpleViewsList", directly
Class "RleViewsList", directly
Class "SimpleRleViewsList", by class "RleViewsList", distance 2
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ViewsList-class", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("coverage-methods")
> ### * coverage-methods
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: coverage-methods
> ### Title: Coverage of a set of ranges
> ### Aliases: coverage-methods coverage coverage,IntegerRanges-method
> ###   coverage,StitchedIPos-method coverage,Views-method
> ###   coverage,IntegerRangesList-method
> ### Keywords: methods utilities
> 
> ### ** Examples
> 
> ## ---------------------------------------------------------------------
> ## A. COVERAGE OF AN IRanges OBJECT
> ## ---------------------------------------------------------------------
> x <- IRanges(start=c(-2L, 6L, 9L, -4L, 1L, 0L, -6L, 10L),
+              width=c( 5L, 0L, 6L,  1L, 4L, 3L,  2L,  3L))
> coverage(x)
integer-Rle of length 14 with 6 runs
  Lengths: 2 2 4 1 3 2
  Values : 3 1 0 1 2 1
> coverage(x, shift=7)
integer-Rle of length 21 with 10 runs
  Lengths: 3 1 2 1 2 2 4 1 3 2
  Values : 1 0 1 2 3 1 0 1 2 1
> coverage(x, shift=7, width=27)
integer-Rle of length 27 with 11 runs
  Lengths: 3 1 2 1 2 2 4 1 3 2 6
  Values : 1 0 1 2 3 1 0 1 2 1 0
> coverage(x, shift=c(-4, 2))  # 'shift' gets recycled
integer-Rle of length 14 with 4 runs
  Lengths: 1 9 1 3
  Values : 0 1 0 1
> coverage(x, shift=c(-4, 2), width=12)
integer-Rle of length 12 with 4 runs
  Lengths: 1 9 1 1
  Values : 0 1 0 1
> coverage(x, shift=-max(end(x)))
integer-Rle of length 0 with 0 runs
  Lengths: 
  Values : 
> 
> coverage(restrict(x, 1, 10))
integer-Rle of length 10 with 5 runs
  Lengths: 2 2 4 1 1
  Values : 3 1 0 1 2
> coverage(reduce(x), shift=7)
integer-Rle of length 21 with 5 runs
  Lengths: 3 1 7 4 6
  Values : 1 0 1 0 1
> coverage(gaps(shift(x, 7), start=1, end=27))
integer-Rle of length 27 with 6 runs
  Lengths: 3 1 7 4 6 6
  Values : 0 1 0 1 0 1
> 
> ## With weights:
> coverage(x, weight=as.integer(10^(0:7)))  # integer-Rle
integer-Rle of length 14 with 6 runs
  Lengths:        2        2        4        1        3        2
  Values :   110001    10000        0      100 10000100      100
> coverage(x, weight=c(2.8, -10))  # numeric-Rle, 'shift' gets recycled
numeric-Rle of length 14 with 6 runs
  Lengths:    2    2    4    1    3    2
  Values : -4.4  2.8  0.0  2.8 -7.2  2.8
> 
> ## ---------------------------------------------------------------------
> ## B. FLOATING POINT ARITHMETIC CAN BRING A SURPRISE
> ## ---------------------------------------------------------------------
> ## Please be aware that rounding errors in floating point arithmetic can
> ## lead to some surprising results when computing a weighted coverage:
> y <- IRanges(c(4, 10), c(18, 15))
> w1 <- 0.958
> w2 <- 1e4
> cvg <- coverage(y, width=100, weight=c(w1, w2))
> cvg  # non-zero coverage at positions 19 to 100!
numeric-Rle of length 100 with 5 runs
  Lengths:           3           6           6           3          82
  Values : 0.00000e+00 9.58000e-01 1.00010e+04 9.58000e-01 5.38458e-13
> 
> ## This is an artefact of floating point arithmetic and the algorithm
> ## used to compute the weighted coverage. It can be observed with basic
> ## floating point arithmetic:
> w1 + w2 - w2 - w1  # very small non-zero value!
[1] 5.384582e-13
> 
> ## Note that this only happens with the "sort" and "hash" methods but
> ## not with the "naive" method:
> coverage(y, width=100, weight=c(w1, w2), method="sort")
numeric-Rle of length 100 with 5 runs
  Lengths:           3           6           6           3          82
  Values : 0.00000e+00 9.58000e-01 1.00010e+04 9.58000e-01 5.38458e-13
> coverage(y, width=100, weight=c(w1, w2), method="hash")
numeric-Rle of length 100 with 5 runs
  Lengths:           3           6           6           3          82
  Values : 0.00000e+00 9.58000e-01 1.00010e+04 9.58000e-01 5.38458e-13
> coverage(y, width=100, weight=c(w1, w2), method="naive")
numeric-Rle of length 100 with 5 runs
  Lengths:         3         6         6         3        82
  Values :     0.000     0.958 10000.958     0.958     0.000
> 
> ## These very small non-zero coverage values in the no-coverage regions
> ## of the numeric-Rle object returned by coverage() are not always
> ## present. But when they are, they can cause problems downstream or
> ## in unit tests. For example downstream code that relies on things
> ## like 'cvg != 0' to find regions with coverage won't work properly.
> ## This can be mitigated either by selecting the "naive" method (be aware
> ## that this can slow down things significantly) or by "cleaning" 'cvg'
> ## first e.g. with something like 'cvg <- round(cvg, digits)' where
> ## 'digits' is a carefully chosen number of digits:
> cvg <- round(cvg, digits=3)
> 
> ## Note that this rounding will also have the interesting side effect of
> ## reducing the memory footprint of the Rle object in general (because
> ## some runs might get merged into a single run as a consequence of the
> ## rounding).
> 
> ## ---------------------------------------------------------------------
> ## C. COVERAGE OF AN IPos OBJECT
> ## ---------------------------------------------------------------------
> pos_runs <- IRanges(c(1, 5, 9), c(10, 8, 15))
> ipos <- IPos(pos_runs)
> coverage(ipos)
integer-Rle of length 15 with 3 runs
  Lengths: 4 6 5
  Values : 1 2 1
> 
> ## ---------------------------------------------------------------------
> ## D. COVERAGE OF AN IRangesList OBJECT
> ## ---------------------------------------------------------------------
> x <- IRangesList(A=IRanges(3*(4:-1), width=1:3), B=IRanges(2:10, width=5))
> cvg <- coverage(x)
> cvg
RleList of length 2
$A
integer-Rle of length 12 with 7 runs
  Lengths: 1 1 1 2 5 1 1
  Values : 1 0 1 0 1 0 1

$B
integer-Rle of length 14 with 10 runs
  Lengths: 1 1 1 1 1 5 1 1 1 1
  Values : 0 1 2 3 4 5 4 3 2 1

> 
> stopifnot(identical(cvg[[1]], coverage(x[[1]])))
> stopifnot(identical(cvg[[2]], coverage(x[[2]])))
> 
> coverage(x, width=c(50, 9))
RleList of length 2
$A
integer-Rle of length 50 with 8 runs
  Lengths:  1  1  1  2  5  1  1 38
  Values :  1  0  1  0  1  0  1  0

$B
integer-Rle of length 9 with 6 runs
  Lengths: 1 1 1 1 1 4
  Values : 0 1 2 3 4 5

> coverage(x, width=c(NA, 9))
RleList of length 2
$A
integer-Rle of length 12 with 7 runs
  Lengths: 1 1 1 2 5 1 1
  Values : 1 0 1 0 1 0 1

$B
integer-Rle of length 9 with 6 runs
  Lengths: 1 1 1 1 1 4
  Values : 0 1 2 3 4 5

> coverage(x, width=9)  # 'width' gets recycled
RleList of length 2
$A
integer-Rle of length 9 with 5 runs
  Lengths: 1 1 1 2 4
  Values : 1 0 1 0 1

$B
integer-Rle of length 9 with 6 runs
  Lengths: 1 1 1 1 1 4
  Values : 0 1 2 3 4 5

> 
> ## Each list element in 'shift' and 'weight' gets recycled to the length
> ## of the corresponding element in 'x'.
> weight <- list(as.integer(10^(0:5)), -0.77)
> cvg2 <- coverage(x, weight=weight)
> cvg2  # 1st coverage vector is an integer-Rle, 2nd is a numeric-Rle
RleList of length 2
$A
integer-Rle of length 12 with 8 runs
  Lengths:     1     1     1     2     3     2     1     1
  Values : 10000     0  1000     0   100    10     0     1

$B
numeric-Rle of length 14 with 10 runs
  Lengths:     1     1     1     1     1     5     1     1     1     1
  Values :  0.00 -0.77 -1.54 -2.31 -3.08 -3.85 -3.08 -2.31 -1.54 -0.77

> 
> identical(mapply(coverage, x=x, weight=weight), as.list(cvg2))
[1] TRUE
> 
> ## ---------------------------------------------------------------------
> ## E. SOME MATHEMATICAL PROPERTIES OF THE coverage() FUNCTION
> ## ---------------------------------------------------------------------
> 
> ## PROPERTY 1: The coverage vector is not affected by reordering the
> ## input ranges:
> set.seed(24)
> x <- IRanges(sample(1000, 40, replace=TRUE), width=17:10)
> cvg0 <- coverage(x)
> stopifnot(identical(coverage(sample(x)), cvg0))
> 
> ## Of course, if the ranges are shifted and/or assigned weights, then
> ## this doesn't hold anymore, unless the 'shift' and/or 'weight'
> ## arguments are reordered accordingly.
> 
> ## PROPERTY 2: The coverage of the concatenation of 2 IntegerRanges
> ## objects 'x' and 'y' is the sum of the 2 individual coverage vectors:
> y <- IRanges(sample(-20:280, 36, replace=TRUE), width=28)
> stopifnot(identical(coverage(c(x, y), width=100),
+                     coverage(x, width=100) + coverage(y, width=100)))
> 
> ## Note that, because adding 2 vectors in R recycles the shortest to
> ## the length of the longest, the following is generally FALSE:
> identical(coverage(c(x, y)), coverage(x) + coverage(y))  # FALSE
Warning in coverage(x) + coverage(y) :
  longer object length is not a multiple of shorter object length
[1] FALSE
> 
> ## It would only be TRUE if the 2 coverage vectors that we add had the
> ## same length, which would only happen by chance. By using the same
> ## 'width' value when we computed the 2 coverages previously, we made
> ## sure they had the same length.
> 
> ## Because of properties 1 & 2, we have:
> x1 <- x[c(TRUE, FALSE)]  # pick up 1st, 3rd, 5th, etc... ranges
> x2 <- x[c(FALSE, TRUE)]  # pick up 2nd, 4th, 6th, etc... ranges
> cvg1 <- coverage(x1, width=100)
> cvg2 <- coverage(x2, width=100)
> stopifnot(identical(coverage(x, width=100), cvg1 + cvg2))
> 
> ## PROPERTY 3: Multiplying the weights by a scalar has the effect of
> ## multiplying the coverage vector by the same scalar:
> weight <- runif(40)
> cvg3 <- coverage(x, weight=weight)
> stopifnot(all.equal(coverage(x, weight=-2.68 * weight), -2.68 * cvg3))
> 
> ## Because of properties 1 & 2 & 3, we have:
> stopifnot(identical(coverage(x, width=100, weight=c(5L, -11L)),
+                     5L * cvg1 - 11L * cvg2))
> 
> ## PROPERTY 4: Using the sum of 2 weight vectors produces the same
> ## result as using the 2 weight vectors separately and summing the
> ## 2 results:
> weight2 <- 10 * runif(40) + 3.7
> stopifnot(all.equal(coverage(x, weight=weight + weight2),
+                     cvg3 + coverage(x, weight=weight2)))
> 
> ## PROPERTY 5: Repeating any input range N number of times is
> ## equivalent to multiplying its assigned weight by N:
> times <- sample(0:10L, length(x), replace=TRUE)
> stopifnot(all.equal(coverage(rep(x, times), weight=rep(weight, times)),
+                     coverage(x, weight=weight * times)))
> 
> ## In particular, if 'weight' is not supplied:
> stopifnot(identical(coverage(rep(x, times)), coverage(x, weight=times)))
> 
> ## PROPERTY 6: If none of the input range actually gets clipped during
> ## the "shift and clip" process, then:
> ##
> ##     sum(cvg) = sum(width(x) * weight)
> ##
> stopifnot(sum(cvg3) == sum(width(x) * weight))
> 
> ## In particular, if 'weight' is not supplied:
> stopifnot(sum(cvg0) == sum(width(x)))
> 
> ## Note that this property is sometimes used in the context of a
> ## ChIP-Seq analysis to estimate "the number of reads in a peak", that
> ## is, the number of short reads that belong to a peak in the coverage
> ## vector computed from the genomic locations (a.k.a. genomic ranges)
> ## of the aligned reads. Because of property 6, the number of reads in
> ## a peak is approximately the area under the peak divided by the short
> ## read length.
> 
> ## PROPERTY 7: If 'weight' is not supplied, then disjoining or reducing
> ## the ranges before calling coverage() has the effect of "shaving" the
> ## coverage vector at elevation 1:
> table(cvg0)
cvg0
  0   1   2   3   4   5 
554 268  98  13   8   1 
> shaved_cvg0 <- cvg0
> runValue(shaved_cvg0) <- pmin(runValue(cvg0), 1L)
> table(shaved_cvg0)
shaved_cvg0
  0   1 
554 388 
> 
> stopifnot(identical(coverage(disjoin(x)), shaved_cvg0))
> stopifnot(identical(coverage(reduce(x)), shaved_cvg0))
> 
> ## ---------------------------------------------------------------------
> ## F. SOME SANITY CHECKS
> ## ---------------------------------------------------------------------
> dummy_coverage <- function(x, shift=0L, width=NULL)
+ {
+     y <- IRanges:::unlist_as_integer(shift(x, shift))
+     if (is.null(width))
+         width <- max(c(0L, y))
+     Rle(tabulate(y,  nbins=width))
+ }
> 
> check_real_vs_dummy <- function(x, shift=0L, width=NULL)
+ {
+     res1 <- coverage(x, shift=shift, width=width)
+     res2 <- dummy_coverage(x, shift=shift, width=width)
+     stopifnot(identical(res1, res2))
+ }
> check_real_vs_dummy(x)
> check_real_vs_dummy(x, shift=7)
> check_real_vs_dummy(x, shift=7, width=27)
> check_real_vs_dummy(x, shift=c(-4, 2))
> check_real_vs_dummy(x, shift=c(-4, 2), width=12)
> check_real_vs_dummy(x, shift=-max(end(x)))
> 
> ## With a set of distinct single positions:
> x3 <- IRanges(sample(50000, 20000), width=1)
> stopifnot(identical(sort(start(x3)), which(coverage(x3) != 0L)))
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("coverage-methods", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("extractList")
> ### * extractList
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: extractList
> ### Title: Group elements of a vector-like object into a list-like object
> ### Aliases: relist relist,ANY,PartitioningByEnd-method
> ###   relist,ANY,List-method relist,Vector,list-method extractList
> ###   extractList,ANY,ANY-method extractList,ANY-method regroup
> ### Keywords: manip
> 
> ### ** Examples
> 
> ## On an Rle object:
> x <- Rle(101:105, 6:2)
> i <- IRanges(6:10, 16:12, names=letters[1:5])
> extractList(x, i)
RleList of length 5
$a
integer-Rle of length 11 with 4 runs
  Lengths:   1   5   4   1
  Values : 101 102 103 104

$b
integer-Rle of length 9 with 2 runs
  Lengths:   5   4
  Values : 102 103

$c
integer-Rle of length 7 with 2 runs
  Lengths:   4   3
  Values : 102 103

$d
integer-Rle of length 5 with 2 runs
  Lengths:   3   2
  Values : 102 103

$e
integer-Rle of length 3 with 2 runs
  Lengths:   2   1
  Values : 102 103

> 
> ## On a DataFrame object:
> df <- DataFrame(X=x, Y=LETTERS[1:20])
> extractList(df, i)
SplitDataFrameList of length 5
$a
DataFrame with 11 rows and 2 columns
       X           Y
   <Rle> <character>
1    101           F
2    102           G
3    102           H
4    102           I
5    102           J
6    102           K
7    103           L
8    103           M
9    103           N
10   103           O
11   104           P

$b
DataFrame with 9 rows and 2 columns
      X           Y
  <Rle> <character>
1   102           G
2   102           H
3   102           I
4   102           J
5   102           K
6   103           L
7   103           M
8   103           N
9   103           O

...
<3 more elements>
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("extractList", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("extractListFragments")
> ### * extractListFragments
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: extractListFragments
> ### Title: Extract list fragments from a list-like object
> ### Aliases: INCOMPATIBLE_ARANGES_MSG extractListFragments equisplit
> ### Keywords: utilities
> 
> ### ** Examples
> 
> ## ---------------------------------------------------------------------
> ## A. extractListFragments()
> ## ---------------------------------------------------------------------
> 
> x <- IntegerList(a=101:109, b=5:-5)
> x
IntegerList of length 2
[["a"]] 101 102 103 104 105 106 107 108 109
[["b"]] 5 4 3 2 1 0 -1 -2 -3 -4 -5
> 
> aranges <- IRanges(start=c(2, 4, 8, 17, 17), end=c(3, 6, 14, 16, 19))
> aranges
IRanges object with 5 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         2         3         2
  [2]         4         6         3
  [3]         8        14         7
  [4]        17        16         0
  [5]        17        19         3
> extractListFragments(x, aranges)
IntegerList of length 6
[["a"]] 102 103
[["a"]] 104 105 106
[["a"]] 108 109
[["b"]] 5 4 3 2 1
[["b"]] integer(0)
[["b"]] -2 -3 -4
> 
> x2 <- IRanges(c(1, 101, 1001, 10001), width=c(10, 5, 0, 12),
+               names=letters[1:4])
> mcols(x2)$label <- LETTERS[1:4]
> x2
IRanges object with 4 ranges and 1 metadata column:
        start       end     width |       label
    <integer> <integer> <integer> | <character>
  a         1        10        10 |           A
  b       101       105         5 |           B
  c      1001      1000         0 |           C
  d     10001     10012        12 |           D
> 
> aranges <- IRanges(start=13, end=20)
> extractListFragments(x2, aranges)
IRanges object with 3 ranges and 2 metadata columns:
        start       end     width |    revmap   revmap2
    <integer> <integer> <integer> | <integer> <integer>
  b       103       105         3 |         2         1
  c      1001      1000         0 |         3         1
  d     10001     10005         5 |         4         1
> extractListFragments(x2, aranges, use.mcols=TRUE)
IRanges object with 3 ranges and 1 metadata column:
        start       end     width |       label
    <integer> <integer> <integer> | <character>
  b       103       105         3 |           B
  c      1001      1000         0 |           C
  d     10001     10005         5 |           D
> 
> aranges2 <- PartitioningByWidth(c(3, 9, 13, 0, 2))
> extractListFragments(x2, aranges2)
IRanges object with 8 ranges and 2 metadata columns:
        start       end     width |    revmap   revmap2
    <integer> <integer> <integer> | <integer> <integer>
  a         1         3         3 |         1         1
  a         4        10         7 |         1         2
  b       101       102         2 |         2         2
  b       103       105         3 |         2         3
  c      1001      1000         0 |         3         3
  d     10001     10010        10 |         4         3
  d     10011     10010         0 |         4         4
  d     10011     10012         2 |         4         5
> extractListFragments(x2, aranges2, use.mcols=TRUE)
IRanges object with 8 ranges and 1 metadata column:
        start       end     width |       label
    <integer> <integer> <integer> | <character>
  a         1         3         3 |           A
  a         4        10         7 |           A
  b       101       102         2 |           B
  b       103       105         3 |           B
  c      1001      1000         0 |           C
  d     10001     10010        10 |           D
  d     10011     10010         0 |           D
  d     10011     10012         2 |           D
> 
> x2b <- as(x2, "IntegerList")
> extractListFragments(x2b, aranges2)
IntegerList of length 8
[["a"]] 1 2 3
[["a"]] 4 5 6 7 8 9 10
[["b"]] 101 102
[["b"]] 103 104 105
[["c"]] integer(0)
[["d"]] 10001 10002 10003 10004 10005 10006 10007 10008 10009 10010
[["d"]] integer(0)
[["d"]] 10011 10012
> 
> x2c <- as.list(x2b)
> extractListFragments(x2c, aranges2, use.mcols=TRUE)
$a
[1] 1 2 3

$a
[1]  4  5  6  7  8  9 10

$b
[1] 101 102

$b
[1] 103 104 105

$c
integer(0)

$d
 [1] 10001 10002 10003 10004 10005 10006 10007 10008 10009 10010

$d
integer(0)

$d
[1] 10011 10012

> 
> ## ---------------------------------------------------------------------
> ## B. equisplit()
> ## ---------------------------------------------------------------------
> 
> ## equisplit() first calls breakInChunks() internally to create a
> ## PartitioningByWidth object that contains the absolute ranges of the
> ## chunks, then calls extractListFragments() on it 'x' to extract the
> ## fragments of 'x' that correspond to these absolute ranges. Finally
> ## the IRanges object returned by extractListFragments() is split into
> ## an IRangesList object where each list element corresponds to a chunk.
> equisplit(x2, nchunk=2)
IRangesList object of length 2:
[[1]]
IRanges object with 2 ranges and 1 metadata column:
        start       end     width |    revmap
    <integer> <integer> <integer> | <integer>
  a         1        10        10 |         1
  b       101       103         3 |         2

[[2]]
IRanges object with 3 ranges and 1 metadata column:
        start       end     width |    revmap
    <integer> <integer> <integer> | <integer>
  b       104       105         2 |         2
  c      1001      1000         0 |         3
  d     10001     10012        12 |         4

> equisplit(x2, nchunk=2, use.mcols=TRUE)
IRangesList object of length 2:
[[1]]
IRanges object with 2 ranges and 1 metadata column:
        start       end     width |       label
    <integer> <integer> <integer> | <character>
  a         1        10        10 |           A
  b       101       103         3 |           B

[[2]]
IRanges object with 3 ranges and 1 metadata column:
        start       end     width |       label
    <integer> <integer> <integer> | <character>
  b       104       105         2 |           B
  c      1001      1000         0 |           C
  d     10001     10012        12 |           D

> 
> equisplit(x2, chunksize=5)
IRangesList object of length 6:
[[1]]
IRanges object with 1 range and 1 metadata column:
        start       end     width |    revmap
    <integer> <integer> <integer> | <integer>
  a         1         5         5 |         1

[[2]]
IRanges object with 1 range and 1 metadata column:
        start       end     width |    revmap
    <integer> <integer> <integer> | <integer>
  a         6        10         5 |         1

[[3]]
IRanges object with 1 range and 1 metadata column:
        start       end     width |    revmap
    <integer> <integer> <integer> | <integer>
  b       101       105         5 |         2

...
<3 more elements>
> 
> library(GenomicRanges)
Loading required package: GenomeInfoDb
> gr <- GRanges(c("chr1", "chr2"), IRanges(1, c(100, 1e5)))
> equisplit(gr, nchunk=2)
GRangesList object of length 2:
[[1]]
GRanges object with 2 ranges and 1 metadata column:
      seqnames    ranges strand |    revmap
         <Rle> <IRanges>  <Rle> | <integer>
  [1]     chr1     1-100      * |         1
  [2]     chr2   1-49950      * |         2
  -------
  seqinfo: 2 sequences from an unspecified genome; no seqlengths

[[2]]
GRanges object with 1 range and 1 metadata column:
      seqnames       ranges strand |    revmap
         <Rle>    <IRanges>  <Rle> | <integer>
  [1]     chr2 49951-100000      * |         2
  -------
  seqinfo: 2 sequences from an unspecified genome; no seqlengths

> equisplit(gr, nchunk=1000)
GRangesList object of length 1000:
[[1]]
GRanges object with 1 range and 1 metadata column:
      seqnames    ranges strand |    revmap
         <Rle> <IRanges>  <Rle> | <integer>
  [1]     chr1     1-100      * |         1
  -------
  seqinfo: 2 sequences from an unspecified genome; no seqlengths

[[2]]
GRanges object with 1 range and 1 metadata column:
      seqnames    ranges strand |    revmap
         <Rle> <IRanges>  <Rle> | <integer>
  [1]     chr2     1-100      * |         2
  -------
  seqinfo: 2 sequences from an unspecified genome; no seqlengths

[[3]]
GRanges object with 1 range and 1 metadata column:
      seqnames    ranges strand |    revmap
         <Rle> <IRanges>  <Rle> | <integer>
  [1]     chr2   101-200      * |         2
  -------
  seqinfo: 2 sequences from an unspecified genome; no seqlengths

...
<997 more elements>
> 
> ## ---------------------------------------------------------------------
> ## C. ADVANCED extractListFragments() EXAMPLES
> ## ---------------------------------------------------------------------
> 
> ## === D1. Fragment list-like object into length 1 fragments ===
> 
> ## First we construct a Partitioning object where all the partitions
> ## have a width of 1:
> x2_cumlen <- nobj(PartitioningByWidth(x2))  # Equivalent to
>                                             # length(unlist(x2)) except
>                                             # that it doesn't unlist 'x2'
>                                             # so is much more efficient.
> aranges1 <- PartitioningByEnd(seq_len(x2_cumlen))
> aranges1
PartitioningByEnd object with 27 ranges and 0 metadata columns:
           start       end     width
       <integer> <integer> <integer>
   [1]         1         1         1
   [2]         2         2         1
   [3]         3         3         1
   [4]         4         4         1
   [5]         5         5         1
   ...       ...       ...       ...
  [23]        23        23         1
  [24]        24        24         1
  [25]        25        25         1
  [26]        26        26         1
  [27]        27        27         1
> 
> ## Then we use it to fragment 'x2':
> extractListFragments(x2, aranges1)
IRanges object with 27 ranges and 2 metadata columns:
        start       end     width |    revmap   revmap2
    <integer> <integer> <integer> | <integer> <integer>
  a         1         1         1 |         1         1
  a         2         2         1 |         1         2
  a         3         3         1 |         1         3
  a         4         4         1 |         1         4
  a         5         5         1 |         1         5
  .       ...       ...       ... .       ...       ...
  d     10008     10008         1 |         4        23
  d     10009     10009         1 |         4        24
  d     10010     10010         1 |         4        25
  d     10011     10011         1 |         4        26
  d     10012     10012         1 |         4        27
> extractListFragments(x2b, aranges1)
IntegerList of length 27
[["a"]] 1
[["a"]] 2
[["a"]] 3
[["a"]] 4
[["a"]] 5
[["a"]] 6
[["a"]] 7
[["a"]] 8
[["a"]] 9
[["a"]] 10
...
<17 more elements>
> extractListFragments(x2c, aranges1, use.mcols=TRUE)
$a
[1] 1

$a
[1] 2

$a
[1] 3

$a
[1] 4

$a
[1] 5

$a
[1] 6

$a
[1] 7

$a
[1] 8

$a
[1] 9

$a
[1] 10

$b
[1] 101

$b
[1] 102

$b
[1] 103

$b
[1] 104

$b
[1] 105

$d
[1] 10001

$d
[1] 10002

$d
[1] 10003

$d
[1] 10004

$d
[1] 10005

$d
[1] 10006

$d
[1] 10007

$d
[1] 10008

$d
[1] 10009

$d
[1] 10010

$d
[1] 10011

$d
[1] 10012

> 
> ## === D2. Fragment a Partitioning object ===
> 
> partitioning2 <- PartitioningByEnd(x2b)  # same as PartitioningByEnd(x2)
> extractListFragments(partitioning2, aranges2)
PartitioningByEnd object with 8 ranges and 2 metadata columns:
        start       end     width |    revmap   revmap2
    <integer> <integer> <integer> | <integer> <integer>
  a         1         3         3 |         1         1
  a         4        10         7 |         1         2
  b        11        12         2 |         2         2
  b        13        15         3 |         2         3
  c        16        15         0 |         3         3
  d        16        25        10 |         4         3
  d        26        25         0 |         4         4
  d        26        27         2 |         4         5
> 
> ## Note that when the 1st arg is a Partitioning derivative, then
> ## swapping the 1st and 2nd elements in the call to extractListFragments()
> ## doesn't change the returned partitioning:
> extractListFragments(aranges2, partitioning2)
PartitioningByWidth object with 8 ranges and 2 metadata columns:
          start       end     width |    revmap   revmap2
      <integer> <integer> <integer> | <integer> <integer>
  [1]         1         3         3 |         1         1
  [2]         4        10         7 |         2         1
  [3]        11        12         2 |         2         2
  [4]        13        15         3 |         3         2
  [5]        16        15         0 |         3         3
  [6]        16        25        10 |         3         4
  [7]        26        25         0 |         4         4
  [8]        26        27         2 |         5         4
> 
> ## ---------------------------------------------------------------------
> ## D. SANITY CHECKS
> ## ---------------------------------------------------------------------
> 
> ## If 'aranges' is 'PartitioningByEnd(x)' or 'PartitioningByWidth(x)'
> ## and 'x' has no zero-length list elements, then
> ## 'extractListFragments(x, aranges, use.mcols=TRUE)' is a no-op.
> check_no_ops <- function(x) {
+   aranges <- PartitioningByEnd(x)
+   stopifnot(identical(
+     extractListFragments(x, aranges, use.mcols=TRUE), x
+   ))
+   aranges <- PartitioningByWidth(x)
+   stopifnot(identical(
+     extractListFragments(x, aranges, use.mcols=TRUE), x
+   ))
+ }
> 
> check_no_ops(x2[lengths(x2) != 0])
> check_no_ops(x2b[lengths(x2b) != 0])
> check_no_ops(x2c[lengths(x2c) != 0])
> check_no_ops(gr)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("extractListFragments", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching 'package:GenomicRanges', 'package:GenomeInfoDb'

> nameEx("findOverlaps-methods")
> ### * findOverlaps-methods
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: findOverlaps-methods
> ### Title: Finding overlapping ranges
> ### Aliases: findOverlaps-methods findOverlaps
> ###   findOverlaps,IntegerRanges,IntegerRanges-method
> ###   findOverlaps,integer,IntegerRanges-method
> ###   findOverlaps,Vector,missing-method
> ###   findOverlaps,IntegerRangesList,IntegerRangesList-method
> ###   findOverlaps,Pairs,missing-method findOverlaps,Pairs,ANY-method
> ###   findOverlaps,ANY,Pairs-method findOverlaps,Pairs,Pairs-method
> ###   countOverlaps countOverlaps,Vector,Vector-method
> ###   countOverlaps,integer,Vector-method
> ###   countOverlaps,Vector,missing-method
> ###   countOverlaps,IntegerRanges,IntegerRanges-method
> ###   countOverlaps,IntegerRangesList,IntegerRangesList-method overlapsAny
> ###   overlapsAny,Vector,Vector-method overlapsAny,integer,Vector-method
> ###   overlapsAny,Vector,missing-method
> ###   overlapsAny,IntegerRangesList,IntegerRangesList-method %over%
> ###   %within% %outside% subsetByOverlaps
> ###   subsetByOverlaps,Vector,Vector-method overlapsRanges
> ###   overlapsRanges,IntegerRanges,IntegerRanges-method
> ###   overlapsRanges,IntegerRangesList,IntegerRangesList-method poverlaps
> ###   poverlaps,IntegerRanges,IntegerRanges-method
> ###   poverlaps,IntegerRanges,integer-method
> ###   poverlaps,integer,IntegerRanges-method mergeByOverlaps
> ###   findOverlapPairs
> ### Keywords: methods
> 
> ### ** Examples
> 
> ## ---------------------------------------------------------------------
> ## findOverlaps()
> ## ---------------------------------------------------------------------
> 
> query <- IRanges(c(1, 4, 9), c(5, 7, 10))
> subject <- IRanges(c(2, 2, 10), c(2, 3, 12))
> 
> findOverlaps(query, subject)
Hits object with 3 hits and 0 metadata columns:
      queryHits subjectHits
      <integer>   <integer>
  [1]         1           2
  [2]         1           1
  [3]         3           3
  -------
  queryLength: 3 / subjectLength: 3
> 
> ## at most one hit per query
> findOverlaps(query, subject, select="first")
[1]  1 NA  3
> findOverlaps(query, subject, select="last")
[1]  2 NA  3
> findOverlaps(query, subject, select="arbitrary")
[1]  2 NA  3
> 
> ## including adjacent ranges in the result
> findOverlaps(query, subject, maxgap=0L)
Hits object with 4 hits and 0 metadata columns:
      queryHits subjectHits
      <integer>   <integer>
  [1]         1           2
  [2]         1           1
  [3]         2           2
  [4]         3           3
  -------
  queryLength: 3 / subjectLength: 3
> 
> query <- IRanges(c(1, 4, 9), c(5, 7, 10))
> subject <- IRanges(c(2, 2), c(5, 4))
> 
> ## one IRanges object with itself
> findOverlaps(query)
SelfHits object with 5 hits and 0 metadata columns:
      queryHits subjectHits
      <integer>   <integer>
  [1]         1           1
  [2]         1           2
  [3]         2           1
  [4]         2           2
  [5]         3           3
  -------
  queryLength: 3 / subjectLength: 3
> 
> ## single points as query
> subject <- IRanges(c(1, 6, 13), c(4, 9, 14))
> findOverlaps(c(3L, 7L, 10L), subject, select="first")
[1]  1  2 NA
> 
> ## special overlap types
> query <- IRanges(c(1, 5, 3, 4), width=c(2, 2, 4, 6))
> subject <- IRanges(c(1, 3, 5, 6), width=c(4, 4, 5, 4))
> 
> findOverlaps(query, subject, type="start")
Hits object with 3 hits and 0 metadata columns:
      queryHits subjectHits
      <integer>   <integer>
  [1]         1           1
  [2]         2           3
  [3]         3           2
  -------
  queryLength: 4 / subjectLength: 4
> findOverlaps(query, subject, type="start", maxgap=1L)
Hits object with 6 hits and 0 metadata columns:
      queryHits subjectHits
      <integer>   <integer>
  [1]         1           1
  [2]         2           3
  [3]         2           4
  [4]         3           2
  [5]         4           2
  [6]         4           3
  -------
  queryLength: 4 / subjectLength: 4
> findOverlaps(query, subject, type="end", select="first")
[1] NA  2  2  3
> ov <- findOverlaps(query, subject, type="within", maxgap=1L)
> ov
Hits object with 1 hit and 0 metadata columns:
      queryHits subjectHits
      <integer>   <integer>
  [1]         3           2
  -------
  queryLength: 4 / subjectLength: 4
> 
> ## Using pairs to find intersection of overlapping ranges
> hits <- findOverlaps(query, subject)
> p <- Pairs(query, subject, hits=hits)
> pintersect(p)
IRanges object with 12 ranges and 0 metadata columns:
           start       end     width
       <integer> <integer> <integer>
   [1]         1         2         2
   [2]         5         6         2
   [3]         5         6         2
   [4]         6         6         1
   [5]         3         4         2
   ...       ...       ...       ...
   [8]         6         6         1
   [9]         4         4         1
  [10]         4         6         3
  [11]         5         9         5
  [12]         6         9         4
> 
> ## Shortcut
> p <- findOverlapPairs(query, subject)
> pintersect(p)
IRanges object with 12 ranges and 0 metadata columns:
           start       end     width
       <integer> <integer> <integer>
   [1]         1         2         2
   [2]         5         6         2
   [3]         5         6         2
   [4]         6         6         1
   [5]         3         4         2
   ...       ...       ...       ...
   [8]         6         6         1
   [9]         4         4         1
  [10]         4         6         3
  [11]         5         9         5
  [12]         6         9         4
> 
> ## ---------------------------------------------------------------------
> ## overlapsAny()
> ## ---------------------------------------------------------------------
> 
> overlapsAny(query, subject, type="start")
[1]  TRUE  TRUE  TRUE FALSE
> overlapsAny(query, subject, type="end")
[1] FALSE  TRUE  TRUE  TRUE
> query %over% subject    # same as overlapsAny(query, subject)
[1] TRUE TRUE TRUE TRUE
> query %within% subject  # same as overlapsAny(query, subject,
[1]  TRUE  TRUE  TRUE FALSE
>                           #                     type="within")
> 
> ## ---------------------------------------------------------------------
> ## overlapsRanges()
> ## ---------------------------------------------------------------------
> 
> ## Extract the regions of intersection between the overlapping ranges:
> overlapsRanges(query, subject, ov)
IRanges object with 1 range and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         3         6         4
> 
> ## ---------------------------------------------------------------------
> ## Using IntegerRangesList objects
> ## ---------------------------------------------------------------------
> 
> query <- IRanges(c(1, 4, 9), c(5, 7, 10))
> qpartition <- factor(c("a","a","b"))
> qlist <- split(query, qpartition)
> 
> subject <- IRanges(c(2, 2, 10), c(2, 3, 12))
> spartition <- factor(c("a","a","b"))
> slist <- split(subject, spartition)
> 
> ## at most one hit per query
> findOverlaps(qlist, slist, select="first")
IntegerList of length 2
[["a"]] 1 <NA>
[["b"]] 1
> findOverlaps(qlist, slist, select="last")
IntegerList of length 2
[["a"]] 2 <NA>
[["b"]] 1
> findOverlaps(qlist, slist, select="arbitrary")
IntegerList of length 2
[["a"]] 2 <NA>
[["b"]] 1
> 
> query <- IRanges(c(1, 5, 3, 4), width=c(2, 2, 4, 6))
> qpartition <- factor(c("a","a","b","b"))
> qlist <- split(query, qpartition)
> 
> subject <- IRanges(c(1, 3, 5, 6), width=c(4, 4, 5, 4))
> spartition <- factor(c("a","a","b","b"))
> slist <- split(subject, spartition)
> 
> overlapsAny(qlist, slist, type="start")
LogicalList of length 2
[["a"]] TRUE FALSE
[["b"]] FALSE FALSE
> overlapsAny(qlist, slist, type="end")
LogicalList of length 2
[["a"]] FALSE TRUE
[["b"]] FALSE TRUE
> qlist 
IRangesList object of length 2:
$a
IRanges object with 2 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         1         2         2
  [2]         5         6         2

$b
IRanges object with 2 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         3         6         4
  [2]         4         9         6

> 
> subsetByOverlaps(qlist, slist)
IRangesList object of length 2:
$a
IRanges object with 2 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         1         2         2
  [2]         5         6         2

$b
IRanges object with 2 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         3         6         4
  [2]         4         9         6

> countOverlaps(qlist, slist)
IntegerList of length 2
[["a"]] 1 1
[["b"]] 2 2
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("findOverlaps-methods", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("inter-range-methods")
> ### * inter-range-methods
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: inter-range-methods
> ### Title: Inter range transformations of an IntegerRanges, Views,
> ###   IntegerRangesList, or MaskCollection object
> ### Aliases: inter-range-methods range range,IntegerRanges-method
> ###   range,StitchedIPos-method range,IntegerRangesList-method
> ###   range,CompressedIRangesList-method reduce reduce,IntegerRanges-method
> ###   reduce,Views-method reduce,IntegerRangesList-method
> ###   reduce,CompressedIRangesList-method gaps gaps,IntegerRanges-method
> ###   gaps,Views-method gaps,IntegerRangesList-method
> ###   gaps,CompressedIRangesList-method gaps,MaskCollection-method disjoin
> ###   disjoin,IntegerRanges-method disjoin,NormalIRanges-method
> ###   disjoin,IntegerRangesList-method disjoin,CompressedIRangesList-method
> ###   isDisjoint isDisjoint,IntegerRanges-method
> ###   isDisjoint,StitchedIPos-method isDisjoint,NormalIRanges-method
> ###   isDisjoint,IntegerRangesList-method disjointBins
> ###   disjointBins,IntegerRanges-method disjointBins,NormalIRanges-method
> ###   disjointBins,IntegerRangesList-method
> ### Keywords: utilities
> 
> ### ** Examples
> 
> ## ---------------------------------------------------------------------
> ## range()
> ## ---------------------------------------------------------------------
> 
> ## On an IntegerRanges object:
> x <- IRanges(start=c(-2, 6, 9, -4, 1, 0, -6, 3, 10),
+              width=c( 5, 0, 6,  1, 4, 3,  2, 0,  3))
> range(x)
IRanges object with 1 range and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]        -6        14        21
> 
> ## On an IntegerRangesList object (XVector package required):
> range1 <- IRanges(start=c(1, 2, 3), end=c(5, 2, 8))
> range2 <- IRanges(start=c(15, 45, 20, 1), end=c(15, 100, 80, 5))
> range3 <- IRanges(start=c(-2, 6, 7), width=c(8, 0, 0))  # with empty ranges
> collection <- IRangesList(one=range1, range2, range3)
> if (require(XVector)) {
+     range(collection)
+ }
Loading required package: XVector
IRangesList object of length 3:
$one
IRanges object with 1 range and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         1         8         8

[[2]]
IRanges object with 1 range and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         1       100       100

[[3]]
IRanges object with 1 range and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]        -2         6         9

> 
> irl1 <- IRangesList(a=IRanges(c(1, 2),c(4, 3)), b=IRanges(c(4, 6),c(10, 7)))
> irl2 <- IRangesList(c=IRanges(c(0, 2),c(4, 5)), a=IRanges(c(4, 5),c(6, 7)))
> range(irl1, irl2)  # matched by names
IRangesList object of length 3:
$a
IRanges object with 1 range and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         1         7         7

$b
IRanges object with 1 range and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         4        10         7

$c
IRanges object with 1 range and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         0         5         6

> names(irl2) <- NULL
> range(irl1, irl2)  # now by position
IRangesList object of length 2:
[[1]]
IRanges object with 1 range and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         0         5         6

[[2]]
IRanges object with 1 range and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         4        10         7

> 
> ## ---------------------------------------------------------------------
> ## reduce()
> ## ---------------------------------------------------------------------
> 
> ## On an IntegerRanges object:
> reduce(x)
IRanges object with 4 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]        -6        -4         3
  [2]        -2         4         7
  [3]         6         5         0
  [4]         9        14         6
> y <- reduce(x, with.revmap=TRUE)
> mcols(y)$revmap  # an IntegerList
IntegerList of length 4
[[1]] 7 4
[[2]] 1 6 5 8
[[3]] 2
[[4]] 3 9
> 
> reduce(x, drop.empty.ranges=TRUE)
IRanges object with 3 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]        -6        -4         3
  [2]        -2         4         7
  [3]         9        14         6
> y <- reduce(x, drop.empty.ranges=TRUE, with.revmap=TRUE)
> mcols(y)$revmap
IntegerList of length 3
[[1]] 7 4
[[2]] 1 6 5
[[3]] 3 9
> 
> ## Use the mapping from reduced to original ranges to split the DataFrame
> ## of original metadata columns by reduced range:
> ir0 <- IRanges(c(11:13, 2, 7:6), width=3)
> mcols(ir0) <- DataFrame(id=letters[1:6], score=1:6)
> ir <- reduce(ir0, with.revmap=TRUE)
> ir
IRanges object with 3 ranges and 1 metadata column:
          start       end     width |        revmap
      <integer> <integer> <integer> | <IntegerList>
  [1]         2         4         3 |             4
  [2]         6         9         4 |           6,5
  [3]        11        15         5 |         1,2,3
> revmap <- mcols(ir)$revmap
> revmap
IntegerList of length 3
[[1]] 4
[[2]] 6 5
[[3]] 1 2 3
> relist(mcols(ir0)[unlist(revmap), ], revmap)  # a SplitDataFrameList
SplitDataFrameList of length 3
[[1]]
DataFrame with 1 row and 2 columns
           id     score
  <character> <integer>
1           d         4

[[2]]
DataFrame with 2 rows and 2 columns
           id     score
  <character> <integer>
1           f         6
2           e         5

[[3]]
DataFrame with 3 rows and 2 columns
           id     score
  <character> <integer>
1           a         1
2           b         2
3           c         3

> 
> ## On an IntegerRangesList object. These 4 are the same:
> res1 <- reduce(collection)
> res2 <- IRangesList(one=reduce(range1), reduce(range2), reduce(range3))
> res3 <- do.call(IRangesList, lapply(collection, reduce))
> res4 <- endoapply(collection, reduce)
> 
> stopifnot(identical(res2, res1))
> stopifnot(identical(res3, res1))
> stopifnot(identical(res4, res1))
> 
> reduce(collection, drop.empty.ranges=TRUE)
IRangesList object of length 3:
$one
IRanges object with 1 range and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         1         8         8

[[2]]
IRanges object with 3 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         1         5         5
  [2]        15        15         1
  [3]        20       100        81

[[3]]
IRanges object with 1 range and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]        -2         5         8

> 
> ## ---------------------------------------------------------------------
> ## gaps()
> ## ---------------------------------------------------------------------
> 
> ## On an IntegerRanges object:
> x0 <- IRanges(start=c(-2, 6, 9, -4, 1, 0, -6, 10),
+               width=c( 5, 0, 6,  1, 4, 3,  2,  3))
> gaps(x0)
IRanges object with 2 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]        -3        -3         1
  [2]         5         8         4
> gaps(x0, start=-6, end=20)
IRanges object with 3 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]        -3        -3         1
  [2]         5         8         4
  [3]        15        20         6
> 
> ## On a Views object:
> subject <- Rle(1:-3, 6:2)
> v <- Views(subject, start=c(8, 3), end=c(14, 4))
> gaps(v)
Views on a 20-length Rle subject

views:
    start end width
[1]     1   2     2 [1 1]
[2]     5   7     3 [1 1 0]
[3]    15  20     6 [-1 -2 -2 -2 -3 -3]
> 
> ## On an IntegerRangesList object. These 4 are the same:
> res1 <- gaps(collection)
> res2 <- IRangesList(one=gaps(range1), gaps(range2), gaps(range3))
> res3 <- do.call(IRangesList, lapply(collection, gaps))
> res4 <- endoapply(collection, gaps)
> 
> stopifnot(identical(res2, res1))
> stopifnot(identical(res3, res1))
> stopifnot(identical(res4, res1))
> 
> ## On a MaskCollection object:
> mask1 <- Mask(mask.width=29, start=c(11, 25, 28), width=c(5, 2, 2))
> mask2 <- Mask(mask.width=29, start=c(3, 10, 27), width=c(5, 8, 1))
> mask3 <- Mask(mask.width=29, start=c(7, 12), width=c(2, 4))
> mymasks <- append(append(mask1, mask2), mask3)
> mymasks
MaskCollection of length 3 and width 29
masks:
  maskedwidth maskedratio active
1           9   0.3103448   TRUE
2          14   0.4827586   TRUE
3           6   0.2068966   TRUE
all masks together:
  maskedwidth maskedratio
           19   0.6551724
> gaps(mymasks)
MaskCollection of length 3 and width 29
masks:
  maskedwidth maskedratio active
1          20   0.6896552   TRUE
2          15   0.5172414   TRUE
3          23   0.7931034   TRUE
all masks together:
  maskedwidth maskedratio
           25    0.862069
> 
> ## ---------------------------------------------------------------------
> ## disjoin()
> ## ---------------------------------------------------------------------
> 
> ## On an IntegerRanges object:
> ir <- IRanges(c(1, 1, 4, 10), c(6, 3, 8, 10))
> disjoin(ir)  # IRanges(c(1, 4, 7, 10), c(3, 6, 8, 10))
IRanges object with 4 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         1         3         3
  [2]         4         6         3
  [3]         7         8         2
  [4]        10        10         1
> disjoin(ir, with.revmap=TRUE)
IRanges object with 4 ranges and 1 metadata column:
          start       end     width |        revmap
      <integer> <integer> <integer> | <IntegerList>
  [1]         1         3         3 |           1,2
  [2]         4         6         3 |           1,3
  [3]         7         8         2 |             3
  [4]        10        10         1 |             4
> 
> ## On an IntegerRangesList object:
> disjoin(collection)
IRangesList object of length 3:
$one
IRanges object with 4 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         1         1         1
  [2]         2         2         1
  [3]         3         5         3
  [4]         6         8         3

[[2]]
IRanges object with 5 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         1         5         5
  [2]        15        15         1
  [3]        20        44        25
  [4]        45        80        36
  [5]        81       100        20

[[3]]
IRanges object with 1 range and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]        -2         5         8

> disjoin(collection, with.revmap=TRUE)
IRangesList object of length 3:
$one
IRanges object with 4 ranges and 1 metadata column:
          start       end     width |        revmap
      <integer> <integer> <integer> | <IntegerList>
  [1]         1         1         1 |             1
  [2]         2         2         1 |           1,2
  [3]         3         5         3 |           1,3
  [4]         6         8         3 |             3

[[2]]
IRanges object with 5 ranges and 1 metadata column:
          start       end     width |        revmap
      <integer> <integer> <integer> | <IntegerList>
  [1]         1         5         5 |             4
  [2]        15        15         1 |             1
  [3]        20        44        25 |             3
  [4]        45        80        36 |           2,3
  [5]        81       100        20 |             2

[[3]]
IRanges object with 1 range and 1 metadata column:
          start       end     width |        revmap
      <integer> <integer> <integer> | <IntegerList>
  [1]        -2         5         8 |             1

> 
> ## ---------------------------------------------------------------------
> ## isDisjoint()
> ## ---------------------------------------------------------------------
> 
> ## On an IntegerRanges object:
> isDisjoint(IRanges(c(2,5,1), c(3,7,3)))  # FALSE
[1] FALSE
> isDisjoint(IRanges(c(2,9,5), c(3,9,6)))  # TRUE
[1] TRUE
> isDisjoint(IRanges(1, 5))  # TRUE
[1] TRUE
> 
> ## Handling of empty ranges:
> x <- IRanges(c(11, 16, 11, -2, 11), c(15, 29, 10, 10, 10))
> stopifnot(isDisjoint(x))
> 
> ## Sliding an empty range along a non-empty range:
> sapply(11:17,
+        function(i) pcompare(IRanges(i, width=0), IRanges(12, 15)))
[1] -6 -5  2  2  2  5  6
> 
> sapply(11:17,
+        function(i) isDisjoint(c(IRanges(i, width=0), IRanges(12, 15))))
[1]  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE
> 
> ## On an IntegerRangesList object:
> isDisjoint(collection)
  one             
FALSE FALSE  TRUE 
> 
> ## ---------------------------------------------------------------------
> ## disjointBins()
> ## ---------------------------------------------------------------------
> 
> ## On an IntegerRanges object:
> disjointBins(IRanges(1, 5))  # 1L
[1] 1
> disjointBins(IRanges(c(3, 1, 10), c(5, 12, 13)))  # c(2L, 1L, 2L)
[1] 2 1 2
> 
> ## On an IntegerRangesList object:
> disjointBins(collection)
IntegerList of length 3
[["one"]] 1 2 2
[[""]] 1 2 1 1
[[""]] 1 1 1
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("inter-range-methods", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching 'package:XVector'

> nameEx("intra-range-methods")
> ### * intra-range-methods
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: intra-range-methods
> ### Title: Intra range transformations of an IRanges, IPos, Views,
> ###   RangesList, or MaskCollection object
> ### Aliases: intra-range-methods update_ranges update_ranges,IRanges-method
> ###   update_ranges,Views-method shift shift,Ranges-method
> ###   shift,IPos-method shift,RangesList-method narrow narrow,ANY-method
> ###   windows,Ranges-method narrow,MaskCollection-method resize
> ###   resize,Ranges-method resize,RangesList-method flank
> ###   flank,Ranges-method flank,RangesList-method promoters
> ###   promoters,IntegerRanges-method promoters,RangesList-method reflect
> ###   reflect,IntegerRanges-method restrict restrict,IntegerRanges-method
> ###   restrict,Views-method restrict,RangesList-method threebands
> ###   threebands,IRanges-method Ops,Ranges,numeric-method
> ###   Ops,RangesList,numeric-method Ops,CompressedRangesList,numeric-method
> ### Keywords: utilities
> 
> ### ** Examples
> 
> ## ---------------------------------------------------------------------
> ## shift()
> ## ---------------------------------------------------------------------
> 
> ## On an IRanges object:
> ir1 <- successiveIRanges(c(19, 5, 0, 8, 5))
> ir1
IRanges object with 5 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         1        19        19
  [2]        20        24         5
  [3]        25        24         0
  [4]        25        32         8
  [5]        33        37         5
> shift(ir1, shift=-3)
IRanges object with 5 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]        -2        16        19
  [2]        17        21         5
  [3]        22        21         0
  [4]        22        29         8
  [5]        30        34         5
> 
> ## On an IRangesList object:
> range1 <- IRanges(start=c(1, 2, 3), end=c(5, 2, 8))
> range2 <- IRanges(start=c(15, 45, 20, 1), end=c(15, 100, 80, 5))
> range3 <- IRanges(start=c(-2, 6, 7), width=c(8, 0, 0))  # with empty ranges
> collection <- IRangesList(one=range1, range2, range3)
> shift(collection, shift=5)  # same as endoapply(collection, shift, shift=5)
IRangesList object of length 3:
$one
IRanges object with 3 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         6        10         5
  [2]         7         7         1
  [3]         8        13         6

[[2]]
IRanges object with 4 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]        20        20         1
  [2]        50       105        56
  [3]        25        85        61
  [4]         6        10         5

[[3]]
IRanges object with 3 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         3        10         8
  [2]        11        10         0
  [3]        12        11         0

> 
> ## Sanity check:
> res1 <- shift(collection, shift=5)
> res2 <- endoapply(collection, shift, shift=5)
> stopifnot(identical(res1, res2))
> 
> ## ---------------------------------------------------------------------
> ## narrow()
> ## ---------------------------------------------------------------------
> 
> ## On an IRanges object:
> ir2 <- ir1[width(ir1) != 0]
> narrow(ir2, start=4, end=-2)
IRanges object with 4 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         4        18        15
  [2]        23        23         1
  [3]        28        31         4
  [4]        36        36         1
> narrow(ir2, start=-4, end=-2)
IRanges object with 4 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]        16        18         3
  [2]        21        23         3
  [3]        29        31         3
  [4]        34        36         3
> narrow(ir2, end=5, width=3)
IRanges object with 4 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         3         5         3
  [2]        22        24         3
  [3]        27        29         3
  [4]        35        37         3
> narrow(ir2, start=c(3, 4, 2, 3), end=c(12, 5, 7, 4))
IRanges object with 4 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         3        12        10
  [2]        23        24         2
  [3]        26        31         6
  [4]        35        36         2
> 
> ## On an IRangesList object:
> narrow(collection[-3], start=2)
IRangesList object of length 2:
$one
IRanges object with 3 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         2         5         4
  [2]         3         2         0
  [3]         4         8         5

[[2]]
IRanges object with 4 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]        16        15         0
  [2]        46       100        55
  [3]        21        80        60
  [4]         2         5         4

> narrow(collection[-3], end=-2)
IRangesList object of length 2:
$one
IRanges object with 3 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         1         4         4
  [2]         2         1         0
  [3]         3         7         5

[[2]]
IRanges object with 4 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]        15        14         0
  [2]        45        99        55
  [3]        20        79        60
  [4]         1         4         4

> 
> ## On a MaskCollection object:
> mask1 <- Mask(mask.width=29, start=c(11, 25, 28), width=c(5, 2, 2))
> mask2 <- Mask(mask.width=29, start=c(3, 10, 27), width=c(5, 8, 1))
> mask3 <- Mask(mask.width=29, start=c(7, 12), width=c(2, 4))
> mymasks <- append(append(mask1, mask2), mask3)
> mymasks
MaskCollection of length 3 and width 29
masks:
  maskedwidth maskedratio active
1           9   0.3103448   TRUE
2          14   0.4827586   TRUE
3           6   0.2068966   TRUE
all masks together:
  maskedwidth maskedratio
           19   0.6551724
> narrow(mymasks, start=8)
MaskCollection of length 3 and width 22
masks:
  maskedwidth maskedratio active
1           9   0.4090909   TRUE
2           9   0.4090909   TRUE
3           5   0.2272727   TRUE
all masks together:
  maskedwidth maskedratio
           14   0.6363636
> 
> ## ---------------------------------------------------------------------
> ## resize()
> ## ---------------------------------------------------------------------
> 
> ## On an IRanges object:
> resize(ir2, 200)
IRanges object with 4 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         1       200       200
  [2]        20       219       200
  [3]        25       224       200
  [4]        33       232       200
> resize(ir2, 2, fix="end")
IRanges object with 4 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]        18        19         2
  [2]        23        24         2
  [3]        31        32         2
  [4]        36        37         2
> 
> ## On an IRangesList object:
> resize(collection, width=200)
IRangesList object of length 3:
$one
IRanges object with 3 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         1       200       200
  [2]         2       201       200
  [3]         3       202       200

[[2]]
IRanges object with 4 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]        15       214       200
  [2]        45       244       200
  [3]        20       219       200
  [4]         1       200       200

[[3]]
IRanges object with 3 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]        -2       197       200
  [2]         6       205       200
  [3]         7       206       200

> 
> ## ---------------------------------------------------------------------
> ## flank()
> ## ---------------------------------------------------------------------
> 
> ## On an IRanges object:
> ir3 <- IRanges(c(2,5,1), c(3,7,3))
> flank(ir3, 2)
IRanges object with 3 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         0         1         2
  [2]         3         4         2
  [3]        -1         0         2
> flank(ir3, 2, start=FALSE)
IRanges object with 3 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         4         5         2
  [2]         8         9         2
  [3]         4         5         2
> flank(ir3, 2, start=c(FALSE, TRUE, FALSE))
IRanges object with 3 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         4         5         2
  [2]         3         4         2
  [3]         4         5         2
> flank(ir3, c(2, -2, 2))
IRanges object with 3 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         0         1         2
  [2]         5         6         2
  [3]        -1         0         2
> flank(ir3, 2, both = TRUE)
IRanges object with 3 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         0         3         4
  [2]         3         6         4
  [3]        -1         2         4
> flank(ir3, 2, start=FALSE, both=TRUE)
IRanges object with 3 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         2         5         4
  [2]         6         9         4
  [3]         2         5         4
> flank(ir3, -2, start=FALSE, both=TRUE)
IRanges object with 3 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         2         5         4
  [2]         6         9         4
  [3]         2         5         4
> 
> ## On an IRangesList object:
> flank(collection, width=10)
IRangesList object of length 3:
$one
IRanges object with 3 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]        -9         0        10
  [2]        -8         1        10
  [3]        -7         2        10

[[2]]
IRanges object with 4 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         5        14        10
  [2]        35        44        10
  [3]        10        19        10
  [4]        -9         0        10

[[3]]
IRanges object with 3 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]       -12        -3        10
  [2]        -4         5        10
  [3]        -3         6        10

> 
> ## ---------------------------------------------------------------------
> ## promoters()
> ## ---------------------------------------------------------------------
> 
> ## On an IRanges object:
> ir4 <- IRanges(20:23, width=3)
> promoters(ir4, upstream=0, downstream=0) ## no change
IRanges object with 4 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]        20        19         0
  [2]        21        20         0
  [3]        22        21         0
  [4]        23        22         0
> promoters(ir4, upstream=0, downstream=1) ## start value only
IRanges object with 4 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]        20        20         1
  [2]        21        21         1
  [3]        22        22         1
  [4]        23        23         1
> promoters(ir4, upstream=1, downstream=0) ## single upstream nucleotide
IRanges object with 4 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]        19        19         1
  [2]        20        20         1
  [3]        21        21         1
  [4]        22        22         1
> 
> ## On an IRangesList object:
> promoters(collection, upstream=5, downstream=2)
IRangesList object of length 3:
$one
IRanges object with 3 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]        -4         2         7
  [2]        -3         3         7
  [3]        -2         4         7

[[2]]
IRanges object with 4 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]        10        16         7
  [2]        40        46         7
  [3]        15        21         7
  [4]        -4         2         7

[[3]]
IRanges object with 3 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]        -7        -1         7
  [2]         1         7         7
  [3]         2         8         7

> 
> ## ---------------------------------------------------------------------
> ## reflect()
> ## ---------------------------------------------------------------------
> 
> ## On an IRanges object:
> bounds <- IRanges(c(0, 5, 3), c(10, 6, 9))
> reflect(ir3, bounds)
IRanges object with 3 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         7         8         2
  [2]         4         6         3
  [3]         9        11         3
> 
> ## reflect() does not yet support IRangesList objects!
> 
> ## ---------------------------------------------------------------------
> ## restrict()
> ## ---------------------------------------------------------------------
> 
> ## On an IRanges object:
> restrict(ir1, start=12, end=34)
IRanges object with 5 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]        12        19         8
  [2]        20        24         5
  [3]        25        24         0
  [4]        25        32         8
  [5]        33        34         2
> restrict(ir1, start=20)
IRanges object with 5 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]        20        19         0
  [2]        20        24         5
  [3]        25        24         0
  [4]        25        32         8
  [5]        33        37         5
> restrict(ir1, start=21)
IRanges object with 4 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]        21        24         4
  [2]        25        24         0
  [3]        25        32         8
  [4]        33        37         5
> restrict(ir1, start=21, keep.all.ranges=TRUE)
IRanges object with 5 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]        21        20         0
  [2]        21        24         4
  [3]        25        24         0
  [4]        25        32         8
  [5]        33        37         5
> 
> ## On an IRangesList object:
> restrict(collection, start=2, end=8)
IRangesList object of length 3:
$one
IRanges object with 3 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         2         5         4
  [2]         2         2         1
  [3]         3         8         6

[[2]]
IRanges object with 1 range and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         2         5         4

[[3]]
IRanges object with 3 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         2         5         4
  [2]         6         5         0
  [3]         7         6         0

> restrict(collection, start=2, end=8, keep.all.ranges=TRUE)
IRangesList object of length 3:
$one
IRanges object with 3 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         2         5         4
  [2]         2         2         1
  [3]         3         8         6

[[2]]
IRanges object with 4 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         9         8         0
  [2]         9         8         0
  [3]         9         8         0
  [4]         2         5         4

[[3]]
IRanges object with 3 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         2         5         4
  [2]         6         5         0
  [3]         7         6         0

> 
> ## ---------------------------------------------------------------------
> ## threebands()
> ## ---------------------------------------------------------------------
> 
> ## On an IRanges object:
> z <- threebands(ir2, start=4, end=-2)
> ir2b <- punion(z$left, z$right, fill.gap=TRUE)
> stopifnot(identical(ir2, ir2b))
> threebands(ir2, start=-5)
$left
IRanges object with 4 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         1        14        14
  [2]        20        19         0
  [3]        25        27         3
  [4]        33        32         0

$middle
IRanges object with 4 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]        15        19         5
  [2]        20        24         5
  [3]        28        32         5
  [4]        33        37         5

$right
IRanges object with 4 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]        20        19         0
  [2]        25        24         0
  [3]        33        32         0
  [4]        38        37         0

> 
> ## threebands() does not support IRangesList objects.
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("intra-range-methods", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("multisplit")
> ### * multisplit
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: multisplit
> ### Title: Split elements belonging to multiple groups
> ### Aliases: multisplit
> ### Keywords: manip
> 
> ### ** Examples
> 
> multisplit(1:3, list(letters[1:2], letters[2:3], letters[2:4]))
IntegerList of length 4
[["a"]] 1
[["b"]] 1 2 3
[["c"]] 2 3
[["d"]] 3
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("multisplit", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("nearest-methods")
> ### * nearest-methods
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: nearest-methods
> ### Title: Finding the nearest range/position neighbor
> ### Aliases: nearest-methods class:IntegerRanges_OR_missing
> ###   IntegerRanges_OR_missing-class IntegerRanges_OR_missing nearest
> ###   precede follow distance distanceToNearest selectNearest
> ###   nearest,IntegerRanges,IntegerRanges_OR_missing-method
> ###   precede,IntegerRanges,IntegerRanges_OR_missing-method
> ###   follow,IntegerRanges,IntegerRanges_OR_missing-method
> ###   distance,IntegerRanges,IntegerRanges-method
> ###   distance,Pairs,missing-method
> ###   distanceToNearest,IntegerRanges,IntegerRanges_OR_missing-method
> ### Keywords: utilities
> 
> ### ** Examples
> 
>   ## ------------------------------------------
>   ## precede() and follow()
>   ## ------------------------------------------
>   query <- IRanges(c(1, 3, 9), c(3, 7, 10))
>   subject <- IRanges(c(3, 2, 10), c(3, 13, 12))
>  
>   precede(query, subject)     # c(3L, 3L, NA)
[1]  3  3 NA
>   precede(IRanges(), subject) # integer()
integer(0)
>   precede(query, IRanges())   # rep(NA_integer_, 3)
[1] NA NA NA
>   precede(query)              # c(3L, 3L, NA)
[1]  3  3 NA
>  
>   follow(query, subject)      # c(NA, NA, 1L)
[1] NA NA  1
>   follow(IRanges(), subject)  # integer()
integer(0)
>   follow(query, IRanges())    # rep(NA_integer_, 3)
[1] NA NA NA
>   follow(query)               # c(NA, NA, 2L)
[1] NA NA  2
> 
>   ## ------------------------------------------
>   ## nearest()
>   ## ------------------------------------------
>   query <- IRanges(c(1, 3, 9), c(2, 7, 10))
>   subject <- IRanges(c(3, 5, 12), c(3, 6, 12))
> 
>   nearest(query, subject) # c(1L, 1L, 3L)
[1] 1 1 3
>   nearest(query)          # c(2L, 1L, 2L)
[1] 2 1 2
> 
>   ## ------------------------------------------
>   ## distance()
>   ## ------------------------------------------
>   ## adjacent
>   distance(IRanges(1,5), IRanges(6,10)) # 0L
[1] 0
>   ## overlap
>   distance(IRanges(1,5), IRanges(3,7))  # 0L
[1] 0
>   ## zero-width
>   sapply(-3:3, function(i) distance(shift(IRanges(4,3), i), IRanges(4,3))) 
[1] 3 2 1 0 1 2 3
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("nearest-methods", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("range-squeezers")
> ### * range-squeezers
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: range-squeezers
> ### Title: Squeeze the ranges out of a range-based object
> ### Aliases: range-squeezers ranges rglist rglist,Pairs-method
> ### Keywords: methods
> 
> ### ** Examples
> 
> ## See ?GAlignments in the GenomicAlignments package for examples of
> ## "ranges" and "rglist" methods.
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("range-squeezers", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("read.Mask")
> ### * read.Mask
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: read.Mask
> ### Title: Read a mask from a file
> ### Aliases: read.Mask read.agpMask read.gapMask read.liftMask read.rmMask
> ###   read.trfMask
> ### Keywords: manip
> 
> ### ** Examples
> 
>   ## ---------------------------------------------------------------------
>   ## A. Extract a mask of assembly gaps ("AGAPS" mask) with read.agpMask()
>   ## ---------------------------------------------------------------------
>   ## Note: The hs_b36v3_chrY.agp file was obtained by downloading,
>   ## extracting and renaming the hs_ref_chrY.agp.gz file from
>   ##
>   ##   ftp://ftp.ncbi.nih.gov/genomes/H_sapiens/Assembled_chromosomes/
>   ##     hs_ref_chrY.agp.gz      5 KB  24/03/08  04:33:00 PM
>   ##
>   ## on May 9, 2008.
> 
>   chrY_length <- 57772954
>   file1 <- system.file("extdata", "hs_b36v3_chrY.agp", package="IRanges")
>   mask1 <- read.agpMask(file1, seqname="chrY", mask.width=chrY_length,
+                         use.gap.types=TRUE)
>   mask1
MaskCollection of length 1 and width 57772954
masks:
  maskedwidth maskedratio active names          desc
1    32120000   0.5559695   TRUE AGAPS assembly gaps
>   mask1[[1]]
NormalIRanges object with 14 ranges and 0 metadata columns:
                      start       end     width
                  <integer> <integer> <integer>
           contig     34822     84821     50000
           contig    171385    201384     30000
           contig    967558   1017557     50000
           contig   1054114   1104113     50000
           contig   1184235   1274234     90000
              ...       ...       ...       ...
       centromere  11253955  11653954    400000
       centromere  12208579  12308578    100000
            clone  22310817  22360816     50000
  heterochromatin  27228750  57228749  30000000
            clone  57327045  57377044     50000
> 
>   mask11 <- read.agpMask(file1, seqname="chrY", mask.width=chrY_length,
+                          gap.types=c("centromere", "heterochromatin"))
>   mask11[[1]]
NormalIRanges object with 3 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]  11253955  11653954    400000
  [2]  12208579  12308578    100000
  [3]  27228750  57228749  30000000
> 
>   ## ---------------------------------------------------------------------
>   ## B. Extract a mask of assembly gaps ("AGAPS" mask) with read.liftMask()
>   ## ---------------------------------------------------------------------
>   ## Note: The hg18liftAll.lft file was obtained by downloading,
>   ## extracting and renaming the liftAll.zip file from
>   ##
>   ##   http://hgdownload.cse.ucsc.edu/goldenPath/hg18/bigZips/
>   ##     liftAll.zip             03-Feb-2006 11:35  5.5K
>   ##
>   ## on May 8, 2008.
> 
>   file2 <- system.file("extdata", "hg18liftAll.lft", package="IRanges")
>   mask2 <- read.liftMask(file2, seqname="chr1")
>   mask2
MaskCollection of length 1 and width 247249719
masks:
  maskedwidth maskedratio active names          desc
1    22250000  0.08998999   TRUE AGAPS assembly gaps
>   if (interactive()) {
+       ## contigs 7 and 8 for chrY are adjacent
+       read.liftMask(file2, seqname="chrY")
+ 
+       ## displays the sequence names found in the file
+       read.liftMask(file2)
+ 
+       ## specify an unknown sequence name
+       read.liftMask(file2, seqname="chrZ", mask.width=300)
+   }
> 
>   ## ---------------------------------------------------------------------
>   ## C. Extract a RepeatMasker ("RM") or Tandem Repeats Finder ("TRF")
>   ##    mask with read.rmMask() or read.trfMask()
>   ## ---------------------------------------------------------------------
>   ## Note: The ce2chrM.fa.out and ce2chrM.bed files were obtained by
>   ## downloading, extracting and renaming the chromOut.zip and
>   ## chromTrf.zip files from
>   ##
>   ##   http://hgdownload.cse.ucsc.edu/goldenPath/ce2/bigZips/
>   ##     chromOut.zip            21-Apr-2004 09:05  2.6M
>   ##     chromTrf.zip            21-Apr-2004 09:07  182K
>   ##
>   ## on May 7, 2008.
> 
>   ## Before you can extract a mask with read.rmMask() or read.trfMask(), you
>   ## need to know the length of the sequence that you're going to put the
>   ## mask on:
>   if (interactive()) {
+       library(BSgenome.Celegans.UCSC.ce2)
+       chrM_length <- seqlengths(Celegans)[["chrM"]]
+ 
+       ## Read the RepeatMasker .out file for chrM in ce2:
+       file3 <- system.file("extdata", "ce2chrM.fa.out", package="IRanges")
+       RMmask <- read.rmMask(file3, seqname="chrM", mask.width=chrM_length)
+       RMmask
+ 
+       ## Read the Tandem Repeats Finder .bed file for chrM in ce2:
+       file4 <- system.file("extdata", "ce2chrM.bed", package="IRanges")
+       TRFmask <- read.trfMask(file4, seqname="chrM", mask.width=chrM_length)
+       TRFmask
+       desc(TRFmask) <- paste(desc(TRFmask), "[period<=12]")
+       TRFmask
+ 
+       ## Put the 2 masks on chrM:
+       chrM <- Celegans$chrM
+       masks(chrM) <- RMmask  # this would drop all current masks, if any
+       masks(chrM) <- append(masks(chrM), TRFmask)
+       chrM
+   }
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("read.Mask", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("reverse-methods")
> ### * reverse-methods
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: reverse
> ### Title: reverse
> ### Aliases: reverse reverse,character-method reverse,IRanges-method
> ###   reverse,NormalIRanges-method reverse,Views-method
> ###   reverse,MaskCollection-method
> ### Keywords: methods manip
> 
> ### ** Examples
> 
> ## On a character vector:
> reverse(c("Hi!", "How are you?"))
[1] "!iH"          "?uoy era woH"
> rev(c("Hi!", "How are you?"))
[1] "How are you?" "Hi!"         
> 
> ## On a Views object:
> v <- successiveViews(Rle(c(-0.5, 12.3, 4.88), 4:2), 1:4)
> v
Views on a 9-length Rle subject

views:
    start end width
[1]     1   1     1 [-0.5]
[2]     2   3     2 [-0.5 -0.5]
[3]     4   6     3 [-0.5 12.3 12.3]
[4]     7  10     4 [12.30  4.88  4.88 ...]
> reverse(v)
Views on a 9-length Rle subject

views:
    start end width
[1]     9   9     1 [-0.5]
[2]     7   8     2 [-0.5 -0.5]
[3]     4   6     3 [12.3 12.3 -0.5]
[4]     0   3     4 [ 4.88  4.88 12.30 ...]
> rev(v)
Views on a 9-length Rle subject

views:
    start end width
[1]     7  10     4 [12.30  4.88  4.88 ...]
[2]     4   6     3 [-0.5 12.3 12.3]
[3]     2   3     2 [-0.5 -0.5]
[4]     1   1     1 [-0.5]
> 
> ## On a MaskCollection object:
> mask1 <- Mask(mask.width=29, start=c(11, 25, 28), width=c(5, 2, 2))
> mask2 <- Mask(mask.width=29, start=c(3, 10, 27), width=c(5, 8, 1))
> mask3 <- Mask(mask.width=29, start=c(7, 12), width=c(2, 4))
> mymasks <- append(append(mask1, mask2), mask3)
> reverse(mymasks)
MaskCollection of length 3 and width 29
masks:
  maskedwidth maskedratio active
1           9   0.3103448   TRUE
2          14   0.4827586   TRUE
3           6   0.2068966   TRUE
all masks together:
  maskedwidth maskedratio
           19   0.6551724
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("reverse-methods", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("setops-methods")
> ### * setops-methods
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: setops-methods
> ### Title: Set operations on IntegerRanges and IntegerRangesList objects
> ### Aliases: setops-methods union union,IntegerRanges,IntegerRanges-method
> ###   union,IntegerRangesList,IntegerRangesList-method
> ###   union,CompressedIRangesList,CompressedIRangesList-method
> ###   union,Pairs,missing-method intersect
> ###   intersect,IntegerRanges,IntegerRanges-method
> ###   intersect,IntegerRangesList,IntegerRangesList-method
> ###   intersect,CompressedIRangesList,CompressedIRangesList-method
> ###   intersect,Pairs,missing-method setdiff
> ###   setdiff,IntegerRanges,IntegerRanges-method
> ###   setdiff,IntegerRangesList,IntegerRangesList-method
> ###   setdiff,CompressedIRangesList,CompressedIRangesList-method
> ###   setdiff,Pairs,missing-method punion
> ###   punion,IntegerRanges,IntegerRanges-method punion,Pairs,missing-method
> ###   pintersect pintersect,IntegerRanges,IntegerRanges-method
> ###   pintersect,Pairs,missing-method psetdiff
> ###   psetdiff,IntegerRanges,IntegerRanges-method
> ###   psetdiff,Pairs,missing-method pgap
> ###   pgap,IntegerRanges,IntegerRanges-method
> ### Keywords: utilities
> 
> ### ** Examples
> 
> x <- IRanges(c(1, 5, -2, 0, 14), c(10, 9, 3, 11, 17))
> subject <- Rle(1:-3, 6:2)
> y <- Views(subject, start=c(14, 0, -5, 6, 18), end=c(20, 2, 2, 8, 20))
> 
> ## Vector-wise operations:
> union(x, ranges(y))
IRanges object with 2 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]        -5        11        17
  [2]        14        20         7
> union(ranges(y), x)
IRanges object with 2 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]        -5        11        17
  [2]        14        20         7
> 
> intersect(x, ranges(y))
IRanges object with 3 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]        -2         2         5
  [2]         6         8         3
  [3]        14        17         4
> intersect(ranges(y), x)
IRanges object with 3 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]        -2         2         5
  [2]         6         8         3
  [3]        14        17         4
> 
> setdiff(x, ranges(y))
IRanges object with 2 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         3         5         3
  [2]         9        11         3
> setdiff(ranges(y), x)
IRanges object with 2 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]        -5        -3         3
  [2]        18        20         3
> 
> ## Element-wise (aka "parallel") operations:
> try(punion(x, ranges(y)))
Error in .local(x, y, ...) : 
  some pair of ranges have a gap within the 2 members of the pair.
  Use 'fill.gap=TRUE' to enforce their union by filling the gap.
> punion(x[3:5], ranges(y)[3:5])
IRanges object with 3 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]        -5         3         9
  [2]         0        11        12
  [3]        14        20         7
> punion(x, ranges(y), fill.gap=TRUE)
IRanges object with 5 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         1        20        20
  [2]         0         9        10
  [3]        -5         3         9
  [4]         0        11        12
  [5]        14        20         7
> try(pintersect(x, ranges(y)))
Error in .local(x, y, ...) : 
  some intersections produce ambiguous empty ranges.
  Use argument 'resolve.empty' to resolve them.
> pintersect(x[3:4], ranges(y)[3:4])
IRanges object with 2 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]        -2         2         5
  [2]         6         8         3
> pintersect(x, ranges(y), resolve.empty="max.start")
IRanges object with 5 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]        14        13         0
  [2]         5         4         0
  [3]        -2         2         5
  [4]         6         8         3
  [5]        18        17         0
> psetdiff(ranges(y), x)
IRanges object with 5 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]        14        20         7
  [2]         0         2         3
  [3]        -5        -3         3
  [4]         6         5         0
  [5]        18        20         3
> try(psetdiff(x, ranges(y)))
Error in .local(x, y, ...) : 
  some ranges in 'y' have their end points strictly inside
  the range in 'x' that they need to be subtracted from.
  Cannot subtract them.
> start(x)[4] <- -99
> end(y)[4] <- 99
> psetdiff(x, ranges(y))
IRanges object with 5 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         1        10        10
  [2]         5         9         5
  [3]         3         3         1
  [4]       -99         5       105
  [5]        14        17         4
> pgap(x, ranges(y))
IRanges object with 5 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]        11        13         3
  [2]         3         4         2
  [3]         3         2         0
  [4]        12        11         0
  [5]        18        17         0
> 
> ## On IntegerRangesList objects:
> irl1 <- IRangesList(a=IRanges(c(1,2),c(4,3)), b=IRanges(c(4,6),c(10,7)))
> irl2 <- IRangesList(c=IRanges(c(0,2),c(4,5)), a=IRanges(c(4,5),c(6,7)))
> union(irl1, irl2)
IRangesList object of length 2:
$a
IRanges object with 1 range and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         0         5         6

$b
IRanges object with 1 range and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         4        10         7

> intersect(irl1, irl2)
IRangesList object of length 2:
$a
IRanges object with 1 range and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         1         4         4

$b
IRanges object with 1 range and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         4         7         4

> setdiff(irl1, irl2)
IRangesList object of length 2:
$a
IRanges object with 0 ranges and 0 metadata columns:
       start       end     width
   <integer> <integer> <integer>

$b
IRanges object with 1 range and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         8        10         3

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("setops-methods", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("slice-methods")
> ### * slice-methods
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: slice-methods
> ### Title: Slice a vector-like or list-like object
> ### Aliases: slice-methods slice slice,ANY-method slice,Rle-method
> ###   slice,RleList-method
> ### Keywords: methods
> 
> ### ** Examples
> 
> ## Views derived from coverage
> x <- IRanges(start=c(1L, 9L, 4L, 1L, 5L, 10L),
+              width=c(5L, 6L, 3L, 4L, 3L,  3L))
> cvg <- coverage(x)
> slice(cvg, lower=2)
Views on a 14-length Rle subject

views:
    start end width
[1]     1   6     6 [2 2 2 3 3 2]
[2]    10  12     3 [2 2 2]
> slice(cvg, lower=2, rangesOnly=TRUE)
IRanges object with 2 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         1         6         6
  [2]        10        12         3
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("slice-methods", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("view-summarization-methods")
> ### * view-summarization-methods
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: view-summarization-methods
> ### Title: Summarize views on a vector-like object with numeric values
> ### Aliases: view-summarization-methods viewApply viewApply,Views-method
> ###   viewApply,RleViews-method viewApply,RleViewsList-method viewMins
> ###   viewMins,RleViews-method viewMins,RleViewsList-method viewMaxs
> ###   viewMaxs,RleViews-method viewMaxs,RleViewsList-method viewSums
> ###   viewSums,RleViews-method viewSums,RleViewsList-method viewMeans
> ###   viewMeans,RleViews-method viewMeans,RleViewsList-method viewWhichMins
> ###   viewWhichMins,RleViews-method viewWhichMins,RleViewsList-method
> ###   viewWhichMaxs viewWhichMaxs,RleViews-method
> ###   viewWhichMaxs,RleViewsList-method viewRangeMins
> ###   viewRangeMins,RleViews-method viewRangeMins,RleViewsList-method
> ###   viewRangeMaxs viewRangeMaxs,RleViews-method
> ###   viewRangeMaxs,RleViewsList-method Summary,Views-method
> ###   mean,Views-method max,Views-method min,Views-method sum,Views-method
> ###   which.min,Views-method which.max,Views-method
> ### Keywords: methods arith
> 
> ### ** Examples
> 
> ## Views derived from coverage
> x <- IRanges(start=c(1L, 9L, 4L, 1L, 5L, 10L),
+              width=c(5L, 6L, 3L, 4L, 3L,  3L))
> cvg <- coverage(x)
> cvg_views <- slice(cvg, lower=2)
> 
> viewApply(cvg_views, diff)
[[1]]
integer-Rle of length 5 with 4 runs
  Lengths:  2  1  1  1
  Values :  0  1  0 -1

[[2]]
integer-Rle of length 2 with 1 run
  Lengths: 2
  Values : 0

> 
> viewMins(cvg_views)
[1] 2 2
> viewMaxs(cvg_views)
[1] 3 2
> 
> viewSums(cvg_views)
[1] 14  6
> viewMeans(cvg_views)
[1] 2.333333 2.000000
> 
> viewWhichMins(cvg_views)
[1]  1 10
> viewWhichMaxs(cvg_views)
[1]  4 10
> 
> viewRangeMins(cvg_views)
IRanges object with 2 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         1         3         3
  [2]        10        12         3
> viewRangeMaxs(cvg_views)
IRanges object with 2 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         4         5         2
  [2]        10        12         3
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("view-summarization-methods", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  16.91 0.56 17.48 NA NA 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
