
R version 4.1.0 (2021-05-18) -- "Camp Pontanezen"
Copyright (C) 2021 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "S4Vectors"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> base::assign(".ExTimings", "S4Vectors-Ex.timings", pos = 'CheckExEnv')
> base::cat("name\tuser\tsystem\telapsed\n", file=base::get(".ExTimings", pos = 'CheckExEnv'))
> base::assign(".format_ptime",
+ function(x) {
+   if(!is.na(x[4L])) x[1L] <- x[1L] + x[4L]
+   if(!is.na(x[5L])) x[2L] <- x[2L] + x[5L]
+   options(OutDec = '.')
+   format(x[1L:3L], digits = 7L)
+ },
+ pos = 'CheckExEnv')
> 
> ### * </HEADER>
> library('S4Vectors')
Loading required package: stats4
Loading required package: BiocGenerics
Loading required package: parallel

Attaching package: ‘BiocGenerics’

The following objects are masked from ‘package:parallel’:

    clusterApply, clusterApplyLB, clusterCall, clusterEvalQ,
    clusterExport, clusterMap, parApply, parCapply, parLapply,
    parLapplyLB, parRapply, parSapply, parSapplyLB

The following objects are masked from ‘package:stats’:

    IQR, mad, sd, var, xtabs

The following objects are masked from ‘package:base’:

    Filter, Find, Map, Position, Reduce, anyDuplicated, append,
    as.data.frame, basename, cbind, colnames, dirname, do.call,
    duplicated, eval, evalq, get, grep, grepl, intersect, is.unsorted,
    lapply, mapply, match, mget, order, paste, pmax, pmax.int, pmin,
    pmin.int, rank, rbind, rownames, sapply, setdiff, sort, table,
    tapply, union, unique, unsplit, which.max, which.min


Attaching package: ‘S4Vectors’

The following objects are masked from ‘package:base’:

    I, expand.grid, unname

> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("Annotated-class")
> ### * Annotated-class
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: Annotated-class
> ### Title: Annotated class
> ### Aliases: Annotated Annotated-class metadata metadata,Annotated-method
> ###   metadata<- metadata<-,Annotated-method
> ### Keywords: methods classes
> 
> ### ** Examples
> 
> showClass("Annotated")  # shows (some of) the known subclasses
Virtual Class "Annotated" [package "S4Vectors"]

Slots:
               
Name:  metadata
Class:     list

Known Subclasses: 
Class "Vector", directly
Class "Hits", by class "Vector", distance 2
Class "SelfHits", by class "Hits", distance 3
Class "SortedByQueryHits", by class "Hits", distance 3
Class "SortedByQuerySelfHits", by class "SelfHits", distance 4
Class "Rle", by class "Vector", distance 2
Class "Factor", by class "Vector", distance 2
Class "List", by class "Vector", distance 2
Class "SimpleList", by class "List", distance 3
Class "HitsList", by class "SimpleList", distance 4
Class "SelfHitsList", by class "HitsList", distance 5
Class "SortedByQueryHitsList", by class "HitsList", distance 5
Class "SortedByQuerySelfHitsList", by class "SelfHitsList", distance 6
Class "DataFrame", by class "SimpleList", distance 4
Class "DFrame", by class "DataFrame", distance 5
Class "TransposedDataFrame", by class "List", distance 3
Class "Pairs", by class "Vector", distance 2
Class "FilterRules", by class "SimpleList", distance 4
> 
> ## If the IRanges package was not already loaded, this will show
> ## more subclasses:
> library(IRanges)
> showClass("Annotated")
Virtual Class "Annotated" [package "S4Vectors"]

Slots:
               
Name:  metadata
Class:     list

Known Subclasses: 
Class "Vector", directly
Class "Hits", by class "Vector", distance 2
Class "SelfHits", by class "Hits", distance 3
Class "SortedByQueryHits", by class "Hits", distance 3
Class "SortedByQuerySelfHits", by class "SelfHits", distance 4
Class "Rle", by class "Vector", distance 2
Class "Factor", by class "Vector", distance 2
Class "List", by class "Vector", distance 2
Class "SimpleList", by class "List", distance 3
Class "HitsList", by class "SimpleList", distance 4
Class "SelfHitsList", by class "HitsList", distance 5
Class "SortedByQueryHitsList", by class "HitsList", distance 5
Class "SortedByQuerySelfHitsList", by class "SelfHitsList", distance 6
Class "DataFrame", by class "SimpleList", distance 4
Class "DFrame", by class "DataFrame", distance 5
Class "TransposedDataFrame", by class "List", distance 3
Class "Pairs", by class "Vector", distance 2
Class "FilterRules", by class "SimpleList", distance 4
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("Annotated-class", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:IRanges’

> nameEx("DataFrame-class")
> ### * DataFrame-class
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: DataFrame-class
> ### Title: DataFrame objects
> ### Aliases: class:DataFrame DataFrame-class class:DFrame DFrame-class
> ###   DFrame vertical_slot_names,DataFrame-method
> ###   horizontal_slot_names,DataFrame-method updateObject,DataFrame-method
> ###   nrow,DataFrame-method ncol,DataFrame-method dim,DataFrame-method
> ###   rownames,DataFrame-method colnames,DataFrame-method
> ###   dimnames,DataFrame-method rownames<-,DataFrame-method
> ###   colnames<-,DataFrame-method dimnames<-,DataFrame-method DataFrame
> ###   make_zero_col_DFrame [,DataFrame-method
> ###   replaceROWS,DataFrame,ANY-method mergeROWS,DataFrame,ANY-method
> ###   [<-,DataFrame-method [[<-,DataFrame-method [[,DataFrame-method
> ###   as.data.frame,DataFrame-method as.matrix,DataFrame-method
> ###   coerce,list,DFrame-method coerce,Vector,DFrame-method
> ###   coerce,data.frame,DFrame-method coerce,data.table,DFrame-method
> ###   coerce,NULL,DFrame-method coerce,table,DFrame-method
> ###   coerce,AsIs,DFrame-method coerce,xtabs,DFrame-method
> ###   coerce,ANY,DFrame-method coerce,ANY,DataFrame-method
> ###   coerce,SimpleList,DataFrame-method coerce,DFrame,DataFrame-method
> ###   coerce,SimpleList,DFrame-method classNameForDisplay,DFrame-method
> ###   makeNakedCharacterMatrixForDisplay,DataFrame-method
> ###   show,DataFrame-method showAsCell,DataFrame-method
> ### Keywords: classes methods
> 
> ### ** Examples
> 
> score <- c(1L, 3L, NA)
> counts <- c(10L, 2L, NA)
> row.names <- c("one", "two", "three")
>   
> df <- DataFrame(score) # single column
> df[["score"]]
[1]  1  3 NA
> df <- DataFrame(score, row.names = row.names) #with row names
> rownames(df)
[1] "one"   "two"   "three"
>   
> df <- DataFrame(vals = score) # explicit naming
> df[["vals"]]
[1]  1  3 NA
> 
> # arrays
> ary <- array(1:4, c(2,1,2))
> sw <- DataFrame(I(ary))  
>   
> # a data.frame
> sw <- DataFrame(swiss)
> as.data.frame(sw) # swiss, without row names
             Fertility Agriculture Examination Education Catholic
Courtelary        80.2        17.0          15        12     9.96
Delemont          83.1        45.1           6         9    84.84
Franches-Mnt      92.5        39.7           5         5    93.40
Moutier           85.8        36.5          12         7    33.77
Neuveville        76.9        43.5          17        15     5.16
Porrentruy        76.1        35.3           9         7    90.57
Broye             83.8        70.2          16         7    92.85
Glane             92.4        67.8          14         8    97.16
Gruyere           82.4        53.3          12         7    97.67
Sarine            82.9        45.2          16        13    91.38
Veveyse           87.1        64.5          14         6    98.61
Aigle             64.1        62.0          21        12     8.52
Aubonne           66.9        67.5          14         7     2.27
Avenches          68.9        60.7          19        12     4.43
Cossonay          61.7        69.3          22         5     2.82
Echallens         68.3        72.6          18         2    24.20
Grandson          71.7        34.0          17         8     3.30
Lausanne          55.7        19.4          26        28    12.11
La Vallee         54.3        15.2          31        20     2.15
Lavaux            65.1        73.0          19         9     2.84
Morges            65.5        59.8          22        10     5.23
Moudon            65.0        55.1          14         3     4.52
Nyone             56.6        50.9          22        12    15.14
Orbe              57.4        54.1          20         6     4.20
Oron              72.5        71.2          12         1     2.40
Payerne           74.2        58.1          14         8     5.23
Paysd'enhaut      72.0        63.5           6         3     2.56
Rolle             60.5        60.8          16        10     7.72
Vevey             58.3        26.8          25        19    18.46
Yverdon           65.4        49.5          15         8     6.10
Conthey           75.5        85.9           3         2    99.71
Entremont         69.3        84.9           7         6    99.68
Herens            77.3        89.7           5         2   100.00
Martigwy          70.5        78.2          12         6    98.96
Monthey           79.4        64.9           7         3    98.22
St Maurice        65.0        75.9           9         9    99.06
Sierre            92.2        84.6           3         3    99.46
Sion              79.3        63.1          13        13    96.83
Boudry            70.4        38.4          26        12     5.62
La Chauxdfnd      65.7         7.7          29        11    13.79
Le Locle          72.7        16.7          22        13    11.22
Neuchatel         64.4        17.6          35        32    16.92
Val de Ruz        77.6        37.6          15         7     4.97
ValdeTravers      67.6        18.7          25         7     8.65
V. De Geneve      35.0         1.2          37        53    42.34
Rive Droite       44.7        46.6          16        29    50.43
Rive Gauche       42.8        27.7          22        29    58.33
             Infant.Mortality
Courtelary               22.2
Delemont                 22.2
Franches-Mnt             20.2
Moutier                  20.3
Neuveville               20.6
Porrentruy               26.6
Broye                    23.6
Glane                    24.9
Gruyere                  21.0
Sarine                   24.4
Veveyse                  24.5
Aigle                    16.5
Aubonne                  19.1
Avenches                 22.7
Cossonay                 18.7
Echallens                21.2
Grandson                 20.0
Lausanne                 20.2
La Vallee                10.8
Lavaux                   20.0
Morges                   18.0
Moudon                   22.4
Nyone                    16.7
Orbe                     15.3
Oron                     21.0
Payerne                  23.8
Paysd'enhaut             18.0
Rolle                    16.3
Vevey                    20.9
Yverdon                  22.5
Conthey                  15.1
Entremont                19.8
Herens                   18.3
Martigwy                 19.4
Monthey                  20.2
St Maurice               17.8
Sierre                   16.3
Sion                     18.1
Boudry                   20.3
La Chauxdfnd             20.5
Le Locle                 18.9
Neuchatel                23.0
Val de Ruz               20.0
ValdeTravers             19.5
V. De Geneve             18.0
Rive Droite              18.2
Rive Gauche              19.3
> # now with row names
> sw <- DataFrame(swiss, row.names = rownames(swiss))
> as.data.frame(sw) # swiss
             Fertility Agriculture Examination Education Catholic
Courtelary        80.2        17.0          15        12     9.96
Delemont          83.1        45.1           6         9    84.84
Franches-Mnt      92.5        39.7           5         5    93.40
Moutier           85.8        36.5          12         7    33.77
Neuveville        76.9        43.5          17        15     5.16
Porrentruy        76.1        35.3           9         7    90.57
Broye             83.8        70.2          16         7    92.85
Glane             92.4        67.8          14         8    97.16
Gruyere           82.4        53.3          12         7    97.67
Sarine            82.9        45.2          16        13    91.38
Veveyse           87.1        64.5          14         6    98.61
Aigle             64.1        62.0          21        12     8.52
Aubonne           66.9        67.5          14         7     2.27
Avenches          68.9        60.7          19        12     4.43
Cossonay          61.7        69.3          22         5     2.82
Echallens         68.3        72.6          18         2    24.20
Grandson          71.7        34.0          17         8     3.30
Lausanne          55.7        19.4          26        28    12.11
La Vallee         54.3        15.2          31        20     2.15
Lavaux            65.1        73.0          19         9     2.84
Morges            65.5        59.8          22        10     5.23
Moudon            65.0        55.1          14         3     4.52
Nyone             56.6        50.9          22        12    15.14
Orbe              57.4        54.1          20         6     4.20
Oron              72.5        71.2          12         1     2.40
Payerne           74.2        58.1          14         8     5.23
Paysd'enhaut      72.0        63.5           6         3     2.56
Rolle             60.5        60.8          16        10     7.72
Vevey             58.3        26.8          25        19    18.46
Yverdon           65.4        49.5          15         8     6.10
Conthey           75.5        85.9           3         2    99.71
Entremont         69.3        84.9           7         6    99.68
Herens            77.3        89.7           5         2   100.00
Martigwy          70.5        78.2          12         6    98.96
Monthey           79.4        64.9           7         3    98.22
St Maurice        65.0        75.9           9         9    99.06
Sierre            92.2        84.6           3         3    99.46
Sion              79.3        63.1          13        13    96.83
Boudry            70.4        38.4          26        12     5.62
La Chauxdfnd      65.7         7.7          29        11    13.79
Le Locle          72.7        16.7          22        13    11.22
Neuchatel         64.4        17.6          35        32    16.92
Val de Ruz        77.6        37.6          15         7     4.97
ValdeTravers      67.6        18.7          25         7     8.65
V. De Geneve      35.0         1.2          37        53    42.34
Rive Droite       44.7        46.6          16        29    50.43
Rive Gauche       42.8        27.7          22        29    58.33
             Infant.Mortality
Courtelary               22.2
Delemont                 22.2
Franches-Mnt             20.2
Moutier                  20.3
Neuveville               20.6
Porrentruy               26.6
Broye                    23.6
Glane                    24.9
Gruyere                  21.0
Sarine                   24.4
Veveyse                  24.5
Aigle                    16.5
Aubonne                  19.1
Avenches                 22.7
Cossonay                 18.7
Echallens                21.2
Grandson                 20.0
Lausanne                 20.2
La Vallee                10.8
Lavaux                   20.0
Morges                   18.0
Moudon                   22.4
Nyone                    16.7
Orbe                     15.3
Oron                     21.0
Payerne                  23.8
Paysd'enhaut             18.0
Rolle                    16.3
Vevey                    20.9
Yverdon                  22.5
Conthey                  15.1
Entremont                19.8
Herens                   18.3
Martigwy                 19.4
Monthey                  20.2
St Maurice               17.8
Sierre                   16.3
Sion                     18.1
Boudry                   20.3
La Chauxdfnd             20.5
Le Locle                 18.9
Neuchatel                23.0
Val de Ruz               20.0
ValdeTravers             19.5
V. De Geneve             18.0
Rive Droite              18.2
Rive Gauche              19.3
> 
> # subsetting
>     
> sw[] # identity subset
DataFrame with 47 rows and 6 columns
             Fertility Agriculture Examination Education  Catholic
             <numeric>   <numeric>   <integer> <integer> <numeric>
Courtelary        80.2        17.0          15        12      9.96
Delemont          83.1        45.1           6         9     84.84
Franches-Mnt      92.5        39.7           5         5     93.40
Moutier           85.8        36.5          12         7     33.77
Neuveville        76.9        43.5          17        15      5.16
...                ...         ...         ...       ...       ...
Val de Ruz        77.6        37.6          15         7      4.97
ValdeTravers      67.6        18.7          25         7      8.65
V. De Geneve      35.0         1.2          37        53     42.34
Rive Droite       44.7        46.6          16        29     50.43
Rive Gauche       42.8        27.7          22        29     58.33
             Infant.Mortality
                    <numeric>
Courtelary               22.2
Delemont                 22.2
Franches-Mnt             20.2
Moutier                  20.3
Neuveville               20.6
...                       ...
Val de Ruz               20.0
ValdeTravers             19.5
V. De Geneve             18.0
Rive Droite              18.2
Rive Gauche              19.3
> sw[,] # same
DataFrame with 47 rows and 6 columns
             Fertility Agriculture Examination Education  Catholic
             <numeric>   <numeric>   <integer> <integer> <numeric>
Courtelary        80.2        17.0          15        12      9.96
Delemont          83.1        45.1           6         9     84.84
Franches-Mnt      92.5        39.7           5         5     93.40
Moutier           85.8        36.5          12         7     33.77
Neuveville        76.9        43.5          17        15      5.16
...                ...         ...         ...       ...       ...
Val de Ruz        77.6        37.6          15         7      4.97
ValdeTravers      67.6        18.7          25         7      8.65
V. De Geneve      35.0         1.2          37        53     42.34
Rive Droite       44.7        46.6          16        29     50.43
Rive Gauche       42.8        27.7          22        29     58.33
             Infant.Mortality
                    <numeric>
Courtelary               22.2
Delemont                 22.2
Franches-Mnt             20.2
Moutier                  20.3
Neuveville               20.6
...                       ...
Val de Ruz               20.0
ValdeTravers             19.5
V. De Geneve             18.0
Rive Droite              18.2
Rive Gauche              19.3
> 
> sw[NULL] # no columns
DataFrame with 47 rows and 0 columns
> sw[,NULL] # no columns
DataFrame with 47 rows and 0 columns
> sw[NULL,] # no rows
DataFrame with 0 rows and 6 columns
> 
> ## select columns
> sw[1:3]
DataFrame with 47 rows and 3 columns
             Fertility Agriculture Examination
             <numeric>   <numeric>   <integer>
Courtelary        80.2        17.0          15
Delemont          83.1        45.1           6
Franches-Mnt      92.5        39.7           5
Moutier           85.8        36.5          12
Neuveville        76.9        43.5          17
...                ...         ...         ...
Val de Ruz        77.6        37.6          15
ValdeTravers      67.6        18.7          25
V. De Geneve      35.0         1.2          37
Rive Droite       44.7        46.6          16
Rive Gauche       42.8        27.7          22
> sw[,1:3] # same as above
DataFrame with 47 rows and 3 columns
             Fertility Agriculture Examination
             <numeric>   <numeric>   <integer>
Courtelary        80.2        17.0          15
Delemont          83.1        45.1           6
Franches-Mnt      92.5        39.7           5
Moutier           85.8        36.5          12
Neuveville        76.9        43.5          17
...                ...         ...         ...
Val de Ruz        77.6        37.6          15
ValdeTravers      67.6        18.7          25
V. De Geneve      35.0         1.2          37
Rive Droite       44.7        46.6          16
Rive Gauche       42.8        27.7          22
> sw[,"Fertility"]
 [1] 80.2 83.1 92.5 85.8 76.9 76.1 83.8 92.4 82.4 82.9 87.1 64.1 66.9 68.9 61.7
[16] 68.3 71.7 55.7 54.3 65.1 65.5 65.0 56.6 57.4 72.5 74.2 72.0 60.5 58.3 65.4
[31] 75.5 69.3 77.3 70.5 79.4 65.0 92.2 79.3 70.4 65.7 72.7 64.4 77.6 67.6 35.0
[46] 44.7 42.8
> sw[,c(TRUE, FALSE, FALSE, FALSE, FALSE, FALSE)]
 [1] 80.2 83.1 92.5 85.8 76.9 76.1 83.8 92.4 82.4 82.9 87.1 64.1 66.9 68.9 61.7
[16] 68.3 71.7 55.7 54.3 65.1 65.5 65.0 56.6 57.4 72.5 74.2 72.0 60.5 58.3 65.4
[31] 75.5 69.3 77.3 70.5 79.4 65.0 92.2 79.3 70.4 65.7 72.7 64.4 77.6 67.6 35.0
[46] 44.7 42.8
> 
> ## select rows and columns
> sw[4:5, 1:3]
DataFrame with 2 rows and 3 columns
           Fertility Agriculture Examination
           <numeric>   <numeric>   <integer>
Moutier         85.8        36.5          12
Neuveville      76.9        43.5          17
>   
> sw[1] # one-column DataFrame
DataFrame with 47 rows and 1 column
             Fertility
             <numeric>
Courtelary        80.2
Delemont          83.1
Franches-Mnt      92.5
Moutier           85.8
Neuveville        76.9
...                ...
Val de Ruz        77.6
ValdeTravers      67.6
V. De Geneve      35.0
Rive Droite       44.7
Rive Gauche       42.8
> ## the same
> sw[, 1, drop = FALSE]
DataFrame with 47 rows and 1 column
             Fertility
             <numeric>
Courtelary        80.2
Delemont          83.1
Franches-Mnt      92.5
Moutier           85.8
Neuveville        76.9
...                ...
Val de Ruz        77.6
ValdeTravers      67.6
V. De Geneve      35.0
Rive Droite       44.7
Rive Gauche       42.8
> sw[, 1] # a (unnamed) vector
 [1] 80.2 83.1 92.5 85.8 76.9 76.1 83.8 92.4 82.4 82.9 87.1 64.1 66.9 68.9 61.7
[16] 68.3 71.7 55.7 54.3 65.1 65.5 65.0 56.6 57.4 72.5 74.2 72.0 60.5 58.3 65.4
[31] 75.5 69.3 77.3 70.5 79.4 65.0 92.2 79.3 70.4 65.7 72.7 64.4 77.6 67.6 35.0
[46] 44.7 42.8
> sw[[1]] # the same
 [1] 80.2 83.1 92.5 85.8 76.9 76.1 83.8 92.4 82.4 82.9 87.1 64.1 66.9 68.9 61.7
[16] 68.3 71.7 55.7 54.3 65.1 65.5 65.0 56.6 57.4 72.5 74.2 72.0 60.5 58.3 65.4
[31] 75.5 69.3 77.3 70.5 79.4 65.0 92.2 79.3 70.4 65.7 72.7 64.4 77.6 67.6 35.0
[46] 44.7 42.8
> sw[["Fertility"]]
 [1] 80.2 83.1 92.5 85.8 76.9 76.1 83.8 92.4 82.4 82.9 87.1 64.1 66.9 68.9 61.7
[16] 68.3 71.7 55.7 54.3 65.1 65.5 65.0 56.6 57.4 72.5 74.2 72.0 60.5 58.3 65.4
[31] 75.5 69.3 77.3 70.5 79.4 65.0 92.2 79.3 70.4 65.7 72.7 64.4 77.6 67.6 35.0
[46] 44.7 42.8
> 
> sw[["Fert"]] # should return 'NULL'
NULL
>  
> sw[1,] # a one-row DataFrame
DataFrame with 1 row and 6 columns
           Fertility Agriculture Examination Education  Catholic
           <numeric>   <numeric>   <integer> <integer> <numeric>
Courtelary      80.2          17          15        12      9.96
           Infant.Mortality
                  <numeric>
Courtelary             22.2
> sw[1,, drop=TRUE] # a list
$Fertility
[1] 80.2

$Agriculture
[1] 17

$Examination
[1] 15

$Education
[1] 12

$Catholic
[1] 9.96

$Infant.Mortality
[1] 22.2

> 
> ## duplicate row, unique row names are created
> sw[c(1, 1:2),]
DataFrame with 3 rows and 6 columns
           Fertility Agriculture Examination Education  Catholic
           <numeric>   <numeric>   <integer> <integer> <numeric>
Courtelary      80.2        17.0          15        12      9.96
Courtelary      80.2        17.0          15        12      9.96
Delemont        83.1        45.1           6         9     84.84
           Infant.Mortality
                  <numeric>
Courtelary             22.2
Courtelary             22.2
Delemont               22.2
> 
> ## indexing by row names  
> sw["Courtelary",]
DataFrame with 1 row and 6 columns
           Fertility Agriculture Examination Education  Catholic
           <numeric>   <numeric>   <integer> <integer> <numeric>
Courtelary      80.2          17          15        12      9.96
           Infant.Mortality
                  <numeric>
Courtelary             22.2
> subsw <- sw[1:5,1:4]
> subsw["C",] # partially matches
DataFrame with 1 row and 4 columns
           Fertility Agriculture Examination Education
           <numeric>   <numeric>   <integer> <integer>
Courtelary      80.2          17          15        12
> 
> ## row and column names
> cn <- paste("X", seq_len(ncol(swiss)), sep = ".")
> colnames(sw) <- cn
> colnames(sw)
[1] "X.1" "X.2" "X.3" "X.4" "X.5" "X.6"
> rn <- seq(nrow(sw))
> rownames(sw) <- rn
> rownames(sw)
 [1] "1"  "2"  "3"  "4"  "5"  "6"  "7"  "8"  "9"  "10" "11" "12" "13" "14" "15"
[16] "16" "17" "18" "19" "20" "21" "22" "23" "24" "25" "26" "27" "28" "29" "30"
[31] "31" "32" "33" "34" "35" "36" "37" "38" "39" "40" "41" "42" "43" "44" "45"
[46] "46" "47"
> 
> ## column replacement
> 
> df[["counts"]] <- counts
> df[["counts"]]
[1] 10  2 NA
> df[[3]] <- score
> df[["X"]]
NULL
> df[[3]] <- NULL # deletion
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("DataFrame-class", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("DataFrame-combine")
> ### * DataFrame-combine
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: DataFrame-combine
> ### Title: Combine DataFrame objects along their rows or columns, or merge
> ###   them
> ### Aliases: DataFrame-combine bindROWS,DataFrame-method c,DataFrame-method
> ###   cbind.DataFrame cbind,DataFrame-method combineRows,DataFrame-method
> ###   combineCols,DataFrame-method merge,DataFrame,DataFrame-method
> ###   merge,data.frame,DataFrame-method merge,DataFrame,data.frame-method
> ### Keywords: utilities methods
> 
> ### ** Examples
> 
> ## ---------------------------------------------------------------------
> ## rbind()
> ## ---------------------------------------------------------------------
> 
> x1 <- DataFrame(A=1:5, B=letters[1:5], C=11:15)
> y1 <- DataFrame(B=c(FALSE, NA, TRUE), C=c(FALSE, NA, TRUE), A=101:103)
> rbind(x1, y1)
DataFrame with 8 rows and 3 columns
          A           B         C
  <integer> <character> <integer>
1         1           a        11
2         2           b        12
3         3           c        13
4         4           d        14
5         5           e        15
6       101       FALSE         0
7       102          NA        NA
8       103        TRUE         1
> 
> x2 <- DataFrame(A=Rle(101:103, 3:1), B=Rle(51:52, c(1, 5)))
> y2 <- DataFrame(A=runif(2), B=Rle(c("a", "b")))
> rbind(x2, y2)
DataFrame with 8 rows and 2 columns
           A     B
   <numeric> <Rle>
1 101.000000    51
2 101.000000    52
3 101.000000    52
4 102.000000    52
5 102.000000    52
6 103.000000    52
7   0.265509     a
8   0.372124     b
> 
> ## ---------------------------------------------------------------------
> ## combineRows()
> ## ---------------------------------------------------------------------
> 
> y3 <- DataFrame(A=runif(2))
> combineRows(x2, y3)
DataFrame with 8 rows and 2 columns
           A     B
   <numeric> <Rle>
1 101.000000    51
2 101.000000    52
3 101.000000    52
4 102.000000    52
5 102.000000    52
6 103.000000    52
7   0.572853    NA
8   0.908208    NA
> 
> y4 <- DataFrame(B=Rle(c("a", "b")), C=runif(2))
> combineRows(x2, y4)
DataFrame with 8 rows and 3 columns
      A     B         C
  <Rle> <Rle> <numeric>
1   101    51        NA
2   101    52        NA
3   101    52        NA
4   102    52        NA
5   102    52        NA
6   103    52        NA
7    NA     a  0.201682
8    NA     b  0.898390
> combineRows(y4, x2)
DataFrame with 8 rows and 3 columns
      B         C     A
  <Rle> <numeric> <Rle>
1     a  0.201682    NA
2     b  0.898390    NA
3    51        NA   101
4    52        NA   101
5    52        NA   101
6    52        NA   102
7    52        NA   102
8    52        NA   103
> combineRows(y4, x2, DataFrame(D=letters[1:3], B=301:303))
DataFrame with 11 rows and 4 columns
             B         C     A           D
   <character> <numeric> <Rle> <character>
1            a  0.201682    NA          NA
2            b  0.898390    NA          NA
3           51        NA   101          NA
4           52        NA   101          NA
5           52        NA   101          NA
6           52        NA   102          NA
7           52        NA   102          NA
8           52        NA   103          NA
9          301        NA    NA           a
10         302        NA    NA           b
11         303        NA    NA           c
> 
> ## ---------------------------------------------------------------------
> ## combineCols()
> ## ---------------------------------------------------------------------
> 
> X <- DataFrame(x=1)
> Y <- DataFrame(y="A")
> Z <- DataFrame(z=TRUE)
> 
> combineCols(X, Y, Z, use.names=FALSE)
DataFrame with 1 row and 3 columns
          x           y         z
  <numeric> <character> <logical>
1         1           A      TRUE
> 
> Y <- DataFrame(y=LETTERS[1:2])
> rownames(X) <- "foo"
> rownames(Y) <- c("foo", "bar")
> rownames(Z) <- "bar"
> 
> combineCols(X, Y, Z)
DataFrame with 2 rows and 3 columns
            x           y         z
    <numeric> <character> <logical>
foo         1           A        NA
bar        NA           B      TRUE
> 
> ## ---------------------------------------------------------------------
> ## combineUniqueCols()
> ## ---------------------------------------------------------------------
> 
> X <- DataFrame(x=1)
> Y <- DataFrame(y=LETTERS[1:2], dup=1:2)
> Z <- DataFrame(z=TRUE, dup=2L)
> 
> rownames(X) <- "foo"
> rownames(Y) <- c("foo", "bar")
> rownames(Z) <- "bar"
> 
> combineUniqueCols(X, Y, Z)
DataFrame with 2 rows and 4 columns
            x           y       dup         z
    <numeric> <character> <integer> <logical>
foo         1           A         1        NA
bar        NA           B         2      TRUE
> 
> Z$dup <- 3
> combineUniqueCols(X, Y, Z)
Warning in combineUniqueCols(X, Y, Z) :
  different values for shared rows in multiple instances of column 'dup',
  ignoring this column in DFrame 3
DataFrame with 2 rows and 4 columns
            x           y       dup         z
    <numeric> <character> <integer> <logical>
foo         1           A         1        NA
bar        NA           B         2      TRUE
> 
> ## ---------------------------------------------------------------------
> ## merge()
> ## ---------------------------------------------------------------------
> 
> x6 <- DataFrame(key=c(155, 2, 33, 17, 2, 26, 1), aa=1:7)
> y6 <- DataFrame(key=1:26, bb=LETTERS)
> merge(x6, y6, by="key")
DataFrame with 5 rows and 3 columns
        key        aa          bb
  <numeric> <integer> <character>
1         1         7           A
2         2         2           B
3         2         5           B
4        17         4           Q
5        26         6           Z
> merge(x6, y6, by="key", all.x=TRUE)
DataFrame with 7 rows and 3 columns
        key        aa          bb
  <numeric> <integer> <character>
1         1         7           A
2         2         2           B
3         2         5           B
4        17         4           Q
5        26         6           Z
6        33         3          NA
7       155         1          NA
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("DataFrame-combine", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("DataFrame-comparison")
> ### * DataFrame-comparison
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: DataFrame-comparison
> ### Title: DataFrame comparison methods
> ### Aliases: sameAsPreviousROW,DataFrame-method
> ###   match,DataFrame,DataFrame-method duplicated.DataFrame
> ###   duplicated,DataFrame-method unique.DataFrame unique,DataFrame-method
> ###   order,DataFrame-method sort.DataFrame sort,DataFrame-method
> ###   pcompare,DataFrame,DataFrame-method ==,DataFrame,DataFrame-method
> ###   <=,DataFrame,DataFrame-method
> ### Keywords: methods
> 
> ### ** Examples
> 
> # Mocking up a DataFrame.
> DF <- DataFrame(
+     A=sample(LETTERS, 100, replace=TRUE),
+     B=sample(5, 100, replace=TRUE)
+ )
> 
> # Matching:
> match(DF, DF[1:10,])
  [1]  1  2  3  4  5  6  7  8  9 10 NA NA NA NA NA  8 NA NA NA NA NA NA NA NA NA
 [26] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA
 [51]  1  6 NA NA NA NA NA NA NA NA NA  5 NA NA NA NA NA  4 NA NA NA NA NA NA NA
 [76] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA  4 NA NA NA NA NA NA
> selfmatch(DF)
  [1]  1  2  3  4  5  6  7  8  9 10 11 12 12 14 15  8 14 18 19 20 21 22 23 24 25
 [26] 26 22 28 29 30 31 20 33 34 35 36 37 37 39 40 34 42 43 31 24 46 39 48 49 50
 [51]  1  6 53 54 55 56 57 14 59 53 61  5 63 64 15 25 36  4 69 70 49 54 73 74 75
 [76] 76 77 78 79 80 81 82 30 84 30 73 87 88 56 90 91 50 93  4 95 96 39 79 99 18
> unique(DF)
DataFrame with 70 rows and 2 columns
              A         B
    <character> <integer>
1             Y         3
2             D         2
3             G         2
4             A         3
5             B         2
...         ...       ...
66            V         4
67            P         1
68            M         4
69            U         5
70            I         1
> 
> # Ordering, alone and with other vectors:
> sort(DF)
DataFrame with 100 rows and 2 columns
              A         B
    <character> <integer>
1             A         1
2             A         3
3             A         3
4             A         3
5             A         5
...         ...       ...
96            Y         4
97            Y         4
98            Y         4
99            Z         2
100           Z         4
> order(DF, runif(nrow(DF)))
  [1]  11  94  68   4  33   5  62  28  35   2  80  22  27  26  54  72  75  36
 [19]  67  97  47  39  59  56  89   3  77 100  18  76  71  49  82  99  23  19
 [37]  17  14  58  38  37  29   7  78  31  44  74  92  50  90  63  95  81  87
 [55]  61  25  66   8  16  40  20  32  93  84  98  79  64   9  10  69  57  70
 [73]  34  41  88  42  12  13  21  96  65  15  91  73  86  46   6  52  53  60
 [91]  48  45  24  51   1  30  85  83  43  55
> 
> # Parallel comparison:
> DF==DF
  [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
 [16] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
 [31] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
 [46] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
 [61] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
 [76] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
 [91] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
> DF==DF[1,]
  [1]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
 [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
 [25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
 [37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
 [49] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
 [61] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
 [73] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
 [85] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
 [97] FALSE FALSE FALSE FALSE
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("DataFrame-comparison", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("DataFrame-utils")
> ### * DataFrame-utils
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: DataFrame-utils
> ### Title: Common operations on DataFrame objects
> ### Aliases: DataFrame-utils relistToClass,DataFrame-method
> ###   relistToClass,data.frame-method na.omit,DataFrame-method
> ###   na.exclude,DataFrame-method is.na,DataFrame-method
> ###   complete.cases,DataFrame-method transform.DataFrame
> ###   transform,DataFrame-method xtabs,DataFrame-method
> ### Keywords: utilities methods
> 
> ### ** Examples
> 
> ## split
> sw <- DataFrame(swiss)
> swsplit <- split(sw, sw[["Education"]])
> 
> ## rbind & cbind
> do.call(rbind, as.list(swsplit))
DataFrame with 47 rows and 6 columns
             Fertility Agriculture Examination Education  Catholic
             <numeric>   <numeric>   <integer> <integer> <numeric>
Oron              72.5        71.2          12         1      2.40
Echallens         68.3        72.6          18         2     24.20
Conthey           75.5        85.9           3         2     99.71
Herens            77.3        89.7           5         2    100.00
Moudon            65.0        55.1          14         3      4.52
...                ...         ...         ...       ...       ...
Lausanne          55.7        19.4          26        28     12.11
Rive Droite       44.7        46.6          16        29     50.43
Rive Gauche       42.8        27.7          22        29     58.33
Neuchatel         64.4        17.6          35        32     16.92
V. De Geneve      35.0         1.2          37        53     42.34
             Infant.Mortality
                    <numeric>
Oron                     21.0
Echallens                21.2
Conthey                  15.1
Herens                   18.3
Moudon                   22.4
...                       ...
Lausanne                 20.2
Rive Droite              18.2
Rive Gauche              19.3
Neuchatel                23.0
V. De Geneve             18.0
> cbind(DataFrame(score), DataFrame(counts))
DataFrame with 1 row and 2 columns
              score            counts
  <standardGeneric> <standardGeneric>
1 <standardGeneric> <standardGeneric>
> 
> df <- DataFrame(as.data.frame(UCBAdmissions))
> xtabs(Freq ~ Gender + Admit, df)
        Admit
Gender   Admitted Rejected
  Male       1198     1493
  Female      557     1278
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("DataFrame-utils", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("Factor-class")
> ### * Factor-class
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: Factor-class
> ### Title: Factor objects
> ### Aliases: class:Factor Factor-class Factor
> ###   parallel_slot_names,Factor-method FactorToClass
> ###   FactorToClass,vector_OR_Vector-method names,Factor-method
> ###   names<-,Factor-method levels levels<- levels<-,Factor-method nlevels
> ###   nlevels,Factor-method unfactor unfactor,factor-method
> ###   unfactor,Factor-method coerce,vector_OR_Vector,Factor-method
> ###   coerce,factor,Factor-method as.integer,Factor-method
> ###   as.factor,Factor-method as.character,Factor-method show,Factor-method
> ###   showAsCell,Factor-method bindROWS,Factor-method
> ###   pcompare,Factor,Factor-method match,Factor,Factor-method
> ###   selfmatch,Factor-method xtfrm,Factor-method
> ### Keywords: methods classes
> 
> ### ** Examples
> 
> showClass("Factor")  # Factor extends Vector
Class "Factor" [package "S4Vectors"]

Slots:
                                                                              
Name:             levels             index   elementMetadata          metadata
Class:  vector_OR_Vector           integer DataFrame_OR_NULL              list

Extends: 
Class "Vector", directly
Class "Annotated", by class "Vector", distance 2
Class "vector_OR_Vector", by class "Vector", distance 2
> 
> ## ---------------------------------------------------------------------
> ## CONSTRUCTOR & ACCESSORS
> ## ---------------------------------------------------------------------
> library(IRanges)
> set.seed(123)
> ir0 <- IRanges(sample(5, 8, replace=TRUE), width=10,
+                names=letters[1:8], ID=paste0("ID", 1:8))
> 
> ## Use explicit levels:
> ir1 <- IRanges(1:6, width=10)
> F1 <- Factor(ir0, levels=ir1)
> F1
Factor object of length 8 with 1 metadata column
Levels: IRanges object of length 6
> length(F1)
[1] 8
> names(F1)
[1] "a" "b" "c" "d" "e" "f" "g" "h"
> levels(F1)  # ir1
IRanges object with 6 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         1        10        10
  [2]         2        11        10
  [3]         3        12        10
  [4]         4        13        10
  [5]         5        14        10
  [6]         6        15        10
> nlevels(F1)
[1] 6
> as.integer(F1)  # encoding
a b c d e f g h 
3 3 2 2 3 5 4 1 
> 
> ## If we don't specify the levels, they'll be set to unique(ir0):
> F2 <- Factor(ir0)
> F2
Factor object of length 8 with 1 metadata column
Levels: IRanges object of length 5
> length(F2)
[1] 8
> names(F2)
[1] "a" "b" "c" "d" "e" "f" "g" "h"
> levels(F2)  # unique(ir0)
IRanges object with 5 ranges and 1 metadata column:
        start       end     width |          ID
    <integer> <integer> <integer> | <character>
  a         3        12        10 |         ID1
  c         2        11        10 |         ID3
  f         5        14        10 |         ID6
  g         4        13        10 |         ID7
  h         1        10        10 |         ID8
> nlevels(F2)
[1] 5
> as.integer(F2)
a b c d e f g h 
1 1 2 2 1 3 4 5 
> 
> ## ---------------------------------------------------------------------
> ## DECODING
> ## ---------------------------------------------------------------------
> unfactor(F1)
IRanges object with 8 ranges and 1 metadata column:
        start       end     width |          ID
    <integer> <integer> <integer> | <character>
  a         3        12        10 |         ID1
  b         3        12        10 |         ID2
  c         2        11        10 |         ID3
  d         2        11        10 |         ID4
  e         3        12        10 |         ID5
  f         5        14        10 |         ID6
  g         4        13        10 |         ID7
  h         1        10        10 |         ID8
> 
> stopifnot(identical(ir0, unfactor(F1)))
> stopifnot(identical(ir0, unfactor(F2)))
> 
> unfactor(F1, use.names=FALSE)
IRanges object with 8 ranges and 1 metadata column:
          start       end     width |          ID
      <integer> <integer> <integer> | <character>
  [1]         3        12        10 |         ID1
  [2]         3        12        10 |         ID2
  [3]         2        11        10 |         ID3
  [4]         2        11        10 |         ID4
  [5]         3        12        10 |         ID5
  [6]         5        14        10 |         ID6
  [7]         4        13        10 |         ID7
  [8]         1        10        10 |         ID8
> unfactor(F1, ignore.mcols=TRUE)
IRanges object with 8 ranges and 0 metadata columns:
        start       end     width
    <integer> <integer> <integer>
  a         3        12        10
  b         3        12        10
  c         2        11        10
  d         2        11        10
  e         3        12        10
  f         5        14        10
  g         4        13        10
  h         1        10        10
> 
> ## ---------------------------------------------------------------------
> ## COERCION
> ## ---------------------------------------------------------------------
> F2b <- as(ir0, "Factor")  # same as Factor(ir0)
> stopifnot(identical(F2, F2b))
> 
> as.factor(F2)
   a    b    c    d    e    f    g    h 
3-12 3-12 2-11 2-11 3-12 5-14 4-13 1-10 
Levels: 3-12 2-11 5-14 4-13 1-10
> as.factor(F1)
   a    b    c    d    e    f    g    h 
3-12 3-12 2-11 2-11 3-12 5-14 4-13 1-10 
Levels: 1-10 2-11 3-12 4-13 5-14 6-15
> 
> as.character(F1)  # same as unfactor(as.factor(F1)),
     a      b      c      d      e      f      g      h 
"3-12" "3-12" "2-11" "2-11" "3-12" "5-14" "4-13" "1-10" 
>                   # and also same as as.character(unfactor(F1))
> 
> ## On an ordinary factor 'f', 'as(f, "Factor")' and 'Factor(f)' are
> ## NOT the same:
> f <- factor(sample(letters, 500, replace=TRUE), levels=letters)
> as(f, "Factor")  # same levels as 'f'
Factor object of length 500 with 0 metadata columns
Levels: character object of length 26
> Factor(f)        # levels **are** 'f'!
Factor object of length 500 with 0 metadata columns
Levels: factor object of length 26
> 
> stopifnot(identical(f, as.factor(as(f, "Factor"))))
> 
> ## ---------------------------------------------------------------------
> ## CONCATENATION
> ## ---------------------------------------------------------------------
> ir3 <- IRanges(c(5, 2, 8:6), width=10)
> F3 <- Factor(levels=ir3, index=2:4)
> F13 <- c(F1, F3)
> F13
Factor object of length 11 with 1 metadata column
Levels: IRanges object of length 8
> levels(F13)
IRanges object with 8 ranges and 0 metadata columns:
          start       end     width
      <integer> <integer> <integer>
  [1]         1        10        10
  [2]         2        11        10
  [3]         3        12        10
  [4]         4        13        10
  [5]         5        14        10
  [6]         6        15        10
  [7]         8        17        10
  [8]         7        16        10
> 
> stopifnot(identical(c(unfactor(F1), unfactor(F3)), unfactor(F13)))
> 
> ## ---------------------------------------------------------------------
> ## COMPARING & ORDERING
> ## ---------------------------------------------------------------------
> F1 == F2   # same as unfactor(F1) == unfactor(F2)
[1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
> 
> order(F1)  # same as order(unfactor(F1))
[1] 8 3 4 1 2 5 7 6
> order(F2)  # same as order(unfactor(F2))
[1] 8 3 4 1 2 5 7 6
> 
> ## The levels of the Factor influence the order of the table:
> table(F1)
F1
1-10 2-11 3-12 4-13 5-14 
   1    2    3    1    1 
> table(F2)
F2
1-10 2-11 3-12 4-13 5-14 
   1    2    3    1    1 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("Factor-class", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:IRanges’

> nameEx("FilterRules-class")
> ### * FilterRules-class
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: FilterRules-class
> ### Title: Collection of Filter Rules
> ### Aliases: class:expression_OR_function expression_OR_function-class
> ###   expression_OR_function class:FilterRules FilterRules-class
> ###   parallel_slot_names,FilterRules-method active
> ###   active,FilterRules-method active<- active<-,FilterRules-method
> ###   coerce,ANY,FilterRules-method coerce,SimpleList,FilterRules-method
> ###   [,FilterRules-method [[<-,FilterRules-method subsetByFilter
> ###   subsetByFilter,ANY,FilterRules-method eval,FilterRules,ANY-method
> ###   evalSeparately evalSeparately,FilterRules-method FilterRules
> ###   summary,FilterRules-method &,FilterRules,FilterRules-method params
> ###   params,FilterClosure-method
> ###   coerce,standardGeneric,FilterClosure-method
> ###   coerce,function,FilterClosure-method show,FilterClosure-method
> ### Keywords: classes methods
> 
> ### ** Examples
> 
> ## constructing a FilterRules instance
> 
> ## an empty set of filters
> filters <- FilterRules()
>   
> ## as a simple character vector
> filts <- c("peaks", "promoters")
> filters <- FilterRules(filts)
> active(filters) # all TRUE
    peaks promoters 
     TRUE      TRUE 
> 
> ## with functions and expressions
> filts <- list(peaks = expression(peaks), promoters = expression(promoters),
+               find_eboxes = function(rd) rep(FALSE, nrow(rd)))
> filters <- FilterRules(filts, active = FALSE)
> active(filters) # all FALSE
      peaks   promoters find_eboxes 
      FALSE       FALSE       FALSE 
> 
> ## direct, quoted args (character literal parsed)
> filters <- FilterRules(under_peaks = peaks, in_promoters = "promoters")
> filts <- list(under_peaks = expression(peaks),
+               in_promoters = expression(promoters))
> 
> ## specify both exprs and additional args
> filters <- FilterRules(filts, diffexp = de)
> 
> filts <- c("promoters", "peaks", "introns")
> filters <- FilterRules(filts)
> 
> ## evaluation
> df <- DataFrame(peaks = c(TRUE, TRUE, FALSE, FALSE),
+                 promoters = c(TRUE, FALSE, FALSE, TRUE),
+                 introns = c(TRUE, FALSE, FALSE, FALSE))
> eval(filters, df)
[1]  TRUE FALSE FALSE FALSE
> fm <- evalSeparately(filters, df)
> identical(filterRules(fm), filters)
[1] TRUE
> summary(fm)
<initial> promoters     peaks   introns   <final> 
        4         2         2         1         1 
> summary(fm, percent = TRUE)
<initial> promoters     peaks   introns   <final> 
     1.00      0.50      0.50      0.25      0.25 
> fm <- evalSeparately(filters, df, serial = TRUE)
> 
> ## set the active state directly
>   
> active(filters) <- FALSE # all FALSE
> active(filters) <- TRUE # all TRUE
> active(filters) <- c(FALSE, FALSE, TRUE)
> active(filters)["promoters"] <- TRUE # use a filter name
>   
> ## toggle the active state by name or index
>   
> active(filters) <- c(NA, 2) # NA's are dropped
> active(filters) <- c("peaks", NA) 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("FilterRules-class", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("Hits-class")
> ### * Hits-class
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: Hits-class
> ### Title: Hits objects
> ### Aliases: class:Hits Hits-class Hits class:SelfHits SelfHits-class
> ###   SelfHits class:SortedByQueryHits SortedByQueryHits-class
> ###   SortedByQueryHits class:SortedByQuerySelfHits
> ###   SortedByQuerySelfHits-class SortedByQuerySelfHits
> ###   parallel_slot_names,Hits-method from from,Hits-method to
> ###   to,Hits-method nLnode nLnode,Hits-method nRnode nRnode,Hits-method
> ###   nnode nnode,SelfHits-method countLnodeHits countLnodeHits,Hits-method
> ###   countRnodeHits countRnodeHits,Hits-method queryHits subjectHits
> ###   queryLength subjectLength countQueryHits countSubjectHits
> ###   updateObject,Hits-method coerce,Hits,SelfHits-method
> ###   coerce,SortedByQueryHits,SortedByQuerySelfHits-method
> ###   coerce,Hits,SortedByQueryHits-method
> ###   coerce,SelfHits,SortedByQuerySelfHits-method
> ###   coerce,Hits,SortedByQuerySelfHits-method as.matrix,Hits-method
> ###   as.table,Hits-method coerce,Hits,DFrame-method as.data.frame.Hits
> ###   as.data.frame,Hits-method extractROWS,SortedByQueryHits,ANY-method
> ###   classNameForDisplay,SortedByQueryHits-method summary.Hits
> ###   summary,Hits-method makeNakedCharacterMatrixForDisplay,Hits-method
> ###   show,Hits-method bindROWS,Hits-method sort,SortedByQueryHits-method
> ###   selectHits breakTies t.Hits t,Hits-method remapHits isSelfHit
> ###   isRedundantHit
> ### Keywords: methods classes
> 
> ### ** Examples
> 
> from <- c(5, 2, 3, 3, 3, 2)
> to <- c(11, 15, 5, 4, 5, 11)
> id <- letters[1:6]
> 
> Hits(from, to, 7, 15, id)
Hits object with 6 hits and 1 metadata column:
           from        to |          id
      <integer> <integer> | <character>
  [1]         5        11 |           a
  [2]         2        15 |           b
  [3]         3         5 |           c
  [4]         3         4 |           d
  [5]         3         5 |           e
  [6]         2        11 |           f
  -------
  nLnode: 7 / nRnode: 15
> Hits(from, to, 7, 15, id, sort.by.query=TRUE)
Hits object with 6 hits and 1 metadata column:
      queryHits subjectHits |          id
      <integer>   <integer> | <character>
  [1]         2          15 |           b
  [2]         2          11 |           f
  [3]         3           5 |           c
  [4]         3           4 |           d
  [5]         3           5 |           e
  [6]         5          11 |           a
  -------
  queryLength: 7 / subjectLength: 15
> 
> ## ---------------------------------------------------------------------
> ## selectHits()
> ## ---------------------------------------------------------------------
> 
> x <- c("a", "b", "a", "c", "d")
> table <- c("a", "e", "d", "a", "a", "d")
> hits <- findMatches(x, table)  # sorts the hits by query
> hits
Hits object with 8 hits and 0 metadata columns:
      queryHits subjectHits
      <integer>   <integer>
  [1]         1           1
  [2]         1           4
  [3]         1           5
  [4]         3           1
  [5]         3           4
  [6]         3           5
  [7]         5           3
  [8]         5           6
  -------
  queryLength: 5 / subjectLength: 6
> 
> selectHits(hits, select="all")  # no-op
Hits object with 8 hits and 0 metadata columns:
      queryHits subjectHits
      <integer>   <integer>
  [1]         1           1
  [2]         1           4
  [3]         1           5
  [4]         3           1
  [5]         3           4
  [6]         3           5
  [7]         5           3
  [8]         5           6
  -------
  queryLength: 5 / subjectLength: 6
> 
> selectHits(hits, select="first")
[1]  1 NA  1 NA  3
> selectHits(hits, select="first", nodup=TRUE)
[1]  1 NA  4 NA  3
> 
> selectHits(hits, select="last")
[1]  5 NA  5 NA  6
> selectHits(hits, select="last", nodup=TRUE)
[1]  5 NA  4 NA  6
> 
> selectHits(hits, select="arbitrary")
[1]  5 NA  5 NA  6
> selectHits(hits, select="count")
[1] 3 0 3 0 2
> 
> ## ---------------------------------------------------------------------
> ## remapHits()
> ## ---------------------------------------------------------------------
> 
> Lnodes.remapping <- factor(c(a="A", b="B", c="C", d="D")[x],
+                            levels=LETTERS[1:4])
> remapHits(hits, Lnodes.remapping=Lnodes.remapping)
Hits object with 5 hits and 0 metadata columns:
      queryHits subjectHits
      <integer>   <integer>
  [1]         1           1
  [2]         1           4
  [3]         1           5
  [4]         4           3
  [5]         4           6
  -------
  queryLength: 4 / subjectLength: 6
> 
> ## See ?`Hits-examples` in the IRanges package for more examples of basic
> ## manipulation of Hits objects.
> 
> ## ---------------------------------------------------------------------
> ## SelfHits objects
> ## ---------------------------------------------------------------------
> 
> hits2 <- SelfHits(c(2, 3, 3, 3, 3, 3, 4, 4, 4), c(4, 3, 2:4, 2, 2:3, 2), 4)
> ## Hits 2 and 4 are self hits (from 3rd node to itself):
> which(isSelfHit(hits2))
[1] 2 4
> ## Hits 4, 6, 7, 8, and 9, are redundant hits:
> which(isRedundantHit(hits2))
[1] 4 6 7 8 9
> 
> hits3 <- findMatches(x)
> hits3[!isSelfHit(hits3)]
SelfHits object with 2 hits and 0 metadata columns:
      queryHits subjectHits
      <integer>   <integer>
  [1]         1           3
  [2]         3           1
  -------
  queryLength: 5 / subjectLength: 5
> hits3[!(isSelfHit(hits3) | isRedundantHit(hits3))]
SelfHits object with 1 hit and 0 metadata columns:
      queryHits subjectHits
      <integer>   <integer>
  [1]         1           3
  -------
  queryLength: 5 / subjectLength: 5
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("Hits-class", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("Hits-comparison")
> ### * Hits-comparison
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: Hits-comparison
> ### Title: Comparing and ordering hits
> ### Aliases: Hits-comparison pcompare,Hits,Hits-method
> ###   match,Hits,Hits-method order,Hits-method
> ### Keywords: methods
> 
> ### ** Examples
> 
> ## ---------------------------------------------------------------------
> ## A. ELEMENT-WISE (AKA "PARALLEL") COMPARISON OF 2 Hits OBJECTS
> ## ---------------------------------------------------------------------
> hits <- Hits(c(2, 4, 4, 4, 5, 5), c(3, 1, 3, 2, 3, 2), 6, 3)
> hits
Hits object with 6 hits and 0 metadata columns:
           from        to
      <integer> <integer>
  [1]         2         3
  [2]         4         1
  [3]         4         3
  [4]         4         2
  [5]         5         3
  [6]         5         2
  -------
  nLnode: 6 / nRnode: 3
> 
> pcompare(hits, hits[3])
[1] -2 -2  0 -1  1  1
> pcompare(hits[3], hits)
[1]  2  2  0  1 -1 -1
> 
> hits == hits[3]
[1] FALSE FALSE  TRUE FALSE FALSE FALSE
> hits != hits[3]
[1]  TRUE  TRUE FALSE  TRUE  TRUE  TRUE
> hits >= hits[3]
[1] FALSE FALSE  TRUE FALSE  TRUE  TRUE
> hits < hits[3]
[1]  TRUE  TRUE FALSE  TRUE FALSE FALSE
> 
> ## ---------------------------------------------------------------------
> ## B. match(), %in%
> ## ---------------------------------------------------------------------
> table <- hits[-c(1, 3)]
> match(hits, table)
[1] NA  1 NA  2  3  4
> 
> hits %in% table
[1] FALSE  TRUE FALSE  TRUE  TRUE  TRUE
> 
> ## ---------------------------------------------------------------------
> ## C. order(), sort(), rank()
> ## ---------------------------------------------------------------------
> order(hits)
[1] 1 2 4 3 6 5
> sort(hits)
Hits object with 6 hits and 0 metadata columns:
           from        to
      <integer> <integer>
  [1]         2         3
  [2]         4         1
  [3]         4         2
  [4]         4         3
  [5]         5         2
  [6]         5         3
  -------
  nLnode: 6 / nRnode: 3
> rank(hits)
[1] 1 2 4 3 6 5
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("Hits-comparison", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("Hits-setops")
> ### * Hits-setops
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: Hits-setops
> ### Title: Set operations on Hits objects
> ### Aliases: Hits-setops union,SortedByQueryHits,Hits-method
> ### Keywords: methods
> 
> ### ** Examples
> 
> x <- Hits(c(2, 4, 4, 4, 5, 5), c(3, 1, 3, 2, 3, 2), 6, 3,
+           score=11:16)
> x
Hits object with 6 hits and 1 metadata column:
           from        to |     score
      <integer> <integer> | <integer>
  [1]         2         3 |        11
  [2]         4         1 |        12
  [3]         4         3 |        13
  [4]         4         2 |        14
  [5]         5         3 |        15
  [6]         5         2 |        16
  -------
  nLnode: 6 / nRnode: 3
> 
> y <- Hits(c(1, 3, 4, 4, 5, 5, 5), c(3, 3, 2, 1, 2, 1, 3), 6, 3,
+           score=21:27)
> y
Hits object with 7 hits and 1 metadata column:
           from        to |     score
      <integer> <integer> | <integer>
  [1]         1         3 |        21
  [2]         3         3 |        22
  [3]         4         2 |        23
  [4]         4         1 |        24
  [5]         5         2 |        25
  [6]         5         1 |        26
  [7]         5         3 |        27
  -------
  nLnode: 6 / nRnode: 3
> 
> union(x, y)
Hits object with 9 hits and 1 metadata column:
           from        to |     score
      <integer> <integer> | <integer>
  [1]         2         3 |        11
  [2]         4         1 |        12
  [3]         4         3 |        13
  [4]         4         2 |        14
  [5]         5         3 |        15
  [6]         5         2 |        16
  [7]         1         3 |        21
  [8]         3         3 |        22
  [9]         5         1 |        26
  -------
  nLnode: 6 / nRnode: 3
> union(y, x)  # same hits as in union(x, y), but in different order
Hits object with 9 hits and 1 metadata column:
           from        to |     score
      <integer> <integer> | <integer>
  [1]         1         3 |        21
  [2]         3         3 |        22
  [3]         4         2 |        23
  [4]         4         1 |        24
  [5]         5         2 |        25
  [6]         5         1 |        26
  [7]         5         3 |        27
  [8]         2         3 |        11
  [9]         4         3 |        13
  -------
  nLnode: 6 / nRnode: 3
> 
> intersect(x, y)
Hits object with 4 hits and 1 metadata column:
           from        to |     score
      <integer> <integer> | <integer>
  [1]         4         1 |        12
  [2]         4         2 |        14
  [3]         5         3 |        15
  [4]         5         2 |        16
  -------
  nLnode: 6 / nRnode: 3
> intersect(y, x)  # same hits as in intersect(x, y), but in
Hits object with 4 hits and 1 metadata column:
           from        to |     score
      <integer> <integer> | <integer>
  [1]         4         2 |        23
  [2]         4         1 |        24
  [3]         5         2 |        25
  [4]         5         3 |        27
  -------
  nLnode: 6 / nRnode: 3
>                  # different order
> 
> setdiff(x, y)
Hits object with 2 hits and 1 metadata column:
           from        to |     score
      <integer> <integer> | <integer>
  [1]         2         3 |        11
  [2]         4         3 |        13
  -------
  nLnode: 6 / nRnode: 3
> setdiff(y, x)
Hits object with 3 hits and 1 metadata column:
           from        to |     score
      <integer> <integer> | <integer>
  [1]         1         3 |        21
  [2]         3         3 |        22
  [3]         5         1 |        26
  -------
  nLnode: 6 / nRnode: 3
> 
> setequal(x, y)
[1] FALSE
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("Hits-setops", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("HitsList-class")
> ### * HitsList-class
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: HitsList-class
> ### Title: List of Hits objects
> ### Aliases: class:HitsList HitsList-class HitsList class:SelfHitsList
> ###   SelfHitsList-class SelfHitsList class:SortedByQueryHitsList
> ###   SortedByQueryHitsList-class SortedByQueryHitsList
> ###   class:SortedByQuerySelfHitsList SortedByQuerySelfHitsList-class
> ###   SortedByQuerySelfHitsList space space,HitsList-method
> ###   subjectHits,HitsList-method queryHits,HitsList-method
> ###   coerce,HitsList,SortedByQueryHitsList-method
> ###   coerce,SortedByQueryHitsList,HitsList-method
> ###   as.matrix,HitsList-method as.table,HitsList-method
> ###   relistToClass,Hits-method relistToClass,SortedByQueryHits-method
> ###   splitAsList,SortedByQueryHits,ANY-method t,HitsList-method
> ### Keywords: methods classes
> 
> ### ** Examples
> 
> hits <- Hits(rep(1:20, each=5), 100:1, 20, 100)
> hlist <- splitAsList(hits, 1:5)
> hlist
HitsList of length 5
names(5): 1 2 3 4 5
> hlist[[1]]
Hits object with 20 hits and 0 metadata columns:
            from        to
       <integer> <integer>
   [1]         1       100
   [2]         2        95
   [3]         3        90
   [4]         4        85
   [5]         5        80
   ...       ...       ...
  [16]        16        25
  [17]        17        20
  [18]        18        15
  [19]        19        10
  [20]        20         5
  -------
  nLnode: 20 / nRnode: 100
> hlist[[2]]
Hits object with 20 hits and 0 metadata columns:
            from        to
       <integer> <integer>
   [1]         1        99
   [2]         2        94
   [3]         3        89
   [4]         4        84
   [5]         5        79
   ...       ...       ...
  [16]        16        24
  [17]        17        19
  [18]        18        14
  [19]        19         9
  [20]        20         4
  -------
  nLnode: 20 / nRnode: 100
> 
> ## Some sanity checks:
> 
> hits1 <- Hits(c(4, 4, 15, 15), c(1, 2, 3, 4), 20, 4)
> hits2 <- Hits(c(4, 4, 15, 15), c(1, 2, 3, 4), 20, 4, sort.by.query=TRUE)
> 
> fA <- c(1, 1, 2, 2)
> hlist1A <- split(hits1, fA)
> hlist2A <- split(hits2, fA)
> stopifnot(identical(as(hlist1A, "SortedByQueryHitsList"), hlist2A))
> stopifnot(identical(hlist1A, as(hlist2A, "HitsList")))
> 
> fB <- c(1, 2, 1, 2)
> hlist1B <- split(hits1, fB)
> hlist2B <- split(hits2, fB)
> stopifnot(identical(as(hlist1B, "SortedByQueryHitsList"), hlist2B))
> stopifnot(identical(hlist1B, as(hlist2B, "HitsList")))
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("HitsList-class", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("LLint-class")
> ### * LLint-class
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: LLint-class
> ### Title: LLint vectors
> ### Aliases: class:LLint LLint-class class:integer_OR_LLint
> ###   integer_OR_LLint-class integer_OR_LLint is.LLint length,LLint-method
> ###   coerce,logical,LLint-method coerce,integer,LLint-method
> ###   coerce,numeric,LLint-method coerce,character,LLint-method as.LLint
> ###   as.logical.LLint as.logical,LLint-method as.integer.LLint
> ###   as.integer,LLint-method as.numeric.LLint as.numeric,LLint-method
> ###   as.character.LLint as.character,LLint-method LLint show,LLint-method
> ###   showAsCell,LLint-method bindROWS,LLint-method c,LLint-method
> ###   NA_LLint_ is.na,LLint-method Ops,LLint,LLint-method
> ###   Ops,LLint,numeric-method Ops,numeric,LLint-method
> ###   Summary,LLint-method
> ### Keywords: methods classes
> 
> ### ** Examples
> 
> ## A long long int uses 8 bytes (i.e. 64 bits) in C:
> .Machine$sizeof.longlong
[1] 8
> 
> ## ---------------------------------------------------------------------
> ## SIMPLE EXAMPLES
> ## ---------------------------------------------------------------------
> 
> LLint()
LLint(0)
> LLint(10)
LLint of length 10:
 [1] 0 0 0 0 0 0 0 0 0 0
> 
> as.LLint(3e9)
LLint of length 1:
[1] 3000000000
> as.LLint("3000000000")
LLint of length 1:
[1] 3000000000
> 
> x <- as.LLint(1:10 * 111111111)
> x * x
LLint of length 10:
 [1] 12345678987654321   49382715950617284   111111110888888889 
 [4] 197530863802469136  308641974691358025  444444443555555556 
 [7] 604938270395061729  790123455209876544  999999998000000001 
[10] 1234567898765432100
> 5 * x   # result as vector of doubles (i.e. 'x' coerced to double)
 [1]  555555555 1111111110 1666666665 2222222220 2777777775 3333333330
 [7] 3888888885 4444444440 4999999995 5555555550
> 5L * x  # result as LLint vector (i.e. 5L coerced to LLint vector)
LLint of length 10:
 [1] 555555555  1111111110 1666666665 2222222220 2777777775 3333333330
 [7] 3888888885 4444444440 4999999995 5555555550
> max(x)
LLint of length 1:
[1] 1111111110
> min(x)
LLint of length 1:
[1] 111111111
> range(x)
LLint of length 2:
[1] 111111111  1111111110
> sum(x)
LLint of length 1:
[1] 6111111105
> 
> x <- as.LLint(1:20)
> prod(x)
LLint of length 1:
[1] 2432902008176640000
> x <- as.LLint(1:21)
> prod(x)  # result is out of LLint range (+/-9.223e18)
Warning in prod(new("LLint", bytes = as.raw(c(0x01, 0x00, 0x00, 0x00, 0x00,  :
  LLint overflow - use prod(as.numeric(.))
LLint of length 1:
[1] NA
> prod(as.numeric(x))
[1] 5.109094e+19
> 
> x <- as.LLint(1:75000)
> sum(x * x * x) == sum(x) * sum(x)
[1] TRUE
> 
> ## Note that max(), min() and range() *always* return an LLint vector
> ## when called on an LLint vector, even when the vector is empty:
> max(LLint())  # NA with no warning
LLint of length 1:
[1] NA
> min(LLint())  # NA with no warning
LLint of length 1:
[1] NA
> 
> ## This differs from how max(), min() and range() behave on an empty
> ## integer vector:
> max(integer())  # -Inf with a warning
Warning in max(integer()) :
  no non-missing arguments to max; returning -Inf
[1] -Inf
> min(integer())  #  Inf with a warning
Warning in min(integer()) :
  no non-missing arguments to min; returning Inf
[1] Inf
> 
> ## ---------------------------------------------------------------------
> ## GOING FROM STRINGS TO INTEGERS
> ## ---------------------------------------------------------------------
> 
> ## as.integer() behaves like as.integer(as.double()) on a character
> ## vector. With the following consequence:
> s <- "-2.9999999999999999"
> as.integer(s)   # -3
[1] -3
> 
> ## as.LLint() converts the string *directly* to LLint, without
> ## coercing to double first:
> as.LLint(s)  # decimal part ignored
LLint of length 1:
[1] -2
> 
> ## ---------------------------------------------------------------------
> ## GOING FROM DOUBLE-PRECISION VALUES TO INTEGERS AND VICE-VERSA
> ## ---------------------------------------------------------------------
> 
> ## Be aware that a double-precision value is not guaranteed to represent
> ## exactly an integer > 2^53. This can cause some surprises:
> 2^53 == 2^53 + 1  # TRUE, yep!
[1] TRUE
> 
> ## And therefore:
> as.LLint(2^53) == as.LLint(2^53 + 1)  # also TRUE
[1] TRUE
> 
> ## This can be even more disturbing when passing a big literal integer
> ## value because the R parser will turn it into a double-precision value
> ## before passing it to as.LLint():
> x1 <- as.LLint(9007199254740992)  # same as as.LLint(2^53)
> x1
LLint of length 1:
[1] 9007199254740992
> x2 <- as.LLint(9007199254740993)  # same as as.LLint(2^53 + 1)
> x2
LLint of length 1:
[1] 9007199254740992
> x1 == x2  # still TRUE
[1] TRUE
> 
> ## However, no precision is lost if a string literal is used instead:
> x1 <- as.LLint("9007199254740992")
> x1
LLint of length 1:
[1] 9007199254740992
> x2 <- as.LLint("9007199254740993")
> x2
LLint of length 1:
[1] 9007199254740993
> x1 == x2  # FALSE
[1] FALSE
> x2 - x1
LLint of length 1:
[1] 1
> 
> d1 <- as.double(x1)
> d2 <- as.double(x2)  # warning!
Warning in .Call2("new_NUMERIC_from_LLint", x, PACKAGE = "S4Vectors") :
  non reversible coercion to double (integer values > 2^53 cannot be exactly
  represented by double values)
> d1 == d2  # TRUE
[1] TRUE
> 
> ## ---------------------------------------------------------------------
> ## LLint IS IMPLEMENTED AS AN S4 CLASS
> ## ---------------------------------------------------------------------
> 
> class(LLint(10))
[1] "LLint"
attr(,"package")
[1] "S4Vectors"
> typeof(LLint(10))        # S4
[1] "S4"
> storage.mode(LLint(10))  # S4
[1] "S4"
> is.vector(LLint(10))     # FALSE
[1] FALSE
> is.atomic(LLint(10))     # FALSE
[1] FALSE
> 
> ## This means that an LLint vector cannot go in an ordinary data
> ## frame:
> ## Not run: 
> ##D data.frame(id=as.LLint(1:5))  # error!
> ## End(Not run)
> ## A DataFrame needs to be used instead:
> DataFrame(id=as.LLint(1:5))
DataFrame with 5 rows and 1 column
       id
  <LLint>
1       1
2       2
3       3
4       4
5       5
> 
> ## ---------------------------------------------------------------------
> ## SANITY CHECKS
> ## ---------------------------------------------------------------------
> 
> x <- as.integer(c(0, 1, -1, -3, NA, -99))
> y <- as.integer(c(-6, NA, -4:3, 0, 1999, 6:10, NA))
> xx <- as.LLint(x)
> yy <- as.LLint(y)
> 
> ## Operations from "Arith" group:
> stopifnot(identical(x + y, as.integer(xx + yy)))
> stopifnot(identical(as.LLint(y + x), yy + xx))
> stopifnot(identical(x - y, as.integer(xx - yy)))
> stopifnot(identical(as.LLint(y - x), yy - xx))
> stopifnot(identical(x * y, as.integer(xx * yy)))
> stopifnot(identical(as.LLint(y * x), yy * xx))
> stopifnot(identical(x / y, xx / yy))
> stopifnot(identical(y / x, yy / xx))
> stopifnot(identical(x %/% y, as.integer(xx %/% yy)))
> stopifnot(identical(as.LLint(y %/% x), yy %/% xx))
> stopifnot(identical(x %% y, as.integer(xx %% yy)))
> stopifnot(identical(as.LLint(y %% x), yy %% xx))
> stopifnot(identical(x ^ y, xx ^ yy))
> stopifnot(identical(y ^ x, yy ^ xx))
> 
> ## Operations from "Compare" group:
> stopifnot(identical(x == y, xx == yy))
> stopifnot(identical(y == x, yy == xx))
> stopifnot(identical(x != y, xx != yy))
> stopifnot(identical(y != x, yy != xx))
> stopifnot(identical(x <= y, xx <= yy))
> stopifnot(identical(y <= x, yy <= xx))
> stopifnot(identical(x >= y, xx >= yy))
> stopifnot(identical(y >= x, yy >= xx))
> stopifnot(identical(x < y, xx < yy))
> stopifnot(identical(y < x, yy < xx))
> stopifnot(identical(x > y, xx > yy))
> stopifnot(identical(y > x, yy > xx))
> 
> ## Operations from "Summary" group:
> stopifnot(identical(max(y), as.integer(max(yy))))
> stopifnot(identical(max(y, na.rm=TRUE), as.integer(max(yy, na.rm=TRUE))))
> stopifnot(identical(min(y), as.integer(min(yy))))
> stopifnot(identical(min(y, na.rm=TRUE), as.integer(min(yy, na.rm=TRUE))))
> stopifnot(identical(range(y), as.integer(range(yy))))
> stopifnot(identical(range(y, na.rm=TRUE), as.integer(range(yy, na.rm=TRUE))))
> stopifnot(identical(sum(y), as.integer(sum(yy))))
> stopifnot(identical(sum(y, na.rm=TRUE), as.integer(sum(yy, na.rm=TRUE))))
> stopifnot(identical(prod(y), as.double(prod(yy))))
> stopifnot(identical(prod(y, na.rm=TRUE), as.double(prod(yy, na.rm=TRUE))))
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("LLint-class", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("List-class")
> ### * List-class
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: List-class
> ### Title: List objects
> ### Aliases: class:List List-class List class:list_OR_List
> ###   list_OR_List-class list_OR_List elementType elementType,List-method
> ###   elementType,vector-method elementNROWS elementNROWS,ANY-method
> ###   elementNROWS,List-method isEmpty isEmpty,ANY-method
> ###   isEmpty,List-method parallelVectorNames,List-method
> ###   coerce,List,list-method coerce,ANY,List-method
> ###   coerce,integer,List-method as.list,List-method unlist,List-method
> ###   as.data.frame,List-method [,List-method [<-,List-method
> ###   [[,List-method [[<-,List-method $,List-method $<-,List-method
> ###   setListElement,List-method getListElement,List-method
> ###   show,List-method showAsCell,List-method
> ### Keywords: methods classes
> 
> ### ** Examples
> 
> showClass("List")  # shows only the known subclasses define in this package
Virtual Class "List" [package "S4Vectors"]

Slots:
                                                            
Name:        elementType   elementMetadata          metadata
Class:         character DataFrame_OR_NULL              list

Extends: 
Class "Vector", directly
Class "list_OR_List", directly
Class "Annotated", by class "Vector", distance 2
Class "vector_OR_Vector", by class "Vector", distance 2

Known Subclasses: 
Class "SimpleList", directly
Class "TransposedDataFrame", directly
Class "HitsList", by class "SimpleList", distance 2
Class "DataFrame", by class "SimpleList", distance 2
Class "SelfHitsList", by class "SimpleList", distance 3
Class "SortedByQueryHitsList", by class "SimpleList", distance 3
Class "DFrame", by class "SimpleList", distance 3
Class "SortedByQuerySelfHitsList", by class "SimpleList", distance 4
Class "FilterRules", by class "SimpleList", distance 2
> 
> ## ---------------------------------------------------------------------
> ## A. CONSTRUCTION
> ## ---------------------------------------------------------------------
> x <- sample(500, 20)
> y0 <- splitAsList(x, x %% 4)
> y0
IntegerList of length 4
[["0"]] 324
[["1"]] 129 481 85 277 329 213
[["2"]] 418 270 466 362 438 330
[["3"]] 167 471 299 187 307 263 79
> 
> levels <- paste0("G", 1:10)
> f1 <- factor(sample(levels, length(x), replace=TRUE), levels=levels)
> y1 <- splitAsList(x, f1)
> y1
IntegerList of length 10
[["G1"]] 187
[["G2"]] 299
[["G3"]] 481
[["G4"]] 307 330 263
[["G5"]] 324 418 471
[["G6"]] 85 438
[["G7"]] 213
[["G8"]] integer(0)
[["G9"]] 167 129 466 79
[["G10"]] 270 277 362 329
> 
> f2 <- factor(sample(levels, 26, replace=TRUE), levels=levels)
> y2 <- splitAsList(letters, f2)
> y2
CharacterList of length 10
[["G1"]] r
[["G2"]] n o
[["G3"]] j s t
[["G4"]] character(0)
[["G5"]] character(0)
[["G6"]] a g l p q v x
[["G7"]] e i w z
[["G8"]] c f m u y
[["G9"]] b d
[["G10"]] h k
> 
> library(IRanges)  # for the NumericList() constructor and the
>                   # coercion to CompressedCharacterList
> 
> NumericList(A=runif(10), B=NULL, C=runif(3))
NumericList of length 3
[["A"]] 0.325352151878178 0.757087148027495 ... 0.642288258532062
[["B"]] numeric(0)
[["C"]] 0.876269212691113 0.778914677444845 0.79730882588774
> 
> ## Another way to obtain 'splitAsList(letters, f2)' but using
> ## 'splitAsList()' should be preferred as it is a lot more efficient:
> y2b <- as(split(letters, f2), "CompressedCharacterList")  # inefficient!
> stopifnot(identical(y2, y2b))
> 
> ## ---------------------------------------------------------------------
> ## B. SUBSETTING
> ## ---------------------------------------------------------------------
> ## Single-bracket and double-bracket subsetting behave like on ordinary
> ## lists:
> y1[c(10, 1, 2, 2)]
IntegerList of length 4
[["G10"]] 270 277 362 329
[["G1"]] 187
[["G2"]] 299
[["G2"]] 299
> y1[c(-10, -1, -2)]
IntegerList of length 7
[["G3"]] 481
[["G4"]] 307 330 263
[["G5"]] 324 418 471
[["G6"]] 85 438
[["G7"]] 213
[["G8"]] integer(0)
[["G9"]] 167 129 466 79
> y1[c(TRUE, FALSE)]
IntegerList of length 5
[["G1"]] 187
[["G3"]] 481
[["G5"]] 324 418 471
[["G7"]] 213
[["G9"]] 167 129 466 79
> y1[c("G8", "G1")]
IntegerList of length 2
[["G8"]] integer(0)
[["G1"]] 187
> head(y1)
IntegerList of length 6
[["G1"]] 187
[["G2"]] 299
[["G3"]] 481
[["G4"]] 307 330 263
[["G5"]] 324 418 471
[["G6"]] 85 438
> tail(y1, n=3)
IntegerList of length 3
[["G8"]] integer(0)
[["G9"]] 167 129 466 79
[["G10"]] 270 277 362 329
> y1[[2]]     # note the difference with y1[2]
[1] 299
> y1[["G2"]]  # note the difference with y1["G2"]
[1] 299
> 
> y0[["3"]]
[1] 167 471 299 187 307 263  79
> y0[[3]]
[1] 418 270 466 362 438 330
> 
> ## In addition to all the forms of subscripting supported by ordinary
> ## lists, List objects and derivatives accept a subscript that is a
> ## list-like object. This form of subsetting is called "list-style
> ## subsetting":
> i <- list(4:3, -2, 1)    # ordinary list
> y1[i]
IntegerList of length 3
[["G1"]] <NA> <NA>
[["G2"]] 299
[["G3"]] 481
> i <- y1 >= 200           # LogicalList object
> y1[i]
IntegerList of length 10
[["G1"]] integer(0)
[["G2"]] 299
[["G3"]] 481
[["G4"]] 307 330 263
[["G5"]] 324 418 471
[["G6"]] 438
[["G7"]] 213
[["G8"]] integer(0)
[["G9"]] 466
[["G10"]] 270 277 362 329
> 
> ## List-style subsetting also works with an RleList or IntegerRangesList
> ## subscript:
> i <- RleList(y1 >= 200)  # RleList object
> y1[i]
IntegerList of length 10
[["G1"]] integer(0)
[["G2"]] 299
[["G3"]] 481
[["G4"]] 307 330 263
[["G5"]] 324 418 471
[["G6"]] 438
[["G7"]] 213
[["G8"]] integer(0)
[["G9"]] 466
[["G10"]] 270 277 362 329
> i <- IRangesList(RleList(y1 >= 200))  # IRangesList object
> y1[i]
IntegerList of length 10
[["G1"]] integer(0)
[["G2"]] 299
[["G3"]] 481
[["G4"]] 307 330 263
[["G5"]] 324 418 471
[["G6"]] 438
[["G7"]] 213
[["G8"]] integer(0)
[["G9"]] 466
[["G10"]] 270 277 362 329
> 
> ## ---------------------------------------------------------------------
> ## C. THE "UNLIST -> TRANFORM -> RELIST" IDIOM
> ## ---------------------------------------------------------------------
> ## The "unlist -> transform -> relist" idiom is a very efficient way to
> ## apply the same simple transformation to all the **inner elements** of
> ## a list-like object (i.e. to all the elements of its list elements).
> ## The result is another list-like object with the same shape as the
> ## original object (but not necessarily the same class):
> relist(sqrt(unlist(y1)), y1)
NumericList of length 10
[["G1"]] G1=13.6747943311773
[["G2"]] G2=17.2916164657906
[["G3"]] G3=21.9317121994613
[["G4"]] G4=17.5214154679352 G4=18.1659021245849 G4=16.2172747402269
[["G5"]] G5=18 G5=20.4450483002609 G5=21.7025344142107
[["G6"]] G6=9.21954445729289 G6=20.9284495364563
[["G7"]] G7=14.5945195193264
[["G8"]] named numeric(0)
[["G9"]] G9=12.9228479833201 G9=11.3578166916005 G9=21.5870331449229 G9=8.88819441731559
[["G10"]] G10=16.431676725155 G10=16.6433169770932 G10=19.0262975904404 G10=18.1383571472171
> relist(toupper(unlist(y2)), y2)
CharacterList of length 10
[["G1"]] G1=R
[["G2"]] G2=N G2=O
[["G3"]] G3=J G3=S G3=T
[["G4"]] named character(0)
[["G5"]] named character(0)
[["G6"]] G6=A G6=G G6=L G6=P G6=Q G6=V G6=X
[["G7"]] G7=E G7=I G7=W G7=Z
[["G8"]] G8=C G8=F G8=M G8=U G8=Y
[["G9"]] G9=B G9=D
[["G10"]] G10=H G10=K
> 
> ## However note that sqrt(), toupper(), and many other base functions,
> ## can be used directly on a List derivative. This is because the IRanges
> ## package defines methods for these functions that know how to handle
> ## List objects:
> sqrt(y1)     # same as 'relist(sqrt(unlist(y1)), y1)'
NumericList of length 10
[["G1"]] 13.6747943311773
[["G2"]] 17.2916164657906
[["G3"]] 21.9317121994613
[["G4"]] 17.5214154679352 18.1659021245849 16.2172747402269
[["G5"]] 18 20.4450483002609 21.7025344142107
[["G6"]] 9.21954445729289 20.9284495364563
[["G7"]] 14.5945195193264
[["G8"]] numeric(0)
[["G9"]] 12.9228479833201 11.3578166916005 21.5870331449229 8.88819441731559
[["G10"]] 16.431676725155 16.6433169770932 19.0262975904404 18.1383571472171
> toupper(y2)  # same as 'relist(toupper(unlist(y2)), y2)'
CharacterList of length 10
[["G1"]] R
[["G2"]] N O
[["G3"]] J S T
[["G4"]] character(0)
[["G5"]] character(0)
[["G6"]] A G L P Q V X
[["G7"]] E I W Z
[["G8"]] C F M U Y
[["G9"]] B D
[["G10"]] H K
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("List-class", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:IRanges’

> nameEx("List-utils")
> ### * List-utils
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: List-utils
> ### Title: Common operations on List objects
> ### Aliases: List-utils lapply,List-method sapply,List-method endoapply
> ###   revElements revElements,list-method revElements,List-method
> ###   mendoapply pc Reduce,List-method Filter,List-method Find,List-method
> ###   Map,List-method Position,List-method within,List-method
> ###   rbind,List-method cbind.List cbind,List-method droplevels.List
> ###   droplevels,List-method
> ### Keywords: utilities methods
> 
> ### ** Examples
> 
> a <- data.frame(x = 1:10, y = rnorm(10))
> b <- data.frame(x = 1:10, y = rnorm(10))
> 
> endoapply(a, function(x) (x - mean(x))/sd(x))
            x           y
1  -1.4863011 -0.97190653
2  -1.1560120  0.06589991
3  -0.8257228 -1.23987805
4  -0.4954337  1.87433300
5  -0.1651446  0.25276523
6   0.1651446 -1.22045645
7   0.4954337  0.45507643
8   0.8257228  0.77649606
9   1.1560120  0.56826358
10  1.4863011 -0.56059319
> mendoapply(function(e1, e2) (e1 - mean(e1)) * (e2 - mean(e2)), a, b)
       x            y
1  20.25 -0.958134872
2  12.25  0.007253027
3   6.25  0.842096112
4   2.25 -3.604358335
5   0.25  0.172856129
6   0.25  0.279874382
7   2.25 -0.094147478
8   6.25  0.421249427
9  12.25  0.253893827
10 20.25 -0.150993611
> 
> x <- list(a=11:13, b=26:21, c=letters)
> y <- list(-(5:1), c("foo", "bar"), 0.25)
> pc(x, y)
$a
[1] "11" "12" "13" "-5" "-4" "-3" "-2" "-1"

$b
[1] "26"  "25"  "24"  "23"  "22"  "21"  "foo" "bar"

$c
 [1] "a"    "b"    "c"    "d"    "e"    "f"    "g"    "h"    "i"    "j"   
[11] "k"    "l"    "m"    "n"    "o"    "p"    "q"    "r"    "s"    "t"   
[21] "u"    "v"    "w"    "x"    "y"    "z"    "0.25"

> 
> library(IRanges)
> x <- IntegerList(a=11:13, b=26:21, c=31:36, d=4:2)
> y <- NumericList(-(5:1), 1:2, numeric(0), 0.25)
> pc(x, y)
NumericList of length 4
[["a"]] 11 12 13 -5 -4 -3 -2 -1
[["b"]] 26 25 24 23 22 21 1 2
[["c"]] 31 32 33 34 35 36
[["d"]] 4 3 2 0.25
> 
> Reduce("+", x)
[1] 72 72 72 72 72 72
> 
> Filter(is.unsorted, x)
IntegerList of length 2
[["b"]] 26 25 24 23 22 21
[["d"]] 4 3 2
> 
> pos1 <- Position(is.unsorted, x)
> stopifnot(identical(Find(is.unsorted, x), x[[pos1]]))
> 
> pos2 <- Position(is.unsorted, x, right=TRUE)
> stopifnot(identical(Find(is.unsorted, x, right=TRUE), x[[pos2]]))
> 
> y <- x * 1000L
> Map("c", x, y)
$a
[1]    11    12    13 11000 12000 13000

$b
 [1]    26    25    24    23    22    21 26000 25000 24000 23000 22000 21000

$c
 [1]    31    32    33    34    35    36 31000 32000 33000 34000 35000 36000

$d
[1]    4    3    2 4000 3000 2000

> 
> rbind(x, y)
  a         b         c         d        
x integer,3 integer,6 integer,6 integer,3
y integer,3 integer,6 integer,6 integer,3
> cbind(x, y)
  x         y        
a integer,3 integer,3
b integer,6 integer,6
c integer,6 integer,6
d integer,3 integer,3
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("List-utils", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:IRanges’

> nameEx("Pairs-class")
> ### * Pairs-class
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: Pairs-class
> ### Title: Pairs objects
> ### Aliases: class:Pairs Pairs-class parallel_slot_names,Pairs-method first
> ###   first,Pairs-method second second,Pairs-method first<-
> ###   first<-,Pairs-method second<- second<-,Pairs-method
> ###   names,Pairs-method names<-,Pairs-method order,Pairs-method
> ###   sameAsPreviousROW,Pairs-method pcompare,Pairs,Pairs-method
> ###   match,Pairs,Pairs-method Pairs zipup,Pairs,missing-method
> ###   coerce,Pairs,DFrame-method coerce,list_OR_List,Pairs-method
> ###   as.data.frame,Pairs-method
> ###   makeNakedCharacterMatrixForDisplay,Pairs-method show,Pairs-method
> ### Keywords: methods classes
> 
> ### ** Examples
> 
> p <- Pairs(1:10, Rle(1L, 10), score=rnorm(10), names=letters[1:10])
> identical(first(p), 1:10)
[1] TRUE
> mcols(p)$score
 [1] -0.6264538  0.1836433 -0.8356286  1.5952808  0.3295078 -0.8204684
 [7]  0.4874291  0.7383247  0.5757814 -0.3053884
> p 
Pairs object with 10 pairs and 1 metadata column:
        first second |     score
    <integer>  <Rle> | <numeric>
  a         1      1 | -0.626454
  b         2      1 |  0.183643
  c         3      1 | -0.835629
  d         4      1 |  1.595281
  e         5      1 |  0.329508
  f         6      1 | -0.820468
  g         7      1 |  0.487429
  h         8      1 |  0.738325
  i         9      1 |  0.575781
  j        10      1 | -0.305388
> as.data.frame(p)
   first second      score names
1      1      1 -0.6264538     a
2      2      1  0.1836433     b
3      3      1 -0.8356286     c
4      4      1  1.5952808     d
5      5      1  0.3295078     e
6      6      1 -0.8204684     f
7      7      1  0.4874291     g
8      8      1  0.7383247     h
9      9      1  0.5757814     i
10    10      1 -0.3053884     j
> z <- zipup(p)
> first(p) <- Rle(1:10)
> identical(zipdown(z), p)
[1] FALSE
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("Pairs-class", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("RectangularData-class")
> ### * RectangularData-class
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: RectangularData-class
> ### Title: RectangularData objects
> ### Aliases: class:RectangularData RectangularData-class RectangularData
> ###   vertical_slot_names horizontal_slot_names ROWNAMES
> ###   ROWNAMES,ANY-method ROWNAMES,RectangularData-method ROWNAMES<-
> ###   ROWNAMES<-,ANY-method ROWNAMES<-,RectangularData-method
> ###   head.RectangularData head,RectangularData-method tail.RectangularData
> ###   tail,RectangularData-method subset,RectangularData-method
> ###   rbind.RectangularData rbind,RectangularData-method
> ###   cbind.RectangularData cbind,RectangularData-method combineRows
> ###   combineCols combineUniqueCols
> ### Keywords: methods classes
> 
> ### ** Examples
> 
> showClass("RectangularData")  # shows (some of) the known subclasses
Virtual Class "RectangularData" [package "S4Vectors"]

No Slots, prototype of class "S4"

Known Subclasses: 
Class "DataFrame", directly
Class "TransposedDataFrame", directly
Class "DFrame", by class "DataFrame", distance 2, with explicit coerce
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("RectangularData-class", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("Rle-class")
> ### * Rle-class
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: Rle-class
> ### Title: Rle objects
> ### Aliases: class:Rle Rle-class Rle Rle,ANY-method Rle,Rle-method
> ###   length,Rle-method runLength runLength,Rle-method runValue
> ###   runValue,Rle-method nrun nrun,Rle-method start,Rle-method
> ###   end,Rle-method width,Rle-method runLength<- runLength<-,Rle-method
> ###   runValue<- runValue<-,Rle-method as.vector,Rle-method as.vector.Rle
> ###   as.factor,Rle-method as.data.frame,Rle-method as.list,Rle-method
> ###   coerce,Rle,list-method coerce,ANY,Rle-method coerce,Rle,vector-method
> ###   coerce,Rle,logical-method coerce,Rle,integer-method
> ###   coerce,Rle,numeric-method coerce,Rle,complex-method
> ###   coerce,Rle,character-method coerce,Rle,raw-method
> ###   coerce,Rle,factor-method decode decode,ANY-method decode,Rle-method
> ###   extractROWS,Rle,ANY-method extractROWS,Rle,RangeNSBS-method
> ###   extractROWS,Rle,NSBS-method [,Rle-method replaceROWS,Rle,ANY-method
> ###   [<-,Rle,ANY-method NSBS,Rle-method as.integer,RleNSBS-method
> ###   length,RleNSBS-method anyDuplicated,RleNSBS-method
> ###   isStrictlySorted,RleNSBS-method extractROWS,Rle,RleNSBS-method
> ###   rev.Rle rev,Rle-method rep.int,Rle-method rep,Rle-method
> ###   bindROWS,Rle-method append,Rle,vector-method append,vector,Rle-method
> ###   %in%,Rle,ANY-method findRun findRun,Rle-method is.na,Rle-method
> ###   is.finite,Rle-method anyNA,Rle-method match,ANY,Rle-method
> ###   match,Rle,ANY-method match,Rle,Rle-method duplicated,Rle-method
> ###   anyDuplicated.Rle anyDuplicated,Rle-method unique,Rle-method
> ###   order,Rle-method is.unsorted,Rle-method isStrictlySorted,Rle-method
> ###   sort.Rle sort,Rle-method rank,Rle-method xtfrm,Rle-method
> ###   table,Rle-method tabulate,Rle-method union,Rle,Rle-method
> ###   union,ANY,Rle-method union,Rle,ANY-method intersect,Rle,Rle-method
> ###   intersect,ANY,Rle-method intersect,Rle,ANY-method
> ###   setdiff,Rle,Rle-method setdiff,ANY,Rle-method setdiff,Rle,ANY-method
> ###   show,Rle-method
> ### Keywords: methods classes
> 
> ### ** Examples
> 
>   x <- Rle(10:1, 1:10)
>   x
integer-Rle of length 55 with 10 runs
  Lengths:  1  2  3  4  5  6  7  8  9 10
  Values : 10  9  8  7  6  5  4  3  2  1
> 
>   runLength(x)
 [1]  1  2  3  4  5  6  7  8  9 10
>   runValue(x)
 [1] 10  9  8  7  6  5  4  3  2  1
>   nrun(x)
[1] 10
> 
>   diff(x)
integer-Rle of length 54 with 18 runs
  Lengths:  1  1  1  2  1  3  1  4  1  5  1  6  1  7  1  8  1  9
  Values : -1  0 -1  0 -1  0 -1  0 -1  0 -1  0 -1  0 -1  0 -1  0
>   unique(x)
 [1] 10  9  8  7  6  5  4  3  2  1
>   sort(x)
integer-Rle of length 55 with 10 runs
  Lengths: 10  9  8  7  6  5  4  3  2  1
  Values :  1  2  3  4  5  6  7  8  9 10
>   x[c(1,3,5,7,9)]
integer-Rle of length 5 with 4 runs
  Lengths:  1  1  1  2
  Values : 10  9  8  7
>   x > 4
logical-Rle of length 55 with 2 runs
  Lengths:    21    34
  Values :  TRUE FALSE
> 
>   x2 <- Rle(LETTERS[c(21:26, 25:26)], 8:1)
>   table(x2)
x2
U V W X Y Z 
8 7 6 5 6 4 
> 
>   y <- Rle(c(TRUE,TRUE,FALSE,FALSE,TRUE,FALSE,TRUE,TRUE,TRUE))
>   y
logical-Rle of length 9 with 5 runs
  Lengths:     2     2     1     1     3
  Values :  TRUE FALSE  TRUE FALSE  TRUE
>   as.vector(y)
[1]  TRUE  TRUE FALSE FALSE  TRUE FALSE  TRUE  TRUE  TRUE
>   rep(y, 10)
logical-Rle of length 90 with 41 runs
  Lengths:     2     2     1     1     5 ...     5     2     1     1     3
  Values :  TRUE FALSE  TRUE FALSE  TRUE ...  TRUE FALSE  TRUE FALSE  TRUE
>   c(y, x > 5)
logical-Rle of length 64 with 6 runs
  Lengths:     2     2     1     1    18    40
  Values :  TRUE FALSE  TRUE FALSE  TRUE FALSE
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("Rle-class", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("Rle-runstat")
> ### * Rle-runstat
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: Rle-runstat
> ### Title: Fixed-width running window summaries
> ### Aliases: Rle-runstat runsum runsum,Rle-method runmean
> ###   runmean,Rle-method smoothEnds,Rle-method runmed,Rle-method runwtsum
> ###   runwtsum,Rle-method runq runq,Rle-method
> ### Keywords: methods algebra arith
> 
> ### ** Examples
> 
>   x <- Rle(1:10, 1:10)
>   runsum(x, k = 3)
integer-Rle of length 53 with 25 runs
  Lengths:  1  1  1  1  1  1  2  1  1  3  1 ...  5  1  1  6  1  1  7  1  1  8
  Values :  5  7  8  9 10 11 12 13 14 15 16 ... 21 22 23 24 25 26 27 28 29 30
>   runsum(x, k = 3, endrule = "constant")
integer-Rle of length 55 with 25 runs
  Lengths:  2  1  1  1  1  1  2  1  1  3  1 ...  5  1  1  6  1  1  7  1  1  9
  Values :  5  7  8  9 10 11 12 13 14 15 16 ... 21 22 23 24 25 26 27 28 29 30
>   runmean(x, k = 3)
numeric-Rle of length 53 with 25 runs
  Lengths:        1        1        1        1 ...        1        1        8
  Values :  1.66667  2.33333  2.66667  3.00000 ...  9.33333  9.66667 10.00000
>   runwtsum(x, k = 3, wt = c(0.25, 0.5, 0.25))
numeric-Rle of length 53 with 25 runs
  Lengths:     1     1     1     1     1 ...     1     7     1     1     8
  Values :  1.75  2.25  2.75  3.00  3.25 ...  8.75  9.00  9.25  9.75 10.00
>   runq(x, k = 5, i = 3, endrule = "constant")
integer-Rle of length 55 with 9 runs
  Lengths:  3  3  4  5  6  7  8  9 10
  Values :  2  3  4  5  6  7  8  9 10
> 
>   ## Missing and non-finite values
>   x <- Rle(c(1, 2, NA, 0, 3, Inf, 4, NaN))
>   runsum(x, k = 2)
numeric-Rle of length 7 with 5 runs
  Lengths:   1   2   1   2   1
  Values :   3  NA   3 Inf NaN
>   runsum(x, k = 2, na.rm = TRUE)
numeric-Rle of length 7 with 6 runs
  Lengths:   1   1   1   1   2   1
  Values :   3   2   0   3 Inf   4
>   runmean(x, k = 2, na.rm = TRUE)
numeric-Rle of length 7 with 6 runs
  Lengths:   1   1   1   1   2   1
  Values : 1.5 2.0 0.0 1.5 Inf 4.0
>   runwtsum(x, k = 2, wt =  c(0.25, 0.5), na.rm = TRUE)
numeric-Rle of length 7 with 6 runs
  Lengths:    1    1    1    1    2    1
  Values : 1.25 0.50 0.00 1.50  Inf 1.00
>   runq(x, k = 2, i = 2, na.rm = TRUE) ## max value in window
numeric-Rle of length 7 with 5 runs
  Lengths:   2   1   1   2   1
  Values :   2   0   3 Inf   4
> 
>   ## The .naive_runsum() function demonstrates the semantics of 
>   ## runsum(). This test ensures the behavior is consistent with
>   ## base::sum().
> 
>   .naive_runsum <- function(x, k, na.rm=FALSE)
+       sapply(0:(length(x)-k),
+           function(offset) sum(x[1:k + offset], na.rm=na.rm))
> 
>   x0 <- c(1, Inf, 3, 4, 5, NA)
>   x <- Rle(x0)
>   target1 <- .naive_runsum(x0, 3, na.rm = TRUE)
>   target2 <- .naive_runsum(x, 3, na.rm = TRUE)
>   stopifnot(target1 == target2)
>   current <- as.vector(runsum(x, 3, na.rm = TRUE))
>   stopifnot(target1 == current)
> 
>   ## runmean() and runwtsum() :
>   x <- Rle(c(2, 1, NA, 0, 1, -Inf))
>   runmean(x, k = 3)
numeric-Rle of length 4 with 2 runs
  Lengths:    3    1
  Values :   NA -Inf
>   runmean(x, k = 3, na.rm = TRUE)
numeric-Rle of length 4 with 3 runs
  Lengths:    1    2    1
  Values :  1.5  0.5 -Inf
>   runwtsum(x, k = 3, wt = c(0.25, 0.50, 0.25))
numeric-Rle of length 4 with 2 runs
  Lengths:    3    1
  Values :   NA -Inf
>   runwtsum(x, k = 3, wt = c(0.25, 0.50, 0.25), na.rm = TRUE)
numeric-Rle of length 4 with 3 runs
  Lengths:    1    2    1
  Values : 1.00 0.25 -Inf
> 
>   ## runq() :
>   runq(x, k = 3, i = 1, na.rm = TRUE) ## smallest value in window
numeric-Rle of length 4 with 3 runs
  Lengths:    1    2    1
  Values :    1    0 -Inf
>   runq(x, k = 3, i = 3, na.rm = TRUE) ## largest value in window
numeric-Rle of length 4 with 2 runs
  Lengths: 1 3
  Values : 2 1
> 
>   ## When na.rm = TRUE, it is possible the number of non-NA 
>   ## values in the window will be less than the 'i' specified.
>   ## Here we request the 4th smallest value in the window,
>   ## which tranlates to the value at the 4/5 (0.8) percentile.
>   x <- Rle(c(1, 2, 3, 4, 5))
>   runq(x, k=length(x), i=4, na.rm=TRUE)
numeric-Rle of length 1 with 1 run
  Lengths: 1
  Values : 4
> 
>   ## The same request on a Rle with two missing values
>   ## finds the value at the 0.8 percentile of the vector 
>   ## at the new length of 3 after the NA's have been removed.
>   ## This translates to round((0.8) * 3).
>   x <- Rle(c(1, 2, 3, NA, NA))
>   runq(x, k=length(x), i=4, na.rm=TRUE)
numeric-Rle of length 1 with 1 run
  Lengths: 1
  Values : 2
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("Rle-runstat", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("Rle-utils")
> ### * Rle-utils
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: Rle-utils
> ### Title: Common operations on Rle objects
> ### Aliases: Rle-utils Ops,Rle,Rle-method Ops,Rle,vector-method
> ###   Ops,vector,Rle-method Math,Rle-method Math2,Rle-method
> ###   Summary,Rle-method Complex,Rle-method summary.Rle summary,Rle-method
> ###   !,Rle-method which,Rle-method pmax,Rle-method pmin,Rle-method
> ###   pmax.int,Rle-method pmin.int,Rle-method which.max,Rle-method diff.Rle
> ###   diff,Rle-method mean.Rle mean,Rle-method var,Rle,missing-method
> ###   var,Rle,Rle-method cov,Rle,Rle-method cor,Rle,Rle-method
> ###   sd,Rle-method median.Rle median,Rle-method quantile.Rle
> ###   quantile,Rle-method mad.Rle mad,Rle-method IQR,Rle-method
> ###   nchar,Rle-method substr,Rle-method substring,Rle-method
> ###   chartr,ANY,ANY,Rle-method tolower,Rle-method toupper,Rle-method
> ###   sub,ANY,ANY,Rle-method gsub,ANY,ANY,Rle-method paste,Rle-method
> ###   levels.Rle levels,Rle-method levels<-,Rle-method droplevels.Rle
> ###   droplevels,Rle-method
> ### Keywords: utilities methods arith
> 
> ### ** Examples
> 
> x <- Rle(10:1, 1:10)
> x
integer-Rle of length 55 with 10 runs
  Lengths:  1  2  3  4  5  6  7  8  9 10
  Values : 10  9  8  7  6  5  4  3  2  1
> 
> sqrt(x)
numeric-Rle of length 55 with 10 runs
  Lengths:       1       2       3       4 ...       7       8       9      10
  Values : 3.16228 3.00000 2.82843 2.64575 ... 2.00000 1.73205 1.41421 1.00000
> x^2 + 2 * x + 1
numeric-Rle of length 55 with 10 runs
  Lengths:   1   2   3   4   5   6   7   8   9  10
  Values : 121 100  81  64  49  36  25  16   9   4
> range(x)
[1]  1 10
> sum(x)
[1] 220
> mean(x)
[1] 4
> 
> z <- c("the", "quick", "red", "fox", "jumps", "over", "the", "lazy", "brown", "dog")
> z <- Rle(z, seq_len(length(z)))
> chartr("a", "@", z)
 [1] "the"   "quick" "quick" "red"   "red"   "red"   "fox"   "fox"   "fox"  
[10] "fox"   "jumps" "jumps" "jumps" "jumps" "jumps" "over"  "over"  "over" 
[19] "over"  "over"  "over"  "the"   "the"   "the"   "the"   "the"   "the"  
[28] "the"   "l@zy"  "l@zy"  "l@zy"  "l@zy"  "l@zy"  "l@zy"  "l@zy"  "l@zy" 
[37] "brown" "brown" "brown" "brown" "brown" "brown" "brown" "brown" "brown"
[46] "dog"   "dog"   "dog"   "dog"   "dog"   "dog"   "dog"   "dog"   "dog"  
[55] "dog"  
> toupper(z)
 [1] "THE"   "QUICK" "QUICK" "RED"   "RED"   "RED"   "FOX"   "FOX"   "FOX"  
[10] "FOX"   "JUMPS" "JUMPS" "JUMPS" "JUMPS" "JUMPS" "OVER"  "OVER"  "OVER" 
[19] "OVER"  "OVER"  "OVER"  "THE"   "THE"   "THE"   "THE"   "THE"   "THE"  
[28] "THE"   "LAZY"  "LAZY"  "LAZY"  "LAZY"  "LAZY"  "LAZY"  "LAZY"  "LAZY" 
[37] "BROWN" "BROWN" "BROWN" "BROWN" "BROWN" "BROWN" "BROWN" "BROWN" "BROWN"
[46] "DOG"   "DOG"   "DOG"   "DOG"   "DOG"   "DOG"   "DOG"   "DOG"   "DOG"  
[55] "DOG"  
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("Rle-utils", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("SimpleList-class")
> ### * SimpleList-class
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: SimpleList-class
> ### Title: SimpleList objects
> ### Aliases: class:SimpleList SimpleList SimpleList-class
> ###   parallel_slot_names,SimpleList-method updateObject,SimpleList-method
> ###   names,SimpleList-method names<-,SimpleList-method
> ###   as.list,SimpleList-method coerce,ANY,SimpleList-method
> ###   coerce,list,List-method as.env,SimpleList-method
> ###   lapply,SimpleList-method classNameForDisplay,SimpleList-method
> ### Keywords: methods classes
> 
> ### ** Examples
> 
> ## Displaying a SimpleList object:
> x1 <- SimpleList(a=letters, i=Rle(22:20, 4:2))
> class(x1)
[1] "SimpleList"
attr(,"package")
[1] "S4Vectors"
> 
> ## The "Simple" prefix is removed from the real class name of the
> ## object:
> x1
List of length 2
names(2): a i
> 
> library(IRanges)
> x2 <- IntegerList(11:12, integer(0), 3:-2, compress=FALSE)
> class(x2)
[1] "SimpleIntegerList"
attr(,"package")
[1] "IRanges"
> 
> ## The "Simple" prefix is removed from the real class name of the
> ## object:
> x2
IntegerList of length 3
[[1]] 11 12
[[2]] integer(0)
[[3]] 3 2 1 0 -1 -2
> 
> ## This is controlled by internal helper classNameForDisplay():
> classNameForDisplay(x2)
[1] "IntegerList"
attr(,"package")
[1] "IRanges"
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("SimpleList-class", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:IRanges’

> nameEx("TransposedDataFrame-class")
> ### * TransposedDataFrame-class
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: TransposedDataFrame-class
> ### Title: TransposedDataFrame objects
> ### Aliases: class:TransposedDataFrame TransposedDataFrame-class
> ###   TransposedDataFrame t.DataFrame t,DataFrame-method
> ###   t.TransposedDataFrame t,TransposedDataFrame-method
> ###   dim,TransposedDataFrame-method length,TransposedDataFrame-method
> ###   dimnames,TransposedDataFrame-method names,TransposedDataFrame-method
> ###   dimnames<-,TransposedDataFrame-method
> ###   names<-,TransposedDataFrame-method
> ###   extractROWS,TransposedDataFrame,ANY-method
> ###   extractCOLS,TransposedDataFrame-method [,TransposedDataFrame-method
> ###   getListElement,TransposedDataFrame-method
> ###   coerce,DataFrame,TransposedDataFrame-method
> ###   coerce,TransposedDataFrame,DataFrame-method
> ###   as.matrix,TransposedDataFrame-method
> ###   as.list,TransposedDataFrame-method
> ###   coerce,list,TransposedDataFrame-method
> ###   makeNakedCharacterMatrixForDisplay,TransposedDataFrame-method
> ###   show,TransposedDataFrame-method bindROWS,TransposedDataFrame-method
> ###   bindCOLS,TransposedDataFrame-method
> ### Keywords: methods classes
> 
> ### ** Examples
> 
> ## A DataFrame object with 3 variables:
> df <- DataFrame(aa=101:126, bb=letters, cc=Rle(c(TRUE, FALSE), 13),
+                 row.names=LETTERS)
> dim(df)
[1] 26  3
> length(df)
[1] 3
> df$aa
 [1] 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119
[20] 120 121 122 123 124 125 126
> 
> tdf <- t(df)
> tdf
TransposedDataFrame with 3 rows and 26 columns
                  A    B    C    D    E    F    G    H    I    J    K    L    M
aa <integer>    101  102  103  104  105  106  107  108  109  110  111  112  113
bb <character>    a    b    c    d    e    f    g    h    i    j    k    l    m
cc <Rle>       TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
                   N     O     P     Q     R     S     T     U     V     W
aa <integer>     114   115   116   117   118   119   120   121   122   123
bb <character>     n     o     p     q     r     s     t     u     v     w
cc <Rle>       FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
                   X     Y     Z
aa <integer>     124   125   126
bb <character>     x     y     z
cc <Rle>       FALSE FALSE FALSE
> dim(tdf)
[1]  3 26
> length(tdf)
[1] 3
> tdf$aa
 [1] 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119
[20] 120 121 122 123 124 125 126
> 
> t(tdf)  # back to 'df'
DataFrame with 26 rows and 3 columns
           aa          bb    cc
    <integer> <character> <Rle>
A         101           a  TRUE
B         102           b  TRUE
C         103           c  TRUE
D         104           d  TRUE
E         105           e  TRUE
...       ...         ...   ...
V         122           v FALSE
W         123           w FALSE
X         124           x FALSE
Y         125           y FALSE
Z         126           z FALSE
> stopifnot(identical(df, t(tdf)))
> 
> tdf$aa <- 0.05 * tdf$aa
> 
> x1 <- DataFrame(A=1:5, B=letters[1:5], C=11:15)
> y1 <- DataFrame(B=c(FALSE, NA, TRUE), C=c(FALSE, NA, TRUE), A=101:103)
> cbind(t(x1), t(y1))
TransposedDataFrame with 3 rows and 8 columns
               1  2  3  4  5     6   7    8
A <integer>    1  2  3  4  5   101 102  103
B <character>  a  b  c  d  e FALSE  NA TRUE
C <integer>   11 12 13 14 15     0  NA    1
> stopifnot(identical(t(rbind(x1, y1)), cbind(t(x1), t(y1))))
> 
> ## A TransposedDataFrame object can be used in the assay() component of a
> ## SummarizedExperiment object if the transposed layout is needed i.e. if
> ## the rows and columns of the original DataFrame object need to be treated
> ## as the samples and features (in this order) of the SummarizedExperiment
> ## object:
> library(SummarizedExperiment)
Loading required package: MatrixGenerics
Loading required package: matrixStats

Attaching package: ‘MatrixGenerics’

The following objects are masked from ‘package:matrixStats’:

    colAlls, colAnyNAs, colAnys, colAvgsPerRowSet, colCollapse,
    colCounts, colCummaxs, colCummins, colCumprods, colCumsums,
    colDiffs, colIQRDiffs, colIQRs, colLogSumExps, colMadDiffs,
    colMads, colMaxs, colMeans2, colMedians, colMins, colOrderStats,
    colProds, colQuantiles, colRanges, colRanks, colSdDiffs, colSds,
    colSums2, colTabulates, colVarDiffs, colVars, colWeightedMads,
    colWeightedMeans, colWeightedMedians, colWeightedSds,
    colWeightedVars, rowAlls, rowAnyNAs, rowAnys, rowAvgsPerColSet,
    rowCollapse, rowCounts, rowCummaxs, rowCummins, rowCumprods,
    rowCumsums, rowDiffs, rowIQRDiffs, rowIQRs, rowLogSumExps,
    rowMadDiffs, rowMads, rowMaxs, rowMeans2, rowMedians, rowMins,
    rowOrderStats, rowProds, rowQuantiles, rowRanges, rowRanks,
    rowSdDiffs, rowSds, rowSums2, rowTabulates, rowVarDiffs, rowVars,
    rowWeightedMads, rowWeightedMeans, rowWeightedMedians,
    rowWeightedSds, rowWeightedVars

Loading required package: GenomicRanges
Loading required package: IRanges
Loading required package: GenomeInfoDb
Loading required package: Biobase
Welcome to Bioconductor

    Vignettes contain introductory material; view with
    'browseVignettes()'. To cite Bioconductor, see
    'citation("Biobase")', and for packages 'citation("pkgname")'.


Attaching package: ‘Biobase’

The following object is masked from ‘package:MatrixGenerics’:

    rowMedians

The following objects are masked from ‘package:matrixStats’:

    anyMissing, rowMedians

> se1 <- SummarizedExperiment(df)
> se1
class: SummarizedExperiment 
dim: 26 3 
metadata(0):
assays(1): ''
rownames(26): A B ... Y Z
rowData names(0):
colnames(3): aa bb cc
colData names(0):
> assay(se1)  # the 3 variables run "vertically"
DataFrame with 26 rows and 3 columns
           aa          bb    cc
    <integer> <character> <Rle>
A         101           a  TRUE
B         102           b  TRUE
C         103           c  TRUE
D         104           d  TRUE
E         105           e  TRUE
...       ...         ...   ...
V         122           v FALSE
W         123           w FALSE
X         124           x FALSE
Y         125           y FALSE
Z         126           z FALSE
> 
> se2 <- SummarizedExperiment(tdf)
> se2
class: SummarizedExperiment 
dim: 3 26 
metadata(0):
assays(1): ''
rownames(3): aa bb cc
rowData names(0):
colnames(26): A B ... Y Z
colData names(0):
> assay(se2)  # the 3 variables run "horizontally"
TransposedDataFrame with 3 rows and 26 columns
                  A    B    C    D    E    F    G    H    I    J    K    L    M
aa <numeric>   5.05 5.10 5.15 5.20 5.25 5.30 5.35 5.40 5.45 5.50 5.55 5.60 5.65
bb <character>    a    b    c    d    e    f    g    h    i    j    k    l    m
cc <Rle>       TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
                   N     O     P     Q     R     S     T     U     V     W
aa <numeric>    5.70  5.75  5.80  5.85  5.90  5.95  6.00  6.05  6.10  6.15
bb <character>     n     o     p     q     r     s     t     u     v     w
cc <Rle>       FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
                   X     Y     Z
aa <numeric>    6.20  6.25  6.30
bb <character>     x     y     z
cc <Rle>       FALSE FALSE FALSE
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("TransposedDataFrame-class", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:SummarizedExperiment’, ‘package:Biobase’,
  ‘package:GenomicRanges’, ‘package:GenomeInfoDb’, ‘package:IRanges’,
  ‘package:MatrixGenerics’, ‘package:matrixStats’

> nameEx("Vector-class")
> ### * Vector-class
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: Vector-class
> ### Title: Vector objects
> ### Aliases: class:Vector Vector-class Vector class:vector_OR_Vector
> ###   vector_OR_Vector-class vector_OR_Vector parallel_slot_names
> ###   parallel_slot_names,Vector-method updateObject,Vector-method
> ###   length,Vector-method lengths,Vector-method elementMetadata
> ###   elementMetadata,Vector-method mcols mcols,Vector-method values
> ###   values,Vector-method anyNA,Vector-method is.na,Vector-method
> ###   elementMetadata<- elementMetadata<-,Vector-method mcols<-
> ###   mcols<-,Vector-method values<- values<-,Vector-method rename
> ###   rename,vector-method rename,Vector-method unname,Vector-method
> ###   as.logical,Vector-method as.integer,Vector-method
> ###   as.numeric,Vector-method as.double,Vector-method
> ###   as.complex,Vector-method as.character,Vector-method
> ###   as.raw,Vector-method as.matrix,Vector-method as.matrix.Vector
> ###   coerce,Vector,vector-method coerce,Vector,logical-method
> ###   coerce,Vector,integer-method coerce,Vector,numeric-method
> ###   coerce,Vector,double-method coerce,Vector,complex-method
> ###   coerce,Vector,character-method coerce,Vector,raw-method
> ###   coerce,Vector,factor-method coerce,Vector,data.frame-method
> ###   as.data.frame.Vector as.data.frame,Vector-method as.env
> ###   as.env,NULL-method as.env,Vector-method as.list.Vector
> ###   as.list,Vector-method [ [,Vector-method [<-,Vector-method
> ###   replaceROWS,Vector,ANY-method mergeROWS,Vector,ANY-method subset
> ###   subset.Vector subset,Vector-method window window.Vector
> ###   window,Vector-method head head.Vector head,Vector-method tail
> ###   tail.Vector tail,Vector-method rev rev.Vector rev,Vector-method rep
> ###   rep,Vector-method rep.int rep.int,Vector-method summary.Vector
> ###   summary,Vector-method bindROWS,Vector-method c c,Vector-method append
> ###   append,Vector,Vector-method transform.Vector transform,Vector-method
> ###   expand.grid expand.grid,Vector-method parallelVectorNames
> ###   parallelVectorNames,ANY-method
> ### Keywords: methods classes
> 
> ### ** Examples
> 
> showClass("Vector")  # shows (some of) the known subclasses
Virtual Class "Vector" [package "S4Vectors"]

Slots:
                                          
Name:    elementMetadata          metadata
Class: DataFrame_OR_NULL              list

Extends: "Annotated", "vector_OR_Vector"

Known Subclasses: 
Class "Hits", directly
Class "Rle", directly
Class "Factor", directly
Class "List", directly
Class "Pairs", directly
Class "SelfHits", by class "Hits", distance 2
Class "SortedByQueryHits", by class "Hits", distance 2
Class "SimpleList", by class "List", distance 2
Class "TransposedDataFrame", by class "List", distance 2
Class "SortedByQuerySelfHits", by class "Hits", distance 3
Class "SortedByQuerySelfHits", by class "Hits", distance 3
Class "HitsList", by class "List", distance 3
Class "DataFrame", by class "List", distance 3
Class "SelfHitsList", by class "List", distance 4
Class "SortedByQueryHitsList", by class "List", distance 4
Class "DFrame", by class "List", distance 4
Class "SortedByQuerySelfHitsList", by class "List", distance 5
Class "FilterRules", by class "SimpleList", distance 3
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("Vector-class", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("Vector-comparison")
> ### * Vector-comparison
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: Vector-comparison
> ### Title: Compare, order, tabulate vector-like objects
> ### Aliases: Vector-comparison pcompare pcompare,numeric,numeric-method
> ###   pcompare,ANY,ANY-method ==,Vector,Vector-method ==,Vector,ANY-method
> ###   ==,ANY,Vector-method <=,Vector,Vector-method <=,Vector,ANY-method
> ###   <=,ANY,Vector-method !=,Vector,Vector-method !=,Vector,ANY-method
> ###   !=,ANY,Vector-method >=,Vector,Vector-method >=,Vector,ANY-method
> ###   >=,ANY,Vector-method <,Vector,Vector-method <,Vector,ANY-method
> ###   <,ANY,Vector-method >,Vector,Vector-method >,Vector,ANY-method
> ###   >,ANY,Vector-method sameAsPreviousROW sameAsPreviousROW,ANY-method
> ###   match match,Vector,Vector-method selfmatch selfmatch,ANY-method
> ###   selfmatch,factor-method selfmatch,Vector-method duplicated.Vector
> ###   duplicated,Vector-method anyDuplicated.Vector
> ###   anyDuplicated,Vector-method unique.Vector unique,Vector-method
> ###   %in%,Vector,Vector-method %in%,Vector,ANY-method
> ###   %in%,ANY,Vector-method findMatches findMatches,ANY,ANY-method
> ###   findMatches,ANY,missing-method countMatches
> ###   countMatches,ANY,ANY-method sort.Vector sort,Vector-method
> ###   rank,Vector-method xtfrm,Vector-method table,Vector-method
> ### Keywords: methods
> 
> ### ** Examples
> 
> ## ---------------------------------------------------------------------
> ## A. SIMPLE EXAMPLES
> ## ---------------------------------------------------------------------
> 
> y <- c(16L, -3L, -2L, 15L, 15L, 0L, 8L, 15L, -2L)
> selfmatch(y)
[1] 1 2 3 4 4 6 7 4 3
> 
> x <- c(unique(y), 999L)
> findMatches(x, y)
Hits object with 9 hits and 0 metadata columns:
      queryHits subjectHits
      <integer>   <integer>
  [1]         1           1
  [2]         2           2
  [3]         3           3
  [4]         3           9
  [5]         4           4
  [6]         4           5
  [7]         4           8
  [8]         5           6
  [9]         6           7
  -------
  queryLength: 7 / subjectLength: 9
> countMatches(x, y)
[1] 1 1 2 3 1 1 0
> 
> ## See ?`IntegerRanges-comparison` for more examples (on IntegerRanges
> ## objects). You might need to load the IRanges package first.
> 
> ## ---------------------------------------------------------------------
> ## B. FOR DEVELOPERS: HOW TO IMPLEMENT THE BINARY COMPARISON OPERATORS
> ##    FOR YOUR Vector SUBCLASS
> ## ---------------------------------------------------------------------
> 
> ## The answer is: don't implement them. Just implement pcompare() and the
> ## binary comparison operators will work out-of-the-box. Here is an
> ## example:
> 
> ## (1) Implement a simple Vector subclass.
> 
> setClass("Raw", contains="Vector", representation(data="raw"))
> 
> setMethod("length", "Raw", function(x) length(x@data))
> 
> setMethod("[", "Raw",
+     function(x, i, j, ..., drop) { x@data <- x@data[i]; x }
+ )
> 
> x <- new("Raw", data=charToRaw("AB.x0a-BAA+C"))
> stopifnot(identical(length(x), 12L))
> stopifnot(identical(x[7:3], new("Raw", data=charToRaw("-a0x."))))
> 
> ## (2) Implement a "pcompare" method for Raw objects.
> 
> setMethod("pcompare", c("Raw", "Raw"),
+     function(x, y) {as.integer(x@data) - as.integer(y@data)}
+ )
> 
> stopifnot(identical(which(x == x[1]), c(1L, 9L, 10L)))
> stopifnot(identical(x[x < x[5]], new("Raw", data=charToRaw(".-+"))))
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("Vector-comparison", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("Vector-merge")
> ### * Vector-merge
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: Vector-merge
> ### Title: Merge vector-like objects
> ### Aliases: Vector-merge merge merge,Vector,Vector-method
> ### Keywords: methods
> 
> ### ** Examples
> 
> library(GenomicRanges)
Loading required package: IRanges
Loading required package: GenomeInfoDb
> x <- GRanges(c("chr1:1-1000", "chr2:2000-3000"),
+              score=c(0.45, 0.1), a1=c(5L, 7L), a2=c(6, 8))
> y <- GRanges(c("chr2:150-151", "chr1:1-10", "chr2:2000-3000"),
+              score=c(0.7, 0.82, 0.1), b1=c(0L, 5L, 1L), b2=c(1, -2, 1))
> merge(x, y)
GRanges object with 1 range and 5 metadata columns:
      seqnames    ranges strand |     score        a1        a2        b1
         <Rle> <IRanges>  <Rle> | <numeric> <integer> <numeric> <integer>
  [1]     chr2 2000-3000      * |       0.1         7         8         1
             b2
      <numeric>
  [1]         1
  -------
  seqinfo: 2 sequences from an unspecified genome; no seqlengths
> merge(x, y, all=TRUE)
GRanges object with 4 ranges and 5 metadata columns:
      seqnames    ranges strand |     score        a1        a2        b1
         <Rle> <IRanges>  <Rle> | <numeric> <integer> <numeric> <integer>
  [1]     chr1      1-10      * |      0.82      <NA>        NA         5
  [2]     chr1    1-1000      * |      0.45         5         6      <NA>
  [3]     chr2   150-151      * |      0.70      <NA>        NA         0
  [4]     chr2 2000-3000      * |      0.10         7         8         1
             b2
      <numeric>
  [1]        -2
  [2]        NA
  [3]         1
  [4]         1
  -------
  seqinfo: 2 sequences from an unspecified genome; no seqlengths
> merge(x, y, all.x=TRUE)
GRanges object with 2 ranges and 5 metadata columns:
      seqnames    ranges strand |     score        a1        a2        b1
         <Rle> <IRanges>  <Rle> | <numeric> <integer> <numeric> <integer>
  [1]     chr1    1-1000      * |      0.45         5         6      <NA>
  [2]     chr2 2000-3000      * |      0.10         7         8         1
             b2
      <numeric>
  [1]        NA
  [2]         1
  -------
  seqinfo: 2 sequences from an unspecified genome; no seqlengths
> merge(x, y, all.y=TRUE)
GRanges object with 3 ranges and 5 metadata columns:
      seqnames    ranges strand |     score        a1        a2        b1
         <Rle> <IRanges>  <Rle> | <numeric> <integer> <numeric> <integer>
  [1]     chr2   150-151      * |      0.70      <NA>        NA         0
  [2]     chr2 2000-3000      * |      0.10         7         8         1
  [3]     chr1      1-10      * |      0.82      <NA>        NA         5
             b2
      <numeric>
  [1]         1
  [2]         1
  [3]        -2
  -------
  seqinfo: 2 sequences from an unspecified genome; no seqlengths
> 
> ## Shared metadata columns must agree:
> mcols(x)$score[2] <- 0.11
> #merge(x, y)  # error!
> 
> ## NAs agree with anything:
> mcols(x)$score[2] <- NA
> merge(x, y)
GRanges object with 1 range and 5 metadata columns:
      seqnames    ranges strand |     score        a1        a2        b1
         <Rle> <IRanges>  <Rle> | <numeric> <integer> <numeric> <integer>
  [1]     chr2 2000-3000      * |       0.1         7         8         1
             b2
      <numeric>
  [1]         1
  -------
  seqinfo: 2 sequences from an unspecified genome; no seqlengths
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("Vector-merge", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:GenomicRanges’, ‘package:GenomeInfoDb’,
  ‘package:IRanges’

> nameEx("Vector-setops")
> ### * Vector-setops
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: Vector-setops
> ### Title: Set operations on vector-like objects
> ### Aliases: Vector-setops union.Vector union,Vector,Vector-method
> ###   intersect.Vector intersect,Vector,Vector-method setdiff.Vector
> ###   setdiff,Vector,Vector-method setequal.Vector
> ###   setequal,Vector,Vector-method
> ### Keywords: methods
> 
> ### ** Examples
> 
> ## See ?`Hits-setops` for some examples.
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("Vector-setops", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("aggregate-methods")
> ### * aggregate-methods
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: aggregate-methods
> ### Title: Compute summary statistics of subsets of vector-like objects
> ### Aliases: aggregate-methods aggregate aggregate,matrix-method
> ###   aggregate,data.frame-method aggregate,ts-method aggregate.Vector
> ###   aggregate,Vector-method aggregate,Rle-method aggregate,List-method
> ### Keywords: methods utilities
> 
> ### ** Examples
> 
> x <- Rle(10:2, 1:9)
> aggregate(x, x > 4, mean)
[1] 6.666667 2.916667
> aggregate(x, FUN=mean, start=1:26, width=20)
 [1] 6.75 6.50 6.25 6.00 5.80 5.60 5.40 5.25 5.10 4.90 4.70 4.55 4.40 4.25 4.10
[16] 3.95 3.85 3.70 3.55 3.40 3.25 3.10 3.00 2.90 2.80 2.70
> 
> ## Note that aggregate() works on a DataFrame object the same way it
> ## works on an ordinary data frame:
> aggregate(DataFrame(state.x77), list(Region=state.region), mean)
DataFrame with 4 rows and 9 columns
         Region Population    Income Illiteracy  Life.Exp    Murder   HS.Grad
       <factor>  <numeric> <numeric>  <numeric> <numeric> <numeric> <numeric>
1 Northeast        5495.11   4570.22    1.00000   71.2644   4.72222   53.9667
2 South            4208.12   4011.94    1.73750   69.7062  10.58125   44.3438
3 North Central    4803.00   4611.08    0.70000   71.7667   5.27500   54.5167
4 West             2915.31   4702.62    1.02308   71.2346   7.21538   62.0000
      Frost      Area
  <numeric> <numeric>
1   132.778   18141.0
2    64.625   54605.1
3   138.833   62652.0
4   102.154  134463.0
> aggregate(weight ~ feed, data=DataFrame(chickwts), mean)
       feed   weight
1    casein 323.5833
2 horsebean 160.2000
3   linseed 218.7500
4  meatmeal 276.9091
5   soybean 246.4286
6 sunflower 328.9167
> 
> library(IRanges)
> by <- IRanges(start=1:26, width=20, names=LETTERS)
> aggregate(x, by, is.unsorted)
   A    B    C    D    E    F    G    H    I    J    K    L    M    N    O    P 
TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE 
   Q    R    S    T    U    V    W    X    Y    Z 
TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("aggregate-methods", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:IRanges’

> nameEx("character-utils")
> ### * character-utils
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: character-utils
> ### Title: Some utility functions to operate on strings
> ### Aliases: unstrsplit unstrsplit,list-method unstrsplit,character-method
> ###   safeExplode svn.time
> ### Keywords: utilities
> 
> ### ** Examples
> 
> x <- list(A=c("abc", "XY"), B=NULL, C=letters[1:4])
> unstrsplit(x)
      A       B       C 
"abcXY"      ""  "abcd" 
> unstrsplit(x, sep=",")
        A         B         C 
 "abc,XY"        "" "a,b,c,d" 
> unstrsplit(x, sep=" => ")
                 A                  B                  C 
       "abc => XY"                 "" "a => b => c => d" 
> 
> data(islands)
> x <- names(islands)
> y <- strsplit(x, split=" ", fixed=TRUE)
> x2 <- unstrsplit(y, sep=" ")
> stopifnot(identical(x, x2))
> 
> ## But...
> names(x) <- x
> y <- strsplit(x, split="in", fixed=TRUE)
> x2 <- unstrsplit(y, sep="in")
> y[x != x2]
$Baffin
[1] "Baff"

$Britain
[1] "Brita"

$`New Britain`
[1] "New Brita"

$Sakhalin
[1] "Sakhal"

> ## In other words: strsplit() behavior sucks :-/
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("character-utils", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("expand-methods")
> ### * expand-methods
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: expand
> ### Title: Unlist the list-like columns of a DataFrame object
> ### Aliases: expand expand,DataFrame-method expand,Vector-method
> ### Keywords: methods
> 
> ### ** Examples
> 
> library(IRanges)
> aa <- CharacterList("a", paste0("d", 1:2), paste0("b", 1:3), c(), "c")
> bb <- CharacterList(paste0("sna", 1:2),"foo", paste0("bar",1:3),c(),"hica")
> df <- DataFrame(aa=aa, bb=bb, cc=11:15)
> 
> ## Expand by all list-like columns (aa, bb), dropping rows with empty
> ## list elements:
> expand(df)
DataFrame with 14 rows and 3 columns
             aa          bb        cc
    <character> <character> <integer>
1             a        sna1        11
2             a        sna2        11
3            d1         foo        12
4            d2         foo        12
5            b1        bar1        13
...         ...         ...       ...
10           b2        bar3        13
11           b3        bar1        13
12           b3        bar2        13
13           b3        bar3        13
14            c        hica        15
> 
> ## Expand the aa column only:
> expand(df, colnames="aa", keepEmptyRows=TRUE)
DataFrame with 8 rows and 3 columns
           aa              bb        cc
  <character> <CharacterList> <integer>
1           a       sna1,sna2        11
2          d1             foo        12
3          d2             foo        12
4          b1  bar1,bar2,bar3        13
5          b2  bar1,bar2,bar3        13
6          b3  bar1,bar2,bar3        13
7          NA                        14
8           c            hica        15
> expand(df, colnames="aa", keepEmptyRows=FALSE)
DataFrame with 7 rows and 3 columns
           aa              bb        cc
  <character> <CharacterList> <integer>
1           a       sna1,sna2        11
2          d1             foo        12
3          d2             foo        12
4          b1  bar1,bar2,bar3        13
5          b2  bar1,bar2,bar3        13
6          b3  bar1,bar2,bar3        13
7           c            hica        15
> 
> ## Expand the aa and then the bb column:
> expand(df, colnames=c("aa","bb"), keepEmptyRows=TRUE)
DataFrame with 15 rows and 3 columns
             aa          bb        cc
    <character> <character> <integer>
1             a        sna1        11
2             a        sna2        11
3            d1         foo        12
4            d2         foo        12
5            b1        bar1        13
...         ...         ...       ...
11           b3        bar1        13
12           b3        bar2        13
13           b3        bar3        13
14           NA          NA        14
15            c        hica        15
> expand(df, colnames=c("aa","bb"), keepEmptyRows=FALSE)
DataFrame with 14 rows and 3 columns
             aa          bb        cc
    <character> <character> <integer>
1             a        sna1        11
2             a        sna2        11
3            d1         foo        12
4            d2         foo        12
5            b1        bar1        13
...         ...         ...       ...
10           b2        bar3        13
11           b3        bar1        13
12           b3        bar2        13
13           b3        bar3        13
14            c        hica        15
> 
> ## Expand the aa and dd column in parallel:
> df$dd <- relist(seq_along(unlist(aa)), aa)
> expand(df, colnames=c("aa","dd"), recursive=FALSE)
DataFrame with 7 rows and 4 columns
           aa              bb        cc        dd
  <character> <CharacterList> <integer> <integer>
1           a       sna1,sna2        11         1
2          d1             foo        12         2
3          d2             foo        12         3
4          b1  bar1,bar2,bar3        13         4
5          b2  bar1,bar2,bar3        13         5
6          b3  bar1,bar2,bar3        13         6
7           c            hica        15         7
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("expand-methods", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:IRanges’

> nameEx("integer-utils")
> ### * integer-utils
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: integer-utils
> ### Title: Some utility functions to operate on integer vectors
> ### Aliases: isSequence toListOfIntegerVectors orderIntegerPairs
> ###   matchIntegerPairs selfmatchIntegerPairs duplicatedIntegerPairs
> ###   orderIntegerQuads matchIntegerQuads selfmatchIntegerQuads
> ###   duplicatedIntegerQuads
> ### Keywords: utilities
> 
> ### ** Examples
> 
> ## ---------------------------------------------------------------------
> ## isSequence()
> ## ---------------------------------------------------------------------
> isSequence(1:5)               # TRUE
[1] TRUE
> isSequence(5:1)               # FALSE
[1] FALSE
> isSequence(0:5)               # FALSE
[1] FALSE
> isSequence(integer(0))        # TRUE
[1] TRUE
> isSequence(1:5, of.length=5)  # TRUE (the expected length)
[1] TRUE
> isSequence(1:5, of.length=6)  # FALSE (not the expected length)
[1] FALSE
> 
> ## ---------------------------------------------------------------------
> ## toListOfIntegerVectors()
> ## ---------------------------------------------------------------------
> 
> x <- c("1116,0,-19",
+        " +55291 , 2476,",
+        "19184,4269,5659,6470,6721,7469,14601",
+        "7778889, 426900, -4833,5659,6470,6721,7096",
+        "19184 , -99999")
> 
> y <- toListOfIntegerVectors(x)
> y
[[1]]
[1] 1116    0  -19

[[2]]
[1] 55291  2476

[[3]]
[1] 19184  4269  5659  6470  6721  7469 14601

[[4]]
[1] 7778889  426900   -4833    5659    6470    6721    7096

[[5]]
[1]  19184 -99999

> 
> ## When it doesn't choke on an NA or string that doesn't represent
> ## an integer value, toListOfIntegerVectors() is equivalent to
> ## the function below but is faster and more memory-efficient:
> toListOfIntegerVectors2 <- function(x, sep=",")
+ {
+     lapply(strsplit(x, sep, fixed=TRUE), as.integer)
+ }
> y2 <- toListOfIntegerVectors2(x)
> stopifnot(identical(y, y2))
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("integer-utils", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("isSorted")
> ### * isSorted
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: isSorted
> ### Title: Test if a vector-like object is sorted
> ### Aliases: isSorted isSorted,ANY-method isConstant
> ###   isConstant,integer-method isConstant,numeric-method
> ###   isConstant,array-method isStrictlySorted isStrictlySorted,ANY-method
> ### Keywords: utilities
> 
> ### ** Examples
> 
> ## ---------------------------------------------------------------------
> ## A. isSorted() and isStrictlySorted()
> ## ---------------------------------------------------------------------
> 
> x <- 1:10
> 
> isSorted(x)           # TRUE
[1] TRUE
> isSorted(-x)          # FALSE
[1] FALSE
> isSorted(rev(x))      # FALSE
[1] FALSE
> isSorted(-rev(x))     # TRUE
[1] TRUE
> 
> isStrictlySorted(x)   # TRUE
[1] TRUE
> 
> x2 <- rep(x, each=2)
> isSorted(x2)          # TRUE
[1] TRUE
> isStrictlySorted(x2)  # FALSE
[1] FALSE
> 
> ## ---------------------------------------------------------------------
> ## B. "isConstant" METHOD FOR integer VECTORS
> ## ---------------------------------------------------------------------
> 
> ## On a vector with no NAs:
> stopifnot(isConstant(rep(-29L, 10000)))
> 
> ## On a vector with NAs:
> stopifnot(!isConstant(c(0L, NA, -29L)))
> stopifnot(is.na(isConstant(c(-29L, -29L, NA))))
>  
> ## On a vector of length <= 1:
> stopifnot(isConstant(NA_integer_))
> 
> 
> ## ---------------------------------------------------------------------
> ## C. "isConstant" METHOD FOR numeric VECTORS
> ## ---------------------------------------------------------------------
> ## This method does its best to handle rounding errors and special
> ## values NA, NaN, Inf and -Inf in a way that "makes sense".
> ## Below we only illustrate handling of rounding errors.
> 
> ## Here values in 'x' are "conceptually" the same:
> x <- c(11/3,
+        2/3 + 4/3 + 5/3,
+        50 + 11/3 - 50,
+        7.00001 - 1000003/300000)
> ## However, due to machine rounding errors, they are not *strictly*
> ## equal:
> duplicated(x)
[1] FALSE FALSE FALSE FALSE
> unique(x)
[1] 3.666667 3.666667 3.666667 3.666667
> ## only *nearly* equal:
> all.equal(x, rep(11/3, 4))  # TRUE
[1] TRUE
> 
> ## 'isConstant(x)' uses 'all.equal()' internally to decide whether
> ## the values in 'x' are all the same or not:
> stopifnot(isConstant(x))
> 
> ## This is not perfect though:
> isConstant((x - 11/3) * 1e8)  # FALSE on Intel Pentium paltforms
[1] FALSE
>                               # (but this is highly machine dependent!)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("isSorted", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("shiftApply-methods")
> ### * shiftApply-methods
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: shiftApply-methods
> ### Title: Apply a function over subsequences of 2 vector-like objects
> ### Aliases: shiftApply-methods shiftApply shiftApply,Vector,Vector-method
> ###   shiftApply,vector,vector-method
> ### Keywords: methods utilities
> 
> ### ** Examples
> 
> set.seed(0)
> lambda <- c(rep(0.001, 4500), seq(0.001, 10, length = 500),
+             seq(10, 0.001, length = 500))
> xRle <- Rle(rpois(1e7, lambda))
> yRle <- Rle(rpois(1e7, lambda[c(251:length(lambda), 1:250)]))
> 
> cor(xRle, yRle)
[1] 0.5739224
> shifts <- seq(235, 265, by=3)
> corrs <- shiftApply(shifts, yRle, xRle, FUN=cor)
> 
> cor(xRle, yRle)
[1] 0.5739224
> shiftApply(249:251, yRle, xRle,
+            FUN=function(x, y) var(x, y) / (sd(x) * sd(y)))
[1] 0.8519138 0.8517324 0.8517725
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("shiftApply-methods", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("splitAsList")
> ### * splitAsList
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: splitAsList
> ### Title: Divide a vector-like object into groups
> ### Aliases: relistToClass relistToClass,ANY-method splitAsList
> ###   splitAsList,ANY,ANY-method split split,Vector,ANY-method
> ###   split,ANY,Vector-method split,Vector,Vector-method
> ###   split,list,Vector-method
> ### Keywords: methods
> 
> ### ** Examples
> 
> ## On an Rle object:
> x <- Rle(101:105, 6:2)
> split(x, c("B", "B", "A", "B", "A"))
RleList of length 2
$A
integer-Rle of length 8 with 5 runs
  Lengths:   2   2   2   1   1
  Values : 101 102 103 104 105

$B
integer-Rle of length 12 with 5 runs
  Lengths:   4   3   2   2   1
  Values : 101 102 103 104 105

> 
> ## On a DataFrame object:
> groups <- c("group1", "group2")
> DF <- DataFrame(
+     a=letters[1:10],
+     i=101:110,
+     group=rep(factor(groups, levels=groups), c(3, 7))
+ )
> split(DF, DF$group)
SplitDataFrameList of length 2
$group1
DataFrame with 3 rows and 3 columns
            a         i    group
  <character> <integer> <factor>
1           a       101   group1
2           b       102   group1
3           c       103   group1

$group2
DataFrame with 7 rows and 3 columns
            a         i    group
  <character> <integer> <factor>
1           d       104   group2
2           e       105   group2
3           f       106   group2
4           g       107   group2
5           h       108   group2
6           i       109   group2
7           j       110   group2

> 
> ## Use splitAsList() if you need to split an ordinary vector into a
> ## List object:
> split(letters, 1:2)        # ordinary list
$`1`
 [1] "a" "c" "e" "g" "i" "k" "m" "o" "q" "s" "u" "w" "y"

$`2`
 [1] "b" "d" "f" "h" "j" "l" "n" "p" "r" "t" "v" "x" "z"

> splitAsList(letters, 1:2)  # List object
CharacterList of length 2
[["1"]] a c e g i k m o q s u w y
[["2"]] b d f h j l n p r t v x z
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("splitAsList", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("stack-methods")
> ### * stack-methods
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: stack-methods
> ### Title: Stack objects
> ### Aliases: stack-methods stack,List-method stack,matrix-method mstack
> ###   mstack,Vector-method mstack,vector-method mstack,DataFrame-method
> ### Keywords: methods utilities
> 
> ### ** Examples
> 
> library(IRanges)
> starts <- IntegerList(c(1, 5), c(2, 8))
> ends <- IntegerList(c(3, 8), c(5, 9))
> rgl <- IRangesList(start=starts, end=ends)
> rangeDataFrame <- stack(rgl, "space", "ranges")
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("stack-methods", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:IRanges’

> nameEx("zip-methods")
> ### * zip-methods
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: zip-methods
> ### Title: Convert between parallel vectors and lists
> ### Aliases: zipup zipup,ANY,ANY-method zipdown zipdown,ANY-method
> ###   zipdown,List-method
> ### Keywords: methods
> 
> ### ** Examples
> 
> z <- zipup(1:10, Rle(1L, 10))
> pairs <- zipdown(z)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("zip-methods", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  24.657 0.972 25.632 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
