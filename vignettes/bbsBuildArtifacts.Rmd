---
title: "bbsBuildArtifacts: filtering build reports"
author: "Vincent J. Carey, stvjc at channing.harvard.edu"
date: "`r format(Sys.time(), '%B %d, %Y')`"
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{bbsBuildArtifacts: filtering build reports}
  %\VignetteEncoding{UTF-8}
output:
  BiocStyle::html_document:
    highlight: pygments
    number_sections: yes
    theme: united
    toc: yes
---

# Introduction

We'd like to be able to get a quick overview of status for a
subset of Bioconductor packages.  "Status" is relative to
Bioconductor version, package version, build platform, and
condition of the platform.

## New approach, December 2021

We want to be able to work with the current artifacts provided
at, e.g., `https://bioconductor.org/checkResults/3.15/bioc-LATEST/report.tgz`.
Such gzipped tar resources are prepared for different types
of resource.

```{r lktypes}
suppressPackageStartupMessages({
  library(bbsBuildArtifacts)
  library(dplyr)
  library(DT)
  library(ggplot2)
})
bbsBuildArtifacts:::valid_types()
```

We'll focus on type `bioc` for now, which associates with Software packages.
We don't know if all types are handled in the same way, but we hope so.

Our objective is to learn the status and processing times for
various phases of the build process for all packages.

### Artifact set manager

We define an S4 class to manage key information about builds.

```{r usecl, cache=TRUE}
af = setup_artifacts(type="bioc", version="3.14")
af
d = as.data.frame(af)
dim(d)
head(d)
sapply(split(d$elapsed_time, d$host), sum, na.rm=TRUE)/3600 # hours
sapply(split(d$elapsed_time, d$phase), sum, na.rm=TRUE)/3600 # hours
ggplot(mutate(d, elapsed_time_sec=elapsed_time), aes(y=elapsed_time_sec, x=host)) + 
    geom_boxplot() + facet_grid(.~phase) + scale_y_log10() 
```

### Digging deeper

We want to extract details on errors.

```{r lkhd}
package_by_host_data(af@pkg_paths["AlpsNMR"], host="tokay2")
```

Because the full check logs are available, we can use rcmdcheck check_details/parse_check
to get more details on events.

## Some details

### Download and cache the report.tgz

```{r demo1}
our_cache = BiocFileCache::BiocFileCache()
cid = get_report_tgz_cacheid(version = "3.14", type="bioc", cache=our_cache)
cid
our_cache[cid] # metadata
our_cache[[cid]]  # actual path
```

There is an unexported helper function to clean the cache of
a path for a given version/type combination.

### Process install-, build-, and check-related contents of a package

We do not cache the untarred data.  The untar process must
occur each time we want to analyze the artifacts.

```{r lkallp}
allpaths = artifact_folder_paths(version = "3.14", type="bioc", cache=BiocFileCache::BiocFileCache())
allpaths
```

The `package_by_host_data` function will parse the DCF files
created for each package by the BBS.

```{r lkpbh}
allpaths["parody"] # simple retrieval
package_by_host_data(allpaths["parody"])
```

We can produce a data table for a number of packages as follows.

```{r domore}
few = allpaths[1:10]
dcfs = lapply(few, function(x) simplify_artifact_build_dcfs(package_by_host_data(x)))
tab = do.call(rbind, unname(dcfs))
library(DT)
datatable(tab)
```

Building a comprehensive table requires some fault tolerance.  We
have used silent `try` calls in `package_by_host_data`; silent can
be set to FALSE if desired.

```{r doall}
suppressWarnings({
alldcfs = lapply(allpaths, function(x) simplify_artifact_build_dcfs(package_by_host_data(x)))
})
fulltab = do.call(rbind, unname(alldcfs))
```

Let's get a sense of the distribution of build times.

```{r lkbtr}
library(dplyr)
bdat = fulltab |> filter(phase=="buildsrc")
nrow(bdat)
hist(bdat$elapsed_time)
sum(bdat$elapsed_time > 600)
```



